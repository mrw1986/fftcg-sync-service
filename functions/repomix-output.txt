This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-20T06:59:40.307Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.eslintrc.fix.js
.eslintrc.js
.gitignore
package.json
src/config/firebase.ts
src/global.d.ts
src/index.ts
src/services/cardSync.ts
src/services/priceSync.ts
src/types/express.d.ts
src/types/index.ts
src/types/node.d.ts
src/utils/cache.ts
src/utils/logger.ts
src/utils/progress.ts
tsconfig.dev.json
tsconfig.json

================================================================
Repository Files
================================================================

================
File: .eslintrc.fix.js
================
module.exports = {
    extends: "./.eslintrc.js",
    rules: {
      "max-len": ["error", { "code": 120 }],
      "require-jsdoc": "off",
      "@typescript-eslint/no-explicit-any": "off",
      "@typescript-eslint/no-unused-vars": ["error", { 
        "argsIgnorePattern": "^_",
        "varsIgnorePattern": "^_"
      }]
    },
  };

================
File: .eslintrc.js
================
module.exports = {
  root: true,
  env: {
    es6: true,
    node: true,
  },
  extends: [
    "eslint:recommended",
    "plugin:import/errors",
    "plugin:import/warnings",
    "plugin:import/typescript",
    "google",
    "plugin:@typescript-eslint/recommended",
  ],
  parser: "@typescript-eslint/parser",
  parserOptions: {
    project: ["tsconfig.json", "tsconfig.dev.json"],
    sourceType: "module",
  },
  ignorePatterns: [
    "/lib/**/*", // Ignore built files.
    "/generated/**/*", // Ignore generated files.
  ],
  plugins: [
    "@typescript-eslint",
    "import",
  ],
  rules: {
    "quotes": ["error", "double"],
    "import/no-unresolved": 0,
    "indent": ["error", 2],
  },
};

================
File: .gitignore
================
# Compiled JavaScript files
lib/**/*.js
lib/**/*.js.map

# TypeScript v1 declaration files
typings/

# Node.js dependency directory
node_modules/
*.local

================
File: package.json
================
{
  "name": "functions",
  "scripts": {
    "clean": "rimraf lib",
    "lint": "eslint --ext .js,.ts .",
    "lint:fix": "eslint --ext .js,.ts . --fix",
    "build": "npm run clean && tsc",
    "build:watch": "tsc --watch",
    "serve": "npm run build && firebase emulators:start --only functions,firestore,storage",
    "shell": "npm run build && firebase functions:shell",
    "start": "npm run shell",
    "deploy": "npm run lint:fix && firebase deploy --only functions",
    "logs": "firebase functions:log"
  },
  "engines": {
    "node": "18"
  },
  "main": "lib/index.js",
  "dependencies": {
    "axios": "^1.7.7",
    "firebase-admin": "^12.0.0",
    "firebase-functions": "^5.1.0",
    "lru-cache": "^7.14.1"
  },
  "devDependencies": {
    "@types/express": "^4.17.21",
    "@types/node": "^18.0.0",
    "@typescript-eslint/eslint-plugin": "^6.0.0",
    "@typescript-eslint/parser": "^6.0.0",
    "eslint": "^8.0.0",
    "eslint-config-google": "^0.14.0",
    "eslint-plugin-import": "^2.25.4",
    "firebase-functions-test": "^3.1.0",
    "rimraf": "^5.0.0",
    "typescript": "^4.9.5"
  },
  "private": true
}

================
File: src/config/firebase.ts
================
import * as admin from "firebase-admin";

const app = !admin.apps.length ? admin.initializeApp() : admin.app();
const db = admin.firestore(app);
const storage = admin.storage(app);

export {db, storage}; // Export storage as well

export const COLLECTION = {
  CARDS: "cards",
  PRICES: "prices",
  SYNC_METADATA: "syncMetadata",
  LOGS: "logs",
  CARD_HASHES: "cardHashes",
  PRICE_HASHES: "priceHashes",
};

export const STORAGE = {
  BUCKETS: {
    CARD_IMAGES: "card-images",
  },
  PATHS: {
    IMAGES: "images",
  },
};

export const BASE_URL = "https://tcgcsv.com";
export const FFTCG_CATEGORY_ID = "24";

export const runtimeOpts = {
  timeoutSeconds: 540,
  memory: "1GB",
} as const;

================
File: src/global.d.ts
================
/// <reference types="node" />
/// <reference types="express" />

================
File: src/index.ts
================
import * as functions from "firebase-functions";
import {Request, Response} from "express";
import {syncCards} from "./services/cardSync";
import {syncPrices} from "./services/priceSync";
import {runtimeOpts} from "./config/firebase";
import {SyncOptions} from "./types";

// Scheduled card sync
exports.scheduledCardSync = functions
  .runWith(runtimeOpts)
  .pubsub.schedule("0 21 * * *")
  .timeZone("UTC")
  .onRun(async (_context) => {
    await syncCards();
    return null;
  });

// Manual card sync endpoint
exports.testCardSync = functions
  .runWith(runtimeOpts)
  .https.onRequest(async (req: Request, res: Response) => {
    const options: SyncOptions = {
      dryRun: req.query.dryRun === "true",
      limit: req.query.limit ? parseInt(req.query.limit as string) : undefined,
      groupId: req.query.groupId as string,
    };

    const result = await syncCards(options);
    res.json(result);
  });

// Scheduled price sync
exports.scheduledPriceSync = functions
  .runWith(runtimeOpts)
  .pubsub.schedule("30 21 * * *")
  .timeZone("UTC")
  .onRun(async (_context) => {
    await syncPrices();
    return null;
  });

// Manual price sync endpoint
exports.testPriceSync = functions
  .runWith(runtimeOpts)
  .https.onRequest(async (req: Request, res: Response) => {
    const options: SyncOptions = {
      dryRun: req.query.dryRun === "true",
      limit: req.query.limit ? parseInt(req.query.limit as string) : undefined,
      groupId: req.query.groupId as string,
      productId: req.query.productId ? parseInt(req.query.productId as string) : undefined,
      showAll: req.query.showAll === "true",
    };

    const result = await syncPrices(options);
    res.json(result);
  });

================
File: src/services/cardSync.ts
================
import axios, {AxiosError} from "axios";
import {db, COLLECTION, FFTCG_CATEGORY_ID} from "../config/firebase";
import {CardProduct, SyncOptions, SyncMetadata} from "../types";
import {cardCache, getCacheKey} from "../utils/cache";
import {logError, logInfo, logWarning} from "../utils/logger";
import * as crypto from "crypto";

const BASE_URL = "https://tcgcsv.com";
const MAX_RETRIES = 3;

async function makeRequest<T>(endpoint: string, retryCount = 0): Promise<T> {
  try {
    await new Promise((resolve) => setTimeout(resolve, 1000)); // Rate limiting
    const url = `${BASE_URL}/${endpoint}`;
    await logInfo(`Making request to: ${url} (Attempt ${retryCount + 1}/${MAX_RETRIES})`);

    const response = await axios.get<T>(url);
    return response.data;
  } catch (error) {
    if (retryCount < MAX_RETRIES - 1 && error instanceof AxiosError) {
      const delay = Math.pow(2, retryCount) * 1000;
      await logWarning(`Request failed, retrying in ${delay}ms...`);
      await new Promise((resolve) => setTimeout(resolve, delay));
      return makeRequest<T>(endpoint, retryCount + 1);
    }
    throw error;
  }
}

function getDataHash(data: any): string {
  return crypto.createHash("md5")
    .update(JSON.stringify(data, Object.keys(data).sort()))
    .digest("hex");
}

export async function syncCards(options: SyncOptions = {}): Promise<SyncMetadata> {
  const startTime = Date.now();
  const metadata: SyncMetadata = {
    lastSync: new Date(),
    status: "in_progress",
    cardCount: 0,
    type: options.dryRun ? "manual" : "scheduled",
    groupsProcessed: 0,
    groupsUpdated: 0,
    errors: [],
  };

  try {
    // Fetch groups
    const groupsResponse = await makeRequest<{ results: any[] }>(
      `${FFTCG_CATEGORY_ID}/groups`
    );
    const groups = groupsResponse.results;

    logInfo(`Found ${groups.length} groups`);

    let processedCards = 0;
    const existingHashes = new Map<string, string>();

    // Load existing hashes from Firestore
    const hashesSnapshot = await db.collection("cardHashes").get();
    hashesSnapshot.forEach((doc) => {
      existingHashes.set(doc.id, doc.data().hash);
    });

    for (const group of groups) {
      if (options.groupId && group.groupId !== options.groupId) continue;

      try {
        metadata.groupsProcessed++;
        const productsResponse = await makeRequest<{ results: CardProduct[] }>(
          `${FFTCG_CATEGORY_ID}/${group.groupId}/products`
        );
        const products = productsResponse.results;

        const groupHash = getDataHash(products);
        const existingHash = existingHashes.get(group.groupId.toString());

        if (!options.dryRun && (!existingHash || existingHash !== groupHash)) {
          metadata.groupsUpdated++;
          const batch = db.batch();

          for (const product of products) {
            if (options.limit && processedCards >= options.limit) break;

            const cardRef = db.collection(COLLECTION.CARDS)
              .doc(product.productId.toString());
            batch.set(cardRef, {
              ...product,
              lastUpdated: new Date(),
              groupHash,
            }, {merge: true});

            cardCache.set(getCacheKey("card", product.productId), product);
            processedCards++;
          }

          // Update hash
          const hashRef = db.collection("cardHashes")
            .doc(group.groupId.toString());
          batch.set(hashRef, {
            hash: groupHash,
            lastUpdated: new Date(),
          });

          await batch.commit();
          logInfo(`Updated ${products.length} cards from group ${group.groupId}`);
        } else {
          logInfo(`No updates needed for group ${group.groupId} (unchanged)`);
        }

        metadata.cardCount += products.length;
      } catch (error: any) { // Type assertion
        const errorMessage = `Error processing group ${group.groupId}: ${error?.message || "Unknown error"}`;
        metadata.errors.push(errorMessage);
        logError(error, "syncCards:processGroup");
      }

      if (options.limit && processedCards >= options.limit) break;
    }

    metadata.status = metadata.errors.length > 0 ? "completed_with_errors" : "success";
  } catch (error: any) { // Type assertion
    metadata.status = "failed";
    metadata.errors.push(error?.message || "Unknown error");
    logError(error, "syncCards:main");
  }

  metadata.lastSync = new Date();
  metadata.duration = Date.now() - startTime;

  if (!options.dryRun) {
    await db.collection(COLLECTION.SYNC_METADATA)
      .add(metadata);
  }

  return metadata;
}

================
File: src/services/priceSync.ts
================
import axios, {AxiosError} from "axios";
import {db, COLLECTION, FFTCG_CATEGORY_ID, BASE_URL} from "../config/firebase";
import {CardPrice, SyncOptions, SyncMetadata, PriceData} from "../types";
import {logError, logInfo, logWarning} from "../utils/logger";
import {ProgressTracker} from "../utils/progress";
import * as crypto from "crypto";

const MAX_RETRIES = 3;

async function makeRequest<T>(endpoint: string, retryCount = 0): Promise<T> {
  try {
    await new Promise((resolve) => setTimeout(resolve, 1000)); // Rate limiting
    const url = `${BASE_URL}/${endpoint}`;
    await logInfo(`Making request to: ${url} (Attempt ${retryCount + 1}/${MAX_RETRIES})`);

    const response = await axios.get<T>(url);
    return response.data;
  } catch (error) {
    if (retryCount < MAX_RETRIES - 1 && error instanceof AxiosError) {
      const delay = Math.pow(2, retryCount) * 1000;
      await logWarning(`Request failed, retrying in ${delay}ms...`);
      await new Promise((resolve) => setTimeout(resolve, delay));
      return makeRequest<T>(endpoint, retryCount + 1);
    }
    throw error;
  }
}

function getDataHash(data: any): string {
  return crypto.createHash("md5")
    .update(JSON.stringify(data, Object.keys(data).sort()))
    .digest("hex");
}

function processPrices(prices: CardPrice[]): Record<number, PriceData> {
  const priceMap: Record<number, PriceData> = {};

  prices.forEach((price) => {
    if (!priceMap[price.productId]) {
      priceMap[price.productId] = {
        lastUpdated: new Date(),
      };
    }

    if (price.subTypeName === "Normal") {
      priceMap[price.productId].normal = price;
    } else {
      priceMap[price.productId].foil = price;
    }
  });

  return priceMap;
}

export async function syncPrices(options: SyncOptions = {}): Promise<SyncMetadata> {
  const startTime = Date.now();
  const metadata: SyncMetadata = {
    lastSync: new Date(),
    status: "in_progress",
    cardCount: 0,
    type: options.dryRun ? "manual" : "scheduled",
    groupsProcessed: 0,
    groupsUpdated: 0,
    errors: [],
  };

  try {
    // If specific productId is provided, fetch just that group
    if (options.productId) {
      const card = await db.collection(COLLECTION.CARDS)
        .doc(options.productId.toString())
        .get();

      if (!card.exists) {
        throw new Error(`Card with ID ${options.productId} not found`);
      }

      const cardData = card.data();
      options.groupId = cardData?.groupId?.toString();
    }

    // Fetch groups or use specific group
    const groupsResponse = await makeRequest<{ results: any[] }>(
      `${FFTCG_CATEGORY_ID}/groups`
    );
    const groups = groupsResponse.results;

    if (options.groupId) {
      const group = groups.find((g) => g.groupId.toString() === options.groupId);
      if (!group) {
        throw new Error(`Group ${options.groupId} not found`);
      }
      groups.length = 0;
      groups.push(group);
    }

    const progress = new ProgressTracker(groups.length, "Processing groups");

    for (const group of groups) {
      try {
        metadata.groupsProcessed++;
        const pricesResponse = await makeRequest<{ results: CardPrice[] }>(
          `${FFTCG_CATEGORY_ID}/${group.groupId}/prices`
        );
        const prices = pricesResponse.results;

        if (options.productId) {
          const filteredPrices = prices.filter((p) => p.productId === options.productId);
          if (filteredPrices.length === 0) {
            throw new Error(`No prices found for product ${options.productId}`);
          }
          prices.length = 0;
          prices.push(...filteredPrices);
        }

        const priceHash = getDataHash(prices);
        const hashDoc = await db.collection(COLLECTION.PRICE_HASHES)
          .doc(group.groupId.toString())
          .get();

        const existingHash = hashDoc.exists ? hashDoc.data()?.hash : null;

        if (!options.dryRun && (!existingHash || existingHash !== priceHash)) {
          metadata.groupsUpdated++;
          const batch = db.batch();
          const processedPrices = processPrices(prices);

          for (const [productId, priceData] of Object.entries(processedPrices)) {
            if (options.limit && metadata.cardCount >= options.limit) break;

            const priceRef = db.collection(COLLECTION.PRICES)
              .doc(productId);
            batch.set(priceRef, priceData, {merge: true});

            metadata.cardCount++;
          }

          // Update hash
          const hashRef = db.collection(COLLECTION.PRICE_HASHES)
            .doc(group.groupId.toString());
          batch.set(hashRef, {
            hash: priceHash,
            lastUpdated: new Date(),
          });

          await batch.commit();
          await logInfo(`Updated ${metadata.cardCount} prices from group ${group.groupId}`);
        } else {
          await logInfo(`No updates needed for group ${group.groupId} (unchanged)`);
        }
      } catch (error: any) {
        const errorMessage = `Error processing group ${group.groupId}: ${error?.message || "Unknown error"}`;
        metadata.errors.push(errorMessage);
        await logError(error, "syncPrices:processGroup");
      }

      progress.update();

      if (options.limit && metadata.cardCount >= options.limit) break;
    }

    metadata.status = metadata.errors.length > 0 ? "completed_with_errors" : "success";
  } catch (error: any) {
    metadata.status = "failed";
    metadata.errors.push(error?.message || "Unknown error");
    await logError(error, "syncPrices:main");
  }

  metadata.lastSync = new Date();
  metadata.duration = Date.now() - startTime;

  if (!options.dryRun) {
    await db.collection(COLLECTION.SYNC_METADATA)
      .add(metadata);
  }

  return metadata;
}

================
File: src/types/express.d.ts
================
/// <reference types="express" />

================
File: src/types/index.ts
================
export interface GenericError extends Error {
    code?: string;
    message: string;
    stack?: string;
  }
  
  export interface CardProduct {
    productId: number;
    name: string;
    cleanName: string;
    imageUrl: string;
    categoryId: number;
    groupId: number;
    url: string;
    modifiedOn: string;
    imageCount: number;
    extendedData: Array<{
      name: string;
      displayName: string;
      value: string;
    }>;
  }
  
  export interface CardPrice {
    productId: number;
    lowPrice: number;
    midPrice: number;
    highPrice: number;
    marketPrice: number | null;
    directLowPrice: number | null;
    subTypeName: "Normal" | "Foil";
  }
  
  export interface SyncOptions {
    dryRun?: boolean;
    limit?: number;
    groupId?: string;
    productId?: number;
    showAll?: boolean;
  }
  
  export interface SyncMetadata {
    lastSync: Date;
    status: "in_progress" | "success" | "failed" | "completed_with_errors";
    cardCount: number;
    type: "manual" | "scheduled";
    groupsProcessed: number;
    groupsUpdated: number;
    errors: string[];
    duration?: number;
  }
  
  export type CacheType = "card" | "price";
  
  export interface PriceData {
    normal?: CardPrice;
    foil?: CardPrice;
    lastUpdated: Date;
  }
  
  export type LogData = any;
  export type GenericObject = Record<string, any>;

================
File: src/types/node.d.ts
================
/// <reference types="node" />

================
File: src/utils/cache.ts
================
import LRUCache from "lru-cache";
import {CacheType, CardProduct} from "../types";

const options = {
  max: 500,
  ttl: 1000 * 60 * 60, // 1 hour
};

export const cardCache = new LRUCache<string, CardProduct>(options);

export const getCacheKey = (type: CacheType, id: number): string => {
  return `${type}:${id}`;
};

================
File: src/utils/logger.ts
================
import * as functions from "firebase-functions";
import { db, COLLECTION } from "../config/firebase";
import { GenericError, LogData, GenericObject } from "../types";

export const logger = functions.logger;

interface LogEntry {
  timestamp: Date;
  level: "INFO" | "WARNING" | "ERROR";
  message: string;
  context?: string;
  data?: LogData;
}

async function saveLogEntry(entry: LogEntry): Promise<void> {
  await db.collection(COLLECTION.LOGS).add(entry);
}

export const logError = async (error: GenericError | GenericObject, context: string) => {
  const entry: LogEntry = {
    timestamp: new Date(),
    level: "ERROR",
    message: error.message || "Unknown error",
    context,
    data: {
      stack: error.stack,
      code: error.code,
    },
  };

  logger.error(entry.message, entry.data);
  await saveLogEntry(entry);
};

export const logInfo = async (message: string, data?: LogData) => {
  const entry: LogEntry = {
    timestamp: new Date(),
    level: "INFO",
    message,
    data,
  };

  logger.info(message, data);
  await saveLogEntry(entry);
};

export const logWarning = async (message: string, data?: LogData) => {
  const entry: LogEntry = {
    timestamp: new Date(),
    level: "WARNING",
    message,
    data,
  };

  logger.warn(message, data);
  await saveLogEntry(entry);
};

================
File: src/utils/progress.ts
================
import { logInfo } from "./logger";

/**
 * Tracks progress of long-running operations
 */
export class ProgressTracker {
  private startTime: number;
  private current: number;

  /**
   * Creates a new progress tracker
   * @param total Total number of items to process
   * @param description Description of the operation
   */
  constructor(
    private total: number,
    private description: string,
  ) {
    this.startTime = Date.now();
    this.current = 0;
  }

  /**
   * Updates progress and logs current status
   * @param amount Number of items processed in this update
   */
  update(amount = 1): void {
    this.current += amount;
    const elapsed = (Date.now() - this.startTime) / 1000;
    const percent = (this.current / this.total) * 100;
    const remaining = this.total - this.current;

    logInfo(
      `${this.description}: ${this.current}/${this.total} ` +
      `(${percent.toFixed(1)}%) - ${remaining} remaining - ` +
      `Elapsed time: ${elapsed.toFixed(1)}s`,
    );
  }

  /**
   * Gets current progress status
   */
  getProgress(): { current: number; total: number; elapsed: number } {
    return {
      current: this.current,
      total: this.total,
      elapsed: (Date.now() - this.startTime) / 1000,
    };
  }
}

================
File: tsconfig.dev.json
================
{
  "include": [
    ".eslintrc.js"
  ]
}

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "module": "commonjs",
    "noImplicitReturns": true,
    "noUnusedLocals": true,
    "outDir": "lib",
    "sourceMap": true,
    "strict": true,
    "target": "es2017",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "resolveJsonModule": true,
    "typeRoots": [
      "./node_modules/@types"
    ],
    "types": [
      "node",
      "express"
    ],
    "baseUrl": "./src",
    "paths": {
      "*": ["*", "types/*"]
    }
  },
  "compileOnSave": true,
  "include": [
    "src"
  ],
  "exclude": [
    "node_modules",
    "lib"
  ]
}
