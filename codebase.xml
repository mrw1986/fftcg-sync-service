This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-04T03:19:38.792Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

- Line numbers have been added to the beginning of each line.
</notes>

<additional_info>

For more information about Repomix, visit: https://github.com/yamadashy/repomix
</additional_info>

</file_summary>

<repository_structure>
.eslintrc.fix.js
.eslintrc.js
.firebaserc
.gitignore
docs/.markdownlint.json
docs/.vitepress/components/ApiExplorer.vue
docs/.vitepress/components/ArchitectureDiagram.vue
docs/.vitepress/components/FileTree.vue
docs/.vitepress/components/LogoutButton.vue
docs/.vitepress/components/ProjectStructure.vue
docs/.vitepress/components/ThemeToggle.vue
docs/.vitepress/config.mts
docs/.vitepress/shims-vue.d.ts
docs/.vitepress/theme/authGuard.ts
docs/.vitepress/theme/custom.css
docs/.vitepress/theme/index.ts
docs/.vitepress/utils/fileStructureParser.ts
docs/api/index.md
docs/architecture.md
docs/deployment/index.md
docs/env.d.ts
docs/faq.md
docs/file_structure.ps1
docs/index.md
docs/integrations/tcgplayer.md
docs/introduction.md
docs/monitoring/index.md
docs/package.json
docs/performance.md
docs/reference/types.md
docs/security.md
docs/services/card-sync.md
docs/services/price-sync.md
docs/setup/configuration.md
docs/setup/firebase-config.md
docs/setup/installation.md
docs/testing/endpoints.md
docs/testing/images.md
docs/testing/index.md
docs/testing/validation.md
docs/troubleshooting.md
docs/troubleshooting/common-issues.md
docs/usage-guide.md
docs/utils/batch.md
docs/utils/cache.md
docs/utils/error-handling.md
docs/utils/image-compressor.md
docs/utils/image-handler.md
docs/utils/image-validator.md
docs/utils/logging.md
docs/utils/progress.md
docs/utils/request.md
docs/utils/sync-logger.md
file_structure.ps1
firebase.json
firestore.indexes.json
firestore.rules
functions/.eslintignore
functions/.eslintrc.base.cjs
functions/.eslintrc.fix.js
functions/.eslintrc.js
functions/.firebaserc
functions/.gitignore
functions/.npmrc
functions/.prettierrc
functions/.repomixignore
functions/firebase.json
functions/package.json
functions/repomix.config.json
functions/src/config/environment.ts
functions/src/config/firebase.ts
functions/src/config/r2.ts
functions/src/index.ts
functions/src/scripts/cleanup.ts
functions/src/scripts/prodSync.ts
functions/src/scripts/setenv.ts
functions/src/scripts/syncAll.ts
functions/src/scripts/syncCards.ts
functions/src/scripts/syncPrices.ts
functions/src/scripts/testSync.ts
functions/src/services/cardSync.ts
functions/src/services/priceSync.ts
functions/src/services/storageService.ts
functions/src/types/index.ts
functions/src/utils/api.ts
functions/src/utils/logger.ts
functions/src/utils/retention.ts
functions/src/utils/timeout.ts
functions/tsconfig.dev.json
functions/tsconfig.json
package.json
public/index.html
repomix.config.json
storage.rules
tsconfig.json
</repository_structure>

<repository_files>
This section contains the contents of the repository's files.

<file path=".eslintrc.fix.js">
 1: module.exports = {
 2:   extends: "./functions/.eslintrc.js",
 3:   rules: {
 4:     "linebreak-style": ["error", "windows"],
 5:     "quotes": ["error", "double"],
 6:     "indent": ["error", 2],
 7:     "object-curly-spacing": ["error", "always"],
 8:     "max-len": ["error", { "code": 120 }],
 9:     "require-jsdoc": "off",
10:     "valid-jsdoc": "off",
11:     "@typescript-eslint/no-explicit-any": "warn",
12:     "comma-dangle": ["error", "always-multiline"]
13:   },
14: };
</file>

<file path=".eslintrc.js">
1: module.exports = {
2:     root: true,
3:     extends: './functions/.eslintrc.js',
4:   };
</file>

<file path=".firebaserc">
 1: {
 2:   "projects": {
 3:     "default": "fftcg-sync-service"
 4:   },
 5:   "targets": {
 6:     "fftcg-sync-service": {
 7:       "hosting": {
 8:         "main": [
 9:           "fftcg-sync-service"
10:         ],
11:         "docs": [
12:           "fftcg-sync-docs"
13:         ]
14:       }
15:     }
16:   },
17:   "etags": {}
18: }
</file>

<file path=".gitignore">
 1: # Firebase
 2: .firebase/
 3: firebase-debug.log
 4: firebase-debug.*.log
 5: ui-debug.log
 6: .runtimeconfig.json
 7: .env
 8: .env.*
 9: !.env.example
10: FirebaseAuth.vue
11: service_account_key.json
12: 
13: # Build and Dependencies
14: functions/lib/
15: node_modules/
16: functions/node_modules/
17: dist/
18: *.tsbuildinfo
19: 
20: # IDE and Editors
21: .idea/
22: .vscode/
23: *.swp
24: *.swo
25: .DS_Store
26: Thumbs.db
27: *.code-workspace
28: 
29: # Logs and Debug
30: logs/
31: *.log
32: npm-debug.log*
33: yarn-debug.log*
34: yarn-error.log*
35: firebase-debug.log*
36: ui-debug.log*
37: 
38: # Cache and Temporary Files
39: .npm/
40: .eslintcache
41: .cache/
42: .temp/
43: *.tmp
44: .vitepress/cache/
45: .vitepress/dist/
46: 
47: # Documentation Build
48: docs/.vitepress/dist/
49: docs/.vitepress/cache/
50: docs/codebase.xml
51: sync_service_codebase.xml
52: file_structure.xml
53: 
54: # Testing and Coverage
55: coverage/
56: .nyc_output/
57: 
58: # Backup Files
59: backups/
60: functions-backup/
61: *.bak
62: 
63: # Environment Files
64: .env.local
65: .env.*.local
66: functions/.env
67: functions/.env.*
68: functions/.runtimeconfig.json
69: 
70: # Generated Files
71: repomix-output.txt
</file>

<file path="docs/.markdownlint.json">
 1: {
 2:   "MD033": {
 3:     "allowed_elements": [
 4:       "ApiExplorer",
 5:       "ArchitectureDiagram",
 6:       "FileTree",
 7:       "ProjectStructure",
 8:       "div",
 9:       "span",
10:       "template",
11:       "script",
12:       "style"
13:     ]
14:   }
15: }
</file>

<file path="docs/.vitepress/components/ApiExplorer.vue">
   1: <script setup lang="ts">
   2: import { ref, computed, watch, onMounted } from 'vue'
   3: import { getAuth } from 'firebase/auth'
   4: 
   5: interface ApiEndpoint {
   6:   name: string
   7:   method: 'GET' | 'POST' | 'PUT' | 'DELETE'
   8:   path: string
   9:   description: string
  10:   params?: Parameter[]
  11:   responses: ApiResponse[]
  12:   example?: {
  13:     request?: string
  14:     response?: string
  15:   }
  16:   authenticated: boolean
  17:   tags?: string[]
  18: }
  19: 
  20: interface Parameter {
  21:   name: string
  22:   type: string
  23:   required: boolean
  24:   description: string
  25:   default?: string
  26:   validation?: {
  27:     pattern?: string
  28:     min?: number
  29:     max?: number
  30:   }
  31: }
  32: 
  33: interface ApiResponse {
  34:   status: number
  35:   description: string
  36:   schema: string
  37: }
  38: 
  39: interface ResponseState {
  40:   loading: boolean
  41:   data: any
  42:   error: string | null
  43:   headers: Record<string, string>
  44:   status: number
  45:   timestamp: number
  46: }
  47: 
  48: interface RequestHeader {
  49:   key: string
  50:   value: string
  51:   enabled: boolean
  52: }
  53: 
  54: interface HistoryEntry {
  55:   id: string
  56:   endpoint: string
  57:   method: string
  58:   params: Record<string, any>
  59:   headers: RequestHeader[]
  60:   timestamp: number
  61:   status: number
  62:   success: boolean
  63: }
  64: 
  65: const endpoints: ApiEndpoint[] = [
  66:   {
  67:     name: 'Test Card Sync',
  68:     method: 'GET',
  69:     path: '/testCardSync',
  70:     description: 'Test card synchronization with optional parameters',
  71:     authenticated: true,
  72:     params: [
  73:       {
  74:         name: 'dryRun',
  75:         type: 'boolean',
  76:         required: false,
  77:         description: 'Run without making changes',
  78:         default: 'true'
  79:       },
  80:       {
  81:         name: 'limit',
  82:         type: 'number',
  83:         required: false,
  84:         description: 'Maximum number of cards to process',
  85:         default: '5'
  86:       },
  87:       {
  88:         name: 'groupId',
  89:         type: 'string',
  90:         required: false,
  91:         description: 'Process specific group only'
  92:       }
  93:     ],
  94:     responses: [
  95:       {
  96:         status: 200,
  97:         description: 'Sync operation details',
  98:         schema: `{
  99:   "lastSync": "string",
 100:   "status": "in_progress" | "success" | "failed" | "completed_with_errors",
 101:   "cardCount": "number",
 102:   "type": "manual" | "scheduled",
 103:   "groupsProcessed": "number",
 104:   "groupsUpdated": "number",
 105:   "errors": "string[]",
 106:   "duration": "number",
 107:   "imagesProcessed": "number",
 108:   "imagesUpdated": "number"
 109: }`
 110:       }
 111:     ]
 112:   },
 113:   {
 114:     name: 'Manual Card Sync',
 115:     method: 'GET',
 116:     path: '/manualCardSync',
 117:     description: 'Trigger a full card synchronization',
 118:     authenticated: true,
 119:     responses: [
 120:       {
 121:         status: 200,
 122:         description: 'Sync operation details',
 123:         schema: `{
 124:   "lastSync": "string",
 125:   "status": "string",
 126:   "cardCount": "number",
 127:   "type": "scheduled",
 128:   "groupsProcessed": "number",
 129:   "groupsUpdated": "number",
 130:   "errors": "string[]",
 131:   "duration": "number"
 132: }`
 133:       }
 134:     ]
 135:   },
 136:   {
 137:     name: 'Test Price Sync',
 138:     method: 'GET',
 139:     path: '/testPriceSync',
 140:     description: 'Test price synchronization with optional parameters',
 141:     authenticated: true,
 142:     params: [
 143:       {
 144:         name: 'dryRun',
 145:         type: 'boolean',
 146:         required: false,
 147:         description: 'Run without making changes',
 148:         default: 'true'
 149:       },
 150:       {
 151:         name: 'limit',
 152:         type: 'number',
 153:         required: false,
 154:         description: 'Maximum number of prices to process'
 155:       },
 156:       {
 157:         name: 'groupId',
 158:         type: 'string',
 159:         required: false,
 160:         description: 'Process specific group only'
 161:       },
 162:       {
 163:         name: 'productId',
 164:         type: 'number',
 165:         required: false,
 166:         description: 'Process specific product only'
 167:       },
 168:       {
 169:         name: 'showAll',
 170:         type: 'boolean',
 171:         required: false,
 172:         description: 'Show all prices, including unchanged',
 173:         default: 'false'
 174:       }
 175:     ],
 176:     responses: [
 177:       {
 178:         status: 200,
 179:         description: 'Price sync operation details',
 180:         schema: `{
 181:   "lastSync": "string",
 182:   "status": "string",
 183:   "cardCount": "number",
 184:   "type": "manual",
 185:   "groupsProcessed": "number",
 186:   "groupsUpdated": "number",
 187:   "errors": "string[]",
 188:   "duration": "number"
 189: }`
 190:       }
 191:     ]
 192:   },
 193:   {
 194:     name: 'Manual Price Sync',
 195:     method: 'GET',
 196:     path: '/manualPriceSync',
 197:     description: 'Trigger a full price synchronization',
 198:     authenticated: true,
 199:     responses: [
 200:       {
 201:         status: 200,
 202:         description: 'Price sync operation details',
 203:         schema: `{
 204:   "lastSync": "string",
 205:   "status": "string",
 206:   "cardCount": "number",
 207:   "type": "scheduled",
 208:   "groupsProcessed": "number",
 209:   "groupsUpdated": "number",
 210:   "errors": "string[]",
 211:   "duration": "number"
 212: }`
 213:       }
 214:     ]
 215:   },
 216:   {
 217:     name: 'Health Check',
 218:     method: 'GET',
 219:     path: '/healthCheck',
 220:     description: 'Check system health status',
 221:     authenticated: false,
 222:     responses: [
 223:       {
 224:         status: 200,
 225:         description: 'System health information',
 226:         schema: `{
 227:   "status": "healthy",
 228:   "timestamp": "string",
 229:   "version": "string"
 230: }`
 231:       }
 232:     ]
 233:   }
 234: ]
 235: 
 236: const BASE_URL = 'https://us-central1-fftcg-sync-service.cloudfunctions.net'
 237: const selectedEndpoint = ref<ApiEndpoint>(endpoints[0])
 238: const showResponse = ref(true)
 239: const showHeaders = ref(false)
 240: const showHistory = ref(false)
 241: const showResponseHeaders = ref(false)
 242: const customHeaders = ref<RequestHeader[]>([
 243:   { key: 'Accept', value: 'application/json', enabled: true }
 244: ])
 245: const history = ref<HistoryEntry[]>([])
 246: const selectedTags = ref<string[]>([])
 247: const showAuthenticated = ref(true)
 248: const searchQuery = ref('')
 249: 
 250: // Response state
 251: const responseState = ref<ResponseState>({
 252:   loading: false,
 253:   data: null,
 254:   error: null,
 255:   headers: {},
 256:   status: 0,
 257:   timestamp: 0
 258: })
 259: 
 260: const paramValues = ref<Record<string, any>>({})
 261: 
 262: // Computed properties
 263: const methodColor = computed(() => {
 264:   switch (selectedEndpoint.value.method) {
 265:     case 'GET': return 'var(--vp-c-green)'
 266:     case 'POST': return 'var(--vp-c-brand)'
 267:     case 'PUT': return 'var(--vp-c-yellow)'
 268:     case 'DELETE': return 'var(--vp-c-red)'
 269:     default: return 'var(--vp-c-text-1)'
 270:   }
 271: })
 272: 
 273: const filteredEndpoints = computed(() => {
 274:   return endpoints.filter(endpoint => {
 275:     const matchesSearch = endpoint.name.toLowerCase().includes(searchQuery.value.toLowerCase()) ||
 276:                          endpoint.path.toLowerCase().includes(searchQuery.value.toLowerCase())
 277:     const matchesTags = selectedTags.value.length === 0 || 
 278:                        endpoint.tags?.some(tag => selectedTags.value.includes(tag))
 279:     const matchesAuth = showAuthenticated.value || !endpoint.authenticated
 280:     
 281:     return matchesSearch && matchesTags && matchesAuth
 282:   })
 283: })
 284: 
 285: const formattedDate = computed(() => {
 286:   return (timestamp: number) => {
 287:     return new Date(timestamp).toLocaleString()
 288:   }
 289: })
 290: 
 291: // Lifecycle hooks
 292: onMounted(() => {
 293:   const savedHistory = localStorage.getItem('api-explorer-history')
 294:   if (savedHistory) {
 295:     history.value = JSON.parse(savedHistory)
 296:   }
 297:   
 298:   initParamValues(selectedEndpoint.value)
 299: })
 300: 
 301: // Methods
 302: function initParamValues(endpoint: ApiEndpoint) {
 303:   const values: Record<string, any> = {}
 304:   endpoint.params?.forEach(param => {
 305:     values[param.name] = param.default || ''
 306:   })
 307:   paramValues.value = values
 308: }
 309: 
 310: function addHeader() {
 311:   customHeaders.value.push({ key: '', value: '', enabled: true })
 312: }
 313: 
 314: function removeHeader(index: number) {
 315:   customHeaders.value.splice(index, 1)
 316: }
 317: 
 318: function getEnabledHeaders(): Record<string, string> {
 319:   return customHeaders.value
 320:     .filter(h => h.enabled && h.key.trim() !== '')
 321:     .reduce((acc, h) => ({ ...acc, [h.key]: h.value }), {})
 322: }
 323: 
 324: async function copyToClipboard(text: string) {
 325:   try {
 326:     await navigator.clipboard.writeText(text)
 327:   } catch (err) {
 328:     console.error('Failed to copy to clipboard:', err)
 329:   }
 330: }
 331: 
 332: function saveAsJson(data: any, filename: string) {
 333:   const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' })
 334:   const url = URL.createObjectURL(blob)
 335:   const link = document.createElement('a')
 336:   link.href = url
 337:   link.download = filename
 338:   document.body.appendChild(link)
 339:   link.click()
 340:   document.body.removeChild(link)
 341:   URL.revokeObjectURL(url)
 342: }
 343: 
 344: function addToHistory(entry: Omit<HistoryEntry, 'id'>) {
 345:   const newEntry: HistoryEntry = {
 346:     ...entry,
 347:     id: crypto.randomUUID()
 348:   }
 349:   history.value.unshift(newEntry)
 350:   if (history.value.length > 50) {
 351:     history.value.pop()
 352:   }
 353:   localStorage.setItem('api-explorer-history', JSON.stringify(history.value))
 354: }
 355: 
 356: async function replayRequest(historyEntry: HistoryEntry) {
 357:   paramValues.value = { ...historyEntry.params }
 358:   customHeaders.value = [...historyEntry.headers]
 359:   const endpoint = endpoints.find(e => e.path === historyEntry.endpoint)
 360:   if (endpoint) {
 361:     selectedEndpoint.value = endpoint
 362:     await tryEndpoint(endpoint)
 363:   }
 364: }
 365: 
 366: async function getAuthToken(): Promise<string | null> {
 367:   const auth = getAuth()
 368:   const user = auth.currentUser
 369:   if (user) {
 370:     try {
 371:       return await user.getIdToken(true) // Force token refresh
 372:     } catch (error) {
 373:       console.error('Error getting auth token:', error)
 374:       return null
 375:     }
 376:   }
 377:   return null
 378: }
 379: 
 380: async function tryEndpoint(endpoint: ApiEndpoint) {
 381:   responseState.value = {
 382:     loading: true,
 383:     data: null,
 384:     error: null,
 385:     headers: {},
 386:     status: 0,
 387:     timestamp: Date.now()
 388:   }
 389: 
 390:   try {
 391:     let headers: Record<string, string> = {
 392:       ...getEnabledHeaders(),
 393:       'Content-Type': 'application/json'
 394:     }
 395: 
 396:     if (endpoint.authenticated) {
 397:       const token = await getAuthToken()
 398:       if (!token) {
 399:         throw new Error('Authentication required for this endpoint')
 400:       }
 401:       headers['Authorization'] = `Bearer ${token}`
 402:     }
 403: 
 404:     const url = new URL(`${BASE_URL}${endpoint.path}`)
 405:     
 406:     if (endpoint.params) {
 407:       Object.entries(paramValues.value).forEach(([key, value]) => {
 408:         if (value !== '' && !endpoint.path.includes(`{${key}}`)) {
 409:           url.searchParams.append(key, value.toString())
 410:         }
 411:       })
 412:     }
 413: 
 414:     const response = await fetch(url.toString(), {
 415:       method: endpoint.method,
 416:       headers
 417:     })
 418: 
 419:     const responseHeaders: Record<string, string> = {}
 420:     response.headers.forEach((value, key) => {
 421:       responseHeaders[key] = value
 422:     })
 423: 
 424:     if (!response.ok) {
 425:       const errorText = await response.text()
 426:       let errorMessage
 427:       try {
 428:         const errorJson = JSON.parse(errorText)
 429:         errorMessage = errorJson.error || errorJson.message || 'Unknown error'
 430:       } catch {
 431:         errorMessage = errorText || `HTTP Error: ${response.status} ${response.statusText}`
 432:       }
 433:       throw new Error(errorMessage)
 434:     }
 435: 
 436:     const data = await response.json()
 437:     
 438:     responseState.value = {
 439:       loading: false,
 440:       data,
 441:       error: null,
 442:       headers: responseHeaders,
 443:       status: response.status,
 444:       timestamp: Date.now()
 445:     }
 446: 
 447:     addToHistory({
 448:       endpoint: endpoint.path,
 449:       method: endpoint.method,
 450:       params: { ...paramValues.value },
 451:       headers: [...customHeaders.value],
 452:       timestamp: Date.now(),
 453:       status: response.status,
 454:       success: true
 455:     })
 456: 
 457:   } catch (error) {
 458:     console.error('API Error:', error)
 459:     responseState.value = {
 460:       ...responseState.value,
 461:       loading: false,
 462:       error: error instanceof Error ? error.message : 'An unknown error occurred',
 463:       status: error instanceof Error && error.message.includes('Authentication') ? 401 : 500,
 464:       data: null
 465:     }
 466: 
 467:     addToHistory({
 468:       endpoint: endpoint.path,
 469:       method: endpoint.method,
 470:       params: { ...paramValues.value },
 471:       headers: [...customHeaders.value],
 472:       timestamp: Date.now(),
 473:       status: responseState.value.status,
 474:       success: false
 475:     })
 476:   }
 477: }
 478: 
 479: // Watch for endpoint changes
 480: watch(selectedEndpoint, (newEndpoint) => {
 481:   initParamValues(newEndpoint)
 482:   responseState.value = {
 483:     loading: false,
 484:     data: null,
 485:     error: null,
 486:     headers: {},
 487:     status: 0,
 488:     timestamp: 0
 489:   }
 490: })
 491: </script>
 492: 
 493: <template>
 494:   <div class="api-explorer">
 495:     <div class="sidebar">
 496:       <!-- Search and Filter Section -->
 497:       <div class="search-section">
 498:         <input
 499:           v-model="searchQuery"
 500:           type="text"
 501:           placeholder="Search endpoints..."
 502:           class="search-input"
 503:         />
 504:         <div class="filter-options">
 505:           <label class="auth-toggle">
 506:             <input
 507:               type="checkbox"
 508:               v-model="showAuthenticated"
 509:             >
 510:             Show authenticated
 511:           </label>
 512:         </div>
 513:       </div>
 514: 
 515:       <!-- Endpoint List -->
 516:       <div class="endpoint-list">
 517:         <div
 518:           v-for="endpoint in filteredEndpoints"
 519:           :key="endpoint.path"
 520:           class="endpoint-item"
 521:           :class="{ 
 522:             active: endpoint === selectedEndpoint,
 523:             authenticated: endpoint.authenticated
 524:           }"
 525:           @click="selectedEndpoint = endpoint"
 526:         >
 527:           <div class="endpoint-item-header">
 528:             <span class="name">{{ endpoint.name }}</span>
 529:           </div>
 530:           <div class="endpoint-path">{{ endpoint.path }}</div>
 531:         </div>
 532:       </div>
 533: 
 534:       <!-- History Section -->
 535:       <div class="history-section">
 536:         <div class="history-toggle" @click="showHistory = !showHistory">
 537:           <span>History</span>
 538:           <span class="toggle-icon">{{ showHistory ? '▼' : '▶' }}</span>
 539:         </div>
 540: 
 541:         <div v-if="showHistory" class="history-panel">
 542:           <div
 543:             v-for="entry in history"
 544:             :key="entry.id"
 545:             class="history-entry"
 546:             :class="{ 
 547:               'history-success': entry.success,
 548:               'history-error': !entry.success
 549:             }"
 550:             @click="replayRequest(entry)"
 551:           >
 552:             <div class="history-entry-header">
 553:               <span class="history-method">{{ entry.method }}</span>
 554:               <span 
 555:                 class="history-status"
 556:                 :class="{ 
 557:                   'status-success': entry.status < 400,
 558:                   'status-error': entry.status >= 400
 559:                 }"
 560:               >
 561:                 {{ entry.status }}
 562:               </span>
 563:             </div>
 564:             <div class="history-endpoint">{{ entry.endpoint }}</div>
 565:             <div class="history-timestamp">
 566:               {{ formattedDate(entry.timestamp) }}
 567:             </div>
 568:           </div>
 569:         </div>
 570:       </div>
 571:     </div>
 572: 
 573:     <div class="content">
 574:       <!-- Endpoint Details -->
 575:       <div class="endpoint-header">
 576:         <div class="endpoint-title">
 577:           <h3>{{ selectedEndpoint.name }}</h3>
 578:           <span 
 579:             v-if="selectedEndpoint.authenticated"
 580:             class="auth-badge"
 581:             title="Requires authentication"
 582:           >
 583:             🔒
 584:           </span>
 585:         </div>
 586:         <div class="endpoint-path">
 587:           <span class="method" :style="{ color: methodColor }">
 588:             {{ selectedEndpoint.method }}
 589:           </span>
 590:           <code>{{ selectedEndpoint.path }}</code>
 591:         </div>
 592:       </div>
 593: 
 594:       <div class="description">
 595:         {{ selectedEndpoint.description }}
 596:       </div>
 597: 
 598:       <!-- Headers Section -->
 599:       <div class="headers-section">
 600:         <div class="section-header" @click="showHeaders = !showHeaders">
 601:           <h4>Headers</h4>
 602:           <span class="toggle-icon">{{ showHeaders ? '▼' : '▶' }}</span>
 603:         </div>
 604:         <div v-if="showHeaders" class="headers-content">
 605:           <div
 606:             v-for="(header, index) in customHeaders"
 607:             :key="index"
 608:             class="header-input"
 609:           >
 610:             <input
 611:               v-model="header.key"
 612:               placeholder="Header name"
 613:               class="header-key"
 614:             />
 615:             <input
 616:               v-model="header.value"
 617:               placeholder="Header value"
 618:               class="header-value"
 619:             />
 620:             <label class="header-enabled">
 621:               <input type="checkbox" v-model="header.enabled" />
 622:               Enable
 623:             </label>
 624:             <button
 625:               class="remove-header"
 626:               @click="removeHeader(index)"
 627:             >
 628:               ✕
 629:             </button>
 630:           </div>
 631:           <button class="add-header" @click="addHeader">
 632:             Add Header
 633:           </button>
 634:         </div>
 635:       </div>
 636: 
 637:       <!-- Parameters Section -->
 638:       <template v-if="selectedEndpoint.params?.length">
 639:         <h4>Parameters</h4>
 640:         <div class="params-form">
 641:           <div
 642:             v-for="param in selectedEndpoint.params"
 643:             :key="param.name"
 644:             class="param-input"
 645:           >
 646:             <label :for="param.name">
 647:               {{ param.name }}
 648:               <span v-if="param.required" class="required">*</span>
 649:             </label>
 650:             <input
 651:               :id="param.name"
 652:               v-model="paramValues[param.name]"
 653:               :type="param.type === 'number' ? 'number' : 'text'"
 654:               :placeholder="param.description"
 655:               :required="param.required"
 656:             />
 657:           </div>
 658:           <button
 659:             class="try-button"
 660:             @click="tryEndpoint(selectedEndpoint)"
 661:             :disabled="responseState.loading"
 662:           >
 663:             {{ responseState.loading ? 'Loading...' : 'Try it' }}
 664:           </button>
 665:         </div>
 666:       </template>
 667: 
 668:       <!-- Response Section -->
 669:       <div 
 670:         v-if="responseState.data || responseState.error" 
 671:         class="live-response"
 672:         :class="{ 'response-error': responseState.error }"
 673:       >
 674:         <div class="response-header">
 675:           <h4>Response</h4>
 676:           <div class="response-actions">
 677:             <button
 678:               class="action-button"
 679:               @click="copyToClipboard(JSON.stringify(responseState.data, null, 2))"
 680:               v-if="responseState.data"
 681:             >
 682:               Copy
 683:             </button>
 684:             <button
 685:               class="action-button"
 686:               @click="saveAsJson(responseState.data, `response-${Date.now()}.json`)"
 687:               v-if="responseState.data"
 688:             >
 689:               Save
 690:             </button>
 691:           </div>
 692:         </div>
 693: 
 694:         <!-- Response Status and Headers -->
 695:         <div v-if="responseState.status" class="response-status">
 696:           Status: {{ responseState.status }}
 697:         </div>
 698:        
 699:         <div v-if="Object.keys(responseState.headers).length" class="response-headers">
 700:           <div class="section-header" @click="showResponseHeaders = !showResponseHeaders">
 701:             <span>Response Headers</span>
 702:             <span class="toggle-icon">{{ showResponseHeaders ? '▼' : '▶' }}</span>
 703:           </div>
 704:           <div v-if="showResponseHeaders" class="headers-list">
 705:             <div
 706:               v-for="(value, key) in responseState.headers"
 707:               :key="key"
 708:               class="header-item"
 709:             >
 710:               <span class="header-key">{{ key }}:</span>
 711:               <span class="header-value">{{ value }}</span>
 712:             </div>
 713:           </div>
 714:         </div>
 715: 
 716:         <div v-if="responseState.error" class="error-message">
 717:           {{ responseState.error }}
 718:         </div>
 719:         <pre v-else class="response-data">
 720:           <code>{{ JSON.stringify(responseState.data, null, 2) }}</code>
 721:         </pre>
 722:       </div>
 723: 
 724:       <!-- Response Schema Section -->
 725:       <h4>Response Schema</h4>
 726:       <div
 727:         v-for="response in selectedEndpoint.responses"
 728:         :key="response.status"
 729:         class="response-section"
 730:       >
 731:         <div class="response-header">
 732:           <span
 733:             class="status"
 734:             :class="response.status < 400 ? 'success' : 'error'"
 735:           >
 736:             {{ response.status }}
 737:           </span>
 738:           <span class="description">{{ response.description }}</span>
 739:         </div>
 740:         <pre class="schema"><code>{{ response.schema }}</code></pre>
 741:       </div>
 742:     </div>
 743:   </div>
 744: </template>
 745: 
 746: <style scoped>
 747: .api-explorer {
 748:   display: grid;
 749:   grid-template-columns: 300px 1fr;
 750:   gap: 20px;
 751:   background: var(--custom-api-bg);
 752:   border-radius: 8px;
 753:   overflow: hidden;
 754:   border: 1px solid var(--vp-c-divider);
 755:   height: 800px;
 756: }
 757: 
 758: .sidebar {
 759:   background: var(--vp-c-bg-soft);
 760:   padding: 1rem;
 761:   border-right: 1px solid var(--vp-c-divider);
 762:   overflow-y: auto;
 763:   display: flex;
 764:   flex-direction: column;
 765: }
 766: 
 767: .search-section {
 768:   margin-bottom: 1rem;
 769:   padding: 0.5rem;
 770: }
 771: 
 772: .search-input {
 773:   width: 100%;
 774:   padding: 0.5rem;
 775:   border: 1px solid var(--vp-c-divider);
 776:   border-radius: 4px;
 777:   background: var(--vp-c-bg);
 778:   color: var(--vp-c-text-1);
 779:   margin-bottom: 0.5rem;
 780: }
 781: 
 782: .filter-options {
 783:   display: flex;
 784:   flex-direction: column;
 785:   gap: 0.5rem;
 786: }
 787: 
 788: .auth-toggle {
 789:   display: flex;
 790:   align-items: center;
 791:   gap: 0.5rem;
 792:   font-size: 0.9rem;
 793: }
 794: 
 795: .endpoint-list {
 796:   flex: 1;
 797:   overflow-y: auto;
 798: }
 799: 
 800: .endpoint-item {
 801:   padding: 0.75rem;
 802:   border-radius: 6px;
 803:   margin-bottom: 0.5rem;
 804:   cursor: pointer;
 805:   transition: all 0.2s ease;
 806: }
 807: 
 808: .endpoint-item:hover {
 809:   background: var(--vp-c-bg-mute);
 810: }
 811: 
 812: .endpoint-item.active {
 813:   background: var(--vp-c-brand-dimm);
 814: }
 815: 
 816: .endpoint-item.authenticated::after {
 817:   content: "🔒";
 818:   float: right;
 819:   font-size: 0.8rem;
 820: }
 821: 
 822: .endpoint-item-header {
 823:   display: flex;
 824:   align-items: center;
 825:   gap: 0.5rem;
 826:   margin-bottom: 0.25rem;
 827: }
 828: 
 829: .endpoint-path {
 830:   font-size: 0.8rem;
 831:   color: var(--vp-c-text-2);
 832:   word-break: break-all;
 833: }
 834: 
 835: .history-toggle {
 836:   margin-top: auto;
 837:   padding: 0.75rem;
 838:   cursor: pointer;
 839:   display: flex;
 840:   justify-content: space-between;
 841:   align-items: center;
 842:   background: var(--vp-c-bg-mute);
 843:   border-radius: 6px;
 844:   margin-top: 1rem;
 845: }
 846: 
 847: .history-panel {
 848:   margin-top: 0.5rem;
 849:   border-top: 1px solid var(--vp-c-divider);
 850:   padding-top: 0.5rem;
 851: }
 852: 
 853: .history-entry {
 854:   padding: 0.5rem;
 855:   border-radius: 4px;
 856:   margin-bottom: 0.5rem;
 857:   cursor: pointer;
 858:   background: var(--vp-c-bg-mute);
 859:   border: 1px solid var(--vp-c-divider);
 860:   transition: all 0.2s ease;
 861: }
 862: 
 863: .history-entry:hover {
 864:   background: var(--vp-c-bg);
 865: }
 866: 
 867: .history-entry.history-success {
 868:   border-left: 3px solid var(--vp-c-green);
 869: }
 870: 
 871: .history-entry.history-error {
 872:   border-left: 3px solid var(--vp-c-red);
 873: }
 874: 
 875: .history-entry-header {
 876:   display: flex;
 877:   justify-content: space-between;
 878:   margin-bottom: 0.25rem;
 879: }
 880: 
 881: .history-method {
 882:   font-weight: 600;
 883: }
 884: 
 885: .history-status {
 886:   font-size: 0.9em;
 887: }
 888: 
 889: .status-success {
 890:   color: var(--vp-c-green);
 891: }
 892: 
 893: .status-error {
 894:   color: var(--vp-c-red);
 895: }
 896: 
 897: .history-endpoint {
 898:   font-size: 0.9em;
 899:   margin-bottom: 0.25rem;
 900: }
 901: 
 902: .history-timestamp {
 903:   font-size: 0.8em;
 904:   color: var(--vp-c-text-2);
 905: }
 906: 
 907: .content {
 908:   padding: 1rem;
 909:   overflow-y: auto;
 910: }
 911: 
 912: .endpoint-header {
 913:   margin-bottom: 1rem;
 914: }
 915: 
 916: .endpoint-title {
 917:   display: flex;
 918:   align-items: center;
 919:   gap: 0.5rem;
 920: }
 921: 
 922: .auth-badge {
 923:   font-size: 1rem;
 924:   cursor: help;
 925: }
 926: 
 927: .headers-section {
 928:   margin: 1rem 0;
 929:   background: var(--vp-c-bg-soft);
 930:   border-radius: 8px;
 931:   overflow: hidden;
 932: }
 933: 
 934: .section-header {
 935:   padding: 0.75rem;
 936:   cursor: pointer;
 937:   display: flex;
 938:   justify-content: space-between;
 939:   align-items: center;
 940:   background: var(--vp-c-bg-mute);
 941: }
 942: 
 943: .headers-content {
 944:   padding: 1rem;
 945: }
 946: 
 947: .header-input {
 948:   display: grid;
 949:   grid-template-columns: 1fr 1fr auto auto;
 950:   gap: 0.5rem;
 951:   margin-bottom: 0.5rem;
 952:   align-items: center;
 953: }
 954: 
 955: .header-key,
 956: .header-value {
 957:   padding: 0.5rem;
 958:   border: 1px solid var(--vp-c-divider);
 959:   border-radius: 4px;
 960:   font-size: 0.9em;
 961: }
 962: 
 963: .header-enabled {
 964:   display: flex;
 965:   align-items: center;
 966:   gap: 0.25rem;
 967: }
 968: 
 969: .remove-header {
 970:   padding: 0.25rem 0.5rem;
 971:   background: var(--vp-c-red);
 972:   color: white;
 973:   border: none;
 974:   border-radius: 4px;
 975:   cursor: pointer;
 976: }
 977: 
 978: .add-header {
 979:   margin-top: 0.5rem;
 980:   padding: 0.5rem;
 981:   background: var(--vp-c-brand);
 982:   color: white;
 983:   border: none;
 984:   border-radius: 4px;
 985:   cursor: pointer;
 986:   width: 100%;
 987: }
 988: 
 989: .params-form {
 990:   margin: 1rem 0;
 991: }
 992: 
 993: .param-input {
 994:   margin-bottom: 1rem;
 995: }
 996: 
 997: .param-input label {
 998:   display: block;
 999:   margin-bottom: 0.25rem;
1000: }
1001: 
1002: .param-input input {
1003:   width: 100%;
1004:   padding: 0.5rem;
1005:   border: 1px solid var(--vp-c-divider);
1006:   border-radius: 4px;
1007: }
1008: 
1009: .required {
1010:   color: var(--vp-c-red);
1011:   margin-left: 0.25rem;
1012: }
1013: 
1014: .try-button {
1015:   padding: 0.5rem 1rem;
1016:   background: var(--vp-c-brand);
1017:   color: white;
1018:   border: none;
1019:   border-radius: 4px;
1020:   cursor: pointer;
1021:   width: 100%;
1022: }
1023: 
1024: .try-button:disabled {
1025:   opacity: 0.5;
1026:   cursor: not-allowed;
1027: }
1028: 
1029: .live-response {
1030:   margin: 1rem 0;
1031:   padding: 1rem;
1032:   background: var(--vp-c-bg-soft);
1033:   border-radius: 8px;
1034:   border: 1px solid var(--vp-c-divider);
1035:   position: relative;
1036: }
1037: 
1038: .response-error {
1039:   border-color: var(--vp-c-red);
1040: }
1041: 
1042: .response-header {
1043:   display: flex;
1044:   justify-content: space-between;
1045:   align-items: center;
1046:   margin-bottom: 1rem;
1047: }
1048: 
1049: .response-actions {
1050:   display: flex;
1051:   gap: 0.5rem;
1052: }
1053: 
1054: .action-button {
1055:   padding: 0.25rem 0.75rem;
1056:   background: var(--vp-c-brand);
1057:   color: white;
1058:   border: none;
1059:   border-radius: 4px;
1060:   cursor: pointer;
1061:   font-size: 0.9em;
1062: }
1063: 
1064: .error-message {
1065:   color: var(--vp-c-red);
1066:   padding: 0.75rem;
1067:   border: 1px solid var(--vp-c-red);
1068:   border-radius: 4px;
1069:   margin: 1rem 0;
1070: }
1071: 
1072: .response-data {
1073:   background: var(--vp-c-bg-mute);
1074:   padding: 1rem;
1075:   border-radius: 4px;
1076:   overflow-x: auto;
1077:   margin: 1rem 0;
1078: }
1079: 
1080: /* Responsive Design */
1081: @media (max-width: 768px) {
1082:   .api-explorer {
1083:     grid-template-columns: 1fr;
1084:     height: auto;
1085:   }
1086: 
1087:   .sidebar {
1088:     max-height: 300px;
1089:     overflow-y: auto;
1090:   }
1091: 
1092:   .content {
1093:     padding: 1rem;
1094:   }
1095: 
1096:   .header-input {
1097:     grid-template-columns: 1fr;
1098:   }
1099: }
1100: </style>
</file>

<file path="docs/.vitepress/components/ArchitectureDiagram.vue">
  1: <script setup>
  2: import { ref, computed } from 'vue'
  3: 
  4: const props = withDefaults(defineProps(), {
  5:   zoom: 1,
  6:   showLabels: true,
  7:   darkMode: false
  8: })
  9: 
 10: const hoveredNode = ref(null)
 11: const selectedNode = ref(null)
 12: const zoomLevel = ref(1)
 13: const zoomCenter = ref({ x: 350, y: 200 })
 14: 
 15: const colorScheme = computed(() => ({
 16:   service: props.darkMode ? '#7582ff' : '#646cff',
 17:   database: props.darkMode ? '#3dd68c' : '#42b883',
 18:   function: props.darkMode ? '#ff9147' : '#fb923c',
 19:   external: props.darkMode ? '#8491a8' : '#94a3b8',
 20:   text: props.darkMode ? '#ffffff' : '#1a1a1a',
 21:   background: props.darkMode ? '#1a1a1a' : '#ffffff',
 22:   hover: 'rgba(255, 255, 255, 0.1)'
 23: }))
 24: 
 25: const nodes = [
 26:   {
 27:     id: 'tcgplayer',
 28:     type: 'external',
 29:     label: 'TCGPlayer API',
 30:     x: 100,
 31:     y: 100,
 32:     description: 'External TCGPlayer API service',
 33:     details: 'Fetches card data and prices from TCGPlayer marketplace'
 34:   },
 35:   {
 36:     id: 'cardSync',
 37:     type: 'function',
 38:     label: 'Card Sync',
 39:     x: 300,
 40:     y: 100,
 41:     description: 'Card synchronization service',
 42:     details: 'Processes and normalizes card data from TCGPlayer'
 43:   },
 44:   {
 45:     id: 'priceSync',
 46:     type: 'function',
 47:     label: 'Price Sync',
 48:     x: 300,
 49:     y: 200,
 50:     description: 'Price synchronization service',
 51:     details: 'Updates card prices and tracks price history'
 52:   },
 53:   {
 54:     id: 'firestore',
 55:     type: 'database',
 56:     label: 'Firestore',
 57:     x: 500,
 58:     y: 150,
 59:     description: 'Firebase Firestore database',
 60:     details: 'Stores card data, prices, and metadata'
 61:   },
 62:   {
 63:     id: 'imageProcessor',
 64:     type: 'function',
 65:     label: 'Image Processor',
 66:     x: 300,
 67:     y: 300,
 68:     description: 'Image processing service',
 69:     details: 'Optimizes and stores card images'
 70:   },
 71:   {
 72:     id: 'storage',
 73:     type: 'database',
 74:     label: 'Firebase Storage',
 75:     x: 500,
 76:     y: 300,
 77:     description: 'Firebase Storage service',
 78:     details: 'Stores optimized card images'
 79:   }
 80: ]
 81: 
 82: const connections = [
 83:   {
 84:     id: 'conn1',
 85:     from: 'tcgplayer',
 86:     to: 'cardSync',
 87:     type: 'sync',
 88:     label: 'Card Data'
 89:   },
 90:   {
 91:     id: 'conn2',
 92:     from: 'tcgplayer',
 93:     to: 'priceSync',
 94:     type: 'sync',
 95:     label: 'Price Data'
 96:   },
 97:   {
 98:     id: 'conn3',
 99:     from: 'cardSync',
100:     to: 'firestore',
101:     type: 'sync',
102:     label: 'Store Cards'
103:   },
104:   {
105:     id: 'conn4',
106:     from: 'priceSync',
107:     to: 'firestore',
108:     type: 'sync',
109:     label: 'Store Prices'
110:   },
111:   {
112:     id: 'conn5',
113:     from: 'imageProcessor',
114:     to: 'storage',
115:     type: 'sync',
116:     label: 'Store Images'
117:   }
118: ]
119: 
120: const relatedConnections = computed(() => {
121:   if (!selectedNode.value) return []
122:   return connections.filter(conn => 
123:     conn.from === selectedNode.value || conn.to === selectedNode.value
124:   ).map(conn => conn.id)
125: })
126: 
127: const relatedNodes = computed(() => {
128:   if (!selectedNode.value) return []
129:   return connections
130:     .filter(conn => conn.from === selectedNode.value || conn.to === selectedNode.value)
131:     .map(conn => [conn.from, conn.to])
132:     .flat()
133:     .filter(nodeId => nodeId !== selectedNode.value)
134: })
135: 
136: function handleNodeClick(node, event) {
137:   event.stopPropagation()
138:   if (selectedNode.value === node.id) {
139:     resetView()
140:   } else {
141:     selectedNode.value = node.id
142:     zoomToNode(node)
143:   }
144: }
145: 
146: function handleCanvasClick() {
147:   resetView()
148: }
149: 
150: function zoomToNode(node) {
151:   zoomLevel.value = 1.5
152:   zoomCenter.value = { x: node.x, y: node.y }
153: }
154: 
155: function resetView() {
156:   zoomLevel.value = 1
157:   zoomCenter.value = { x: 350, y: 200 }
158:   selectedNode.value = null
159: }
160: 
161: function handleNodeHover(nodeId) {
162:   hoveredNode.value = nodeId
163: }
164: 
165: function getNodePosition(nodeId) {
166:   const node = nodes.find(n => n.id === nodeId)
167:   return node ? { x: node.x, y: node.y } : { x: 0, y: 0 }
168: }
169: 
170: function getPath(start, end) {
171:   const dx = end.x - start.x
172:   const dy = end.y - start.y
173:   const midX = start.x + dx / 2
174:   
175:   return `M ${start.x} ${start.y} 
176:           C ${midX} ${start.y},
177:             ${midX} ${end.y},
178:             ${end.x} ${end.y}`
179: }
180: 
181: function getLabelPosition(fromId, toId) {
182:   const from = getNodePosition(fromId)
183:   const to = getNodePosition(toId)
184:   return {
185:     x: (from.x + to.x) / 2,
186:     y: (from.y + to.y) / 2 - 10
187:   }
188: }
189: 
190: function getNodeColor(type) {
191:   return colorScheme.value[type]
192: }
193: 
194: function getConnectionColor(type) {
195:   return type === 'async' ? colorScheme.value.function : colorScheme.value.service
196: }
197: 
198: const transformStyle = computed(() => {
199:   const x = 350 - (zoomCenter.value.x * zoomLevel.value)
200:   const y = 200 - (zoomCenter.value.y * zoomLevel.value)
201:   return `translate(${x}px, ${y}px) scale(${zoomLevel.value})`
202: })
203: </script>
204: 
205: <template>
206:   <div class="diagram-container">
207:     <button class="zoom-reset" @click="resetView" v-if="zoomLevel > 1">
208:       Reset View
209:     </button>
210:     
211:     <svg 
212:       viewBox="0 0 700 400" 
213:       preserveAspectRatio="xMidYMid meet"
214:       @click="handleCanvasClick"
215:     >
216:       <defs>
217:         <pattern id="grid" width="20" height="20" patternUnits="userSpaceOnUse">
218:           <path d="M 20 0 L 0 0 0 20" fill="none" :stroke="colorScheme.text" stroke-opacity="0.1" />
219:         </pattern>
220:       </defs>
221:       
222:       <rect width="100%" height="100%" fill="url(#grid)" />
223: 
224:       <g class="diagram" :style="transformStyle">
225:         <g class="connections">
226:           <template v-for="conn in connections" :key="conn.id">
227:             <path
228:               :d="getPath(getNodePosition(conn.from), getNodePosition(conn.to))"
229:               :class="[
230:                 'connection',
231:                 conn.type,
232:                 {
233:                   'connection-highlighted': relatedConnections.includes(conn.id),
234:                   'connection-dimmed': selectedNode && !relatedConnections.includes(conn.id)
235:                 }
236:               ]"
237:               :stroke="getConnectionColor(conn.type)"
238:             >
239:               <animate
240:                 attributeName="stroke-dashoffset"
241:                 from="100"
242:                 to="0"
243:                 dur="1.5s"
244:                 repeatCount="indefinite"
245:               />
246:             </path>
247:             <text
248:               v-if="showLabels"
249:               :x="getLabelPosition(conn.from, conn.to).x"
250:               :y="getLabelPosition(conn.from, conn.to).y"
251:               dy=".3em"
252:               class="connection-label-outline"
253:             >
254:               {{ conn.label }}
255:             </text>
256:             <text
257:               v-if="showLabels"
258:               :x="getLabelPosition(conn.from, conn.to).x"
259:               :y="getLabelPosition(conn.from, conn.to).y"
260:               dy=".3em"
261:               class="connection-label"
262:             >
263:               {{ conn.label }}
264:             </text>
265:           </template>
266:         </g>
267: 
268:         <g class="nodes">
269:           <template v-for="node in nodes" :key="node.id">
270:             <g
271:               :class="[
272:                 'node',
273:                 node.type,
274:                 {
275:                   'node-hovered': hoveredNode === node.id,
276:                   'node-selected': selectedNode === node.id,
277:                   'node-related': relatedNodes.includes(node.id),
278:                   'node-dimmed': selectedNode && !relatedNodes.includes(node.id) && selectedNode !== node.id
279:                 }
280:               ]"
281:               @mouseenter="handleNodeHover(node.id)"
282:               @mouseleave="handleNodeHover(null)"
283:               @click="$event => handleNodeClick(node, $event)"
284:             >
285:               <rect
286:                 v-if="node.type !== 'database'"
287:                 :x="node.x - 50"
288:                 :y="node.y - 25"
289:                 width="100"
290:                 height="50"
291:                 :rx="node.type === 'function' ? 5 : 0"
292:                 :fill="getNodeColor(node.type)"
293:               />
294:               <ellipse
295:                 v-else
296:                 :cx="node.x"
297:                 :cy="node.y"
298:                 rx="50"
299:                 ry="25"
300:                 :fill="getNodeColor(node.type)"
301:               />
302:               <text
303:                 :x="node.x"
304:                 :y="node.y"
305:                 dy=".3em"
306:                 class="node-label-outline"
307:               >
308:                 {{ node.label }}
309:               </text>
310:               <text
311:                 :x="node.x"
312:                 :y="node.y"
313:                 dy=".3em"
314:                 class="node-label"
315:               >
316:                 {{ node.label }}
317:               </text>
318:             </g>
319:           </template>
320:         </g>
321:       </g>
322:     </svg>
323: 
324:     <div v-if="selectedNode" class="details-panel">
325:       <h3>{{ nodes.find(n => n.id === selectedNode)?.label }}</h3>
326:       <p>{{ nodes.find(n => n.id === selectedNode)?.details }}</p>
327:     </div>
328:   </div>
329: </template>
330: 
331: <style scoped>
332: .diagram-container {
333:   position: relative;
334:   width: 100%;
335:   height: 100%;
336:   overflow: hidden;
337: }
338: 
339: .diagram {
340:   transform-origin: center;
341:   transition: transform 0.5s ease;
342: }
343: 
344: .zoom-reset {
345:   position: absolute;
346:   top: 1rem;
347:   left: 1rem;
348:   padding: 0.5rem 1rem;
349:   background: var(--vp-c-brand);
350:   color: white;
351:   border: none;
352:   border-radius: 4px;
353:   cursor: pointer;
354:   z-index: 100;
355:   transition: background-color 0.2s;
356: }
357: 
358: .zoom-reset:hover {
359:   background: var(--vp-c-brand-dark);
360: }
361: 
362: .node {
363:   cursor: pointer;
364:   transform-origin: center;
365:   transition: all 0.2s ease;
366: }
367: 
368: .node-hovered {
369:   transform: scale(1.1);
370: }
371: 
372: .node-selected {
373:   stroke: var(--vp-c-brand);
374:   stroke-width: 3px;
375: }
376: 
377: .node-related {
378:   stroke: var(--vp-c-brand);
379:   stroke-width: 2px;
380: }
381: 
382: .node-dimmed {
383:   opacity: 0.4;
384: }
385: 
386: .node .node-label-outline {
387:   font-size: 12px;
388:   text-anchor: middle;
389:   pointer-events: none;
390:   font-weight: 600;
391:   fill: transparent;
392:   stroke: black;
393:   stroke-width: 2;
394:   stroke-linejoin: round;
395:   stroke-linecap: round;
396: }
397: 
398: .diagram .nodes .node text.node-label {
399:   font-size: 12px;
400:   text-anchor: middle;
401:   pointer-events: none;
402:   font-weight: 600;
403:   fill: white !important;
404:   stroke: none !important;
405: }
406: 
407: .node .node-label,
408: .node:hover .node-label,
409: .node:active .node-label,
410: .node.node-selected .node-label,
411: .node.node-related .node-label,
412: .node.node-dimmed .node-label {
413:   fill: white !important;
414: }
415: 
416: .connection {
417:   fill: none;
418:   stroke-width: 2;
419:   transition: all 0.3s ease;
420:   opacity: 0.8;
421: }
422: 
423: .connection.async {
424:   stroke-dasharray: 5, 5;
425: }
426: 
427: .connection-highlighted {
428:   stroke-width: 3;
429:   opacity: 1;
430: }
431: 
432: .connection-dimmed {
433:   opacity: 0.2;
434: }
435: 
436: .connection-label-outline {
437:   font-size: 12px;
438:   text-anchor: middle;
439:   pointer-events: none;
440:   transition: all 0.3s ease;
441:   font-weight: 500;
442:   fill: transparent;
443:   stroke: black;
444:   stroke-width: 2;
445:   stroke-linejoin: round;
446:   stroke-linecap: round;
447: }
448: 
449: .connection-label {
450:   font-size: 12px;
451:   text-anchor: middle;
452:   pointer-events: none;
453:   transition: all 0.3s ease;
454:   font-weight: 500;
455:   fill: white !important;
456: }
457: 
458: .label-highlighted {
459:   font-weight: 600;
460: }
461: 
462: .label-dimmed {
463:   opacity: 0.2;
464: }
465: 
466: .details-panel {
467:   position: absolute;
468:   top: 1rem;
469:   right: 1rem;
470:   background: var(--vp-c-bg-soft);
471:   padding: 1rem;
472:   border-radius: 8px;
473:   border: 1px solid var(--vp-c-divider);
474:   width: 250px;
475:   box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
476:   animation: slideIn 0.2s ease;
477: }
478: 
479: .details-panel h3 {
480:   margin: 0 0 0.5rem 0;
481:   color: var(--vp-c-text-1);
482: }
483: 
484: .details-panel p {
485:   margin: 0;
486:   color: var(--vp-c-text-2);
487:   font-size: 0.9rem;
488: }
489: 
490: @keyframes slideIn {
491:   from {
492:     transform: translateX(20px);
493:     opacity: 0;
494:   }
495:   to {
496:     transform: translateX(0);
497:     opacity: 1;
498:   }
499: }
500: 
501: @media (max-width: 768px) {
502:   .details-panel {
503:     position: fixed;
504:     top: auto;
505:     bottom: 1rem;
506:     right: 1rem;
507:     left: 1rem;
508:     width: auto;
509:   }
510: }
511: </style>
</file>

<file path="docs/.vitepress/components/FileTree.vue">
  1: // .vitepress/components/FileTree.vue
  2: 
  3: <script setup lang="ts">
  4: import { ref, onMounted, watchEffect, h } from 'vue'
  5: 
  6: interface TreeNode {
  7:   name: string
  8:   path: string
  9:   type: 'file' | 'directory'
 10:   children?: TreeNode[]
 11: }
 12: 
 13: interface FileStructure {
 14:   directories: {
 15:     [key: string]: {
 16:       directories: string[]
 17:       files: string[]
 18:     }
 19:   }
 20:   root_files: string[]
 21: }
 22: 
 23: const props = defineProps<{
 24:   root?: string
 25:   initialExpanded?: boolean
 26:   fileStructure?: FileStructure | null
 27: }>()
 28: 
 29: const expandedNodes = ref<Set<string>>(new Set())
 30: const treeData = ref<TreeNode[]>([])
 31: const isLoading = ref(true)
 32: const loadError = ref<string | null>(null)
 33: 
 34: watchEffect(() => {
 35:   if (props.fileStructure) {
 36:     try {
 37:       isLoading.value = true
 38:       treeData.value = buildTreeFromStructure(props.fileStructure)
 39:       
 40:       if (props.initialExpanded) {
 41:         const expandAll = (nodes: TreeNode[]) => {
 42:           nodes.forEach(node => {
 43:             if (node.type === 'directory') {
 44:               expandedNodes.value.add(node.path)
 45:               if (node.children) {
 46:                 expandAll(node.children)
 47:               }
 48:             }
 49:           })
 50:         }
 51:         expandAll(treeData.value)
 52:       }
 53:       
 54:       loadError.value = null
 55:     } catch (error) {
 56:       loadError.value = error instanceof Error ? error.message : 'Failed to process file structure'
 57:     } finally {
 58:       isLoading.value = false
 59:     }
 60:   }
 61: })
 62: 
 63: function buildTreeFromStructure(fileStructure: FileStructure): TreeNode[] {
 64:   const tree: TreeNode[] = []
 65:   
 66:   function createDirectoryStructure(dirPath: string): TreeNode {
 67:     const dirName = dirPath.split('/').pop() || dirPath
 68:     const directory = fileStructure.directories[dirPath]
 69:     if (!directory) {
 70:       throw new Error(`Directory not found: ${dirPath}`)
 71:     }
 72:     const children: TreeNode[] = []
 73: 
 74:     if (directory.directories) {
 75:       directory.directories.forEach(subDir => {
 76:         children.push(createDirectoryStructure(subDir))
 77:       })
 78:     }
 79: 
 80:     if (directory.files) {
 81:       directory.files.forEach(file => {
 82:         children.push({
 83:           name: file.split('/').pop() || file,
 84:           path: `${dirPath}/${file}`,
 85:           type: 'file'
 86:         })
 87:       })
 88:     }
 89: 
 90:     return {
 91:       name: dirName,
 92:       path: dirPath,
 93:       type: 'directory',
 94:       children: children.sort((a, b) => {
 95:         if (a.type === b.type) return a.name.localeCompare(b.name)
 96:         return a.type === 'directory' ? -1 : 1
 97:       })
 98:     }
 99:   }
100: 
101:   Object.keys(fileStructure.directories).forEach(dirPath => {
102:     if (!dirPath.includes('/')) {
103:       tree.push(createDirectoryStructure(dirPath))
104:     }
105:   })
106: 
107:   if (fileStructure.root_files?.length) {
108:     tree.push({
109:       name: 'Root Files',
110:       path: 'root',
111:       type: 'directory',
112:       children: fileStructure.root_files.map(file => ({
113:         name: file,
114:         path: file,
115:         type: 'file'
116:       })).sort((a, b) => a.name.localeCompare(b.name))
117:     })
118:   }
119: 
120:   return tree.sort((a, b) => a.name.localeCompare(b.name))
121: }
122: 
123: function toggleNode(path: string) {
124:   if (expandedNodes.value.has(path)) {
125:     expandedNodes.value.delete(path)
126:   } else {
127:     expandedNodes.value.add(path)
128:   }
129: }
130: 
131: function getFileIcon(name: string): string {
132:   const extension = name.split('.').pop()?.toLowerCase()
133:   switch (extension) {
134:     case 'ts':
135:     case 'tsx':
136:       return '📘'
137:     case 'js':
138:     case 'jsx':
139:       return '📒'
140:     case 'json':
141:       return '📋'
142:     case 'md':
143:       return '📝'
144:     case 'env':
145:       return '🔑'
146:     case 'rules':
147:       return '📜'
148:     default:
149:       return '📄'
150:   }
151: }
152: 
153: const renderTreeNode = (node: TreeNode, level: number = 0) => {
154:   return h('div',
155:     {
156:       class: 'tree-node',
157:       style: { paddingLeft: `${level * 20}px` }
158:     },
159:     [
160:       h('div',
161:         {
162:           class: ['node-content', node.type],
163:           onClick: () => node.type === 'directory' && toggleNode(node.path)
164:         },
165:         [
166:           node.type === 'directory'
167:             ? h('span',
168:                 {
169:                   class: ['expand-icon', { expanded: expandedNodes.value.has(node.path) }]
170:                 },
171:                 expandedNodes.value.has(node.path) ? '📂' : '📁'
172:               )
173:             : h('span',
174:                 { class: 'file-icon' },
175:                 getFileIcon(node.name)
176:               ),
177:           h('span', { class: 'node-name' }, node.name)
178:         ]
179:       ),
180:       node.type === 'directory' && expandedNodes.value.has(node.path) && node.children
181:         ? h('div',
182:             { class: 'children' },
183:             node.children.map(child => renderTreeNode(child, level + 1))
184:           )
185:         : null
186:     ]
187:   )
188: }
189: </script>
190: 
191: <template>
192:   <div class="file-tree" role="tree" aria-label="File structure">
193:     <div v-if="isLoading" class="loading-state">
194:       <div class="loading-spinner"></div>
195:       <span>Loading file structure...</span>
196:     </div>
197: 
198:     <div v-else-if="loadError" class="error-state">
199:       <span class="error-icon">⚠️</span>
200:       <span>{{ loadError }}</span>
201:     </div>
202: 
203:     <template v-else>
204:       <div class="tree-content">
205:         <template v-for="node in treeData" :key="node.path">
206:           <component :is="renderTreeNode(node)" />
207:         </template>
208:       </div>
209:     </template>
210:   </div>
211: </template>
212: 
213: <style scoped>
214: .file-tree {
215:   background: var(--vp-c-bg-soft);
216:   border: 1px solid var(--vp-c-divider);
217:   border-radius: 8px;
218:   padding: 1rem;
219:   font-family: var(--vp-font-family-mono);
220:   max-height: 800px;
221:   overflow-y: auto;
222: }
223: 
224: .tree-content {
225:   font-size: 0.9rem;
226: }
227: 
228: .tree-node {
229:   margin: 0.25rem 0;
230: }
231: 
232: .node-content {
233:   display: flex;
234:   align-items: center;
235:   padding: 0.25rem;
236:   cursor: pointer;
237:   border-radius: 4px;
238:   transition: background-color 0.2s ease;
239:   user-select: none;
240: }
241: 
242: .node-content:hover {
243:   background: var(--vp-c-bg-mute);
244: }
245: 
246: .node-content.directory {
247:   font-weight: 500;
248: }
249: 
250: .expand-icon, .file-icon {
251:   margin-right: 0.5rem;
252:   font-size: 1rem;
253:   width: 1.5rem;
254:   text-align: center;
255: }
256: 
257: .node-name {
258:   white-space: nowrap;
259:   overflow: hidden;
260:   text-overflow: ellipsis;
261: }
262: 
263: .children {
264:   margin-left: 0.5rem;
265: }
266: 
267: .loading-state {
268:   display: flex;
269:   align-items: center;
270:   justify-content: center;
271:   padding: 2rem;
272:   color: var(--vp-c-text-2);
273: }
274: 
275: .loading-spinner {
276:   width: 1.5rem;
277:   height: 1.5rem;
278:   border: 2px solid var(--vp-c-brand);
279:   border-radius: 50%;
280:   border-top-color: transparent;
281:   margin-right: 0.5rem;
282:   animation: spin 1s linear infinite;
283: }
284: 
285: .error-state {
286:   display: flex;
287:   align-items: center;
288:   justify-content: center;
289:   padding: 2rem;
290:   color: var(--vp-c-danger);
291:   gap: 0.5rem;
292: }
293: 
294: .error-icon {
295:   font-size: 1.2rem;
296: }
297: 
298: @keyframes spin {
299:   to { transform: rotate(360deg); }
300: }
301: 
302: /* Responsive adjustments */
303: @media (max-width: 768px) {
304:   .file-tree {
305:     padding: 0.5rem;
306:     font-size: 0.9rem;
307:   }
308: 
309:   .node-content {
310:     padding: 0.35rem;
311:   }
312: 
313:   .expand-icon, .file-icon {
314:     font-size: 0.9rem;
315:     width: 1.2rem;
316:   }
317: }
318: 
319: /* Print styles */
320: @media print {
321:   .file-tree {
322:     border: none;
323:     max-height: none;
324:   }
325: 
326:   .node-content {
327:     break-inside: avoid;
328:   }
329: }
330: </style>
</file>

<file path="docs/.vitepress/components/LogoutButton.vue">
 1: <script setup lang="ts">
 2: import { ref } from 'vue'
 3: import { signOut } from 'firebase/auth'
 4: import { auth } from '../theme/firebase'
 5: 
 6: const isLoading = ref(false)
 7: 
 8: const handleLogout = async () => {
 9:   isLoading.value = true
10:   
11:   try {
12:     await signOut(auth)
13:     // Clear any auth state
14:     localStorage.removeItem('firebase:authUser:' + auth.config.apiKey + ':' + auth.name)
15:     sessionStorage.clear()
16:     
17:     // Force a complete reload
18:     window.location.replace('/')
19:   } catch (error) {
20:     console.error('Logout failed:', error)
21:   } finally {
22:     isLoading.value = false
23:   }
24: }
25: </script>
26: 
27: <template>
28:   <button 
29:     class="nav-icon-button" 
30:     @click="handleLogout"
31:     :disabled="isLoading"
32:     title="Logout"
33:   >
34:     <svg
35:       xmlns="http://www.w3.org/2000/svg"
36:       viewBox="0 0 24 24"
37:       class="icon"
38:       fill="none"
39:       stroke="currentColor"
40:       stroke-width="2"
41:       stroke-linecap="round"
42:       stroke-linejoin="round"
43:     >
44:       <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4m7 14l5-5l-5-5m5 5H9" />
45:     </svg>
46:   </button>
47: </template>
48: 
49: <style scoped>
50: .nav-icon-button {
51:   display: flex;
52:   align-items: center;
53:   padding: 0 12px;
54:   background: transparent;
55:   border: none;
56:   color: var(--vp-c-text-2);
57:   transition: color 0.2s;
58:   cursor: pointer;
59:   height: var(--vp-nav-height);
60:   margin-left: 8px;
61: }
62: 
63: .nav-icon-button:hover {
64:   color: var(--vp-c-text-1);
65: }
66: 
67: .nav-icon-button:disabled {
68:   opacity: 0.5;
69:   cursor: not-allowed;
70: }
71: 
72: .icon {
73:   width: 20px;
74:   height: 20px;
75: }
76: </style>
</file>

<file path="docs/.vitepress/components/ProjectStructure.vue">
  1: // .vitepress/components/ProjectStructure.vue
  2: 
  3: <script setup lang="ts">
  4: import { ref, onMounted } from 'vue'
  5: import { type FileStructure } from '../utils/fileStructureParser'
  6: import FileTree from './FileTree.vue'
  7: 
  8: const fileStructure = ref<FileStructure | null>(null)
  9: const error = ref<string | null>(null)
 10: 
 11: // Create structure exactly matching the XML
 12: const simpleStructure: FileStructure = {
 13:   directories: {
 14:     'functions/src/config': {
 15:       directories: [],
 16:       files: ['firebase.ts']
 17:     },
 18:     'functions/src/services': {
 19:       directories: [],
 20:       files: ['cardSync.ts', 'priceSync.ts']
 21:     },
 22:     'functions/src/test': {
 23:       directories: [],
 24:       files: [
 25:         'testEndpoints.ts',
 26:         'testImageHandler.ts',
 27:         'testSync.ts',
 28:         'validateSync.ts'
 29:       ]
 30:     },
 31:     'functions/src/types': {
 32:       directories: [],
 33:       files: [
 34:         'express.d.ts',
 35:         'index.ts',
 36:         'node.d.ts'
 37:       ]
 38:     },
 39:     'functions/src/utils': {
 40:       directories: [],
 41:       files: [
 42:         'batch.ts',
 43:         'cache.ts',
 44:         'error.ts',
 45:         'imageCache.ts',
 46:         'imageCompressor.ts',
 47:         'imageHandler.ts',
 48:         'imageValidator.ts',
 49:         'logger.ts',
 50:         'progress.ts',
 51:         'request.ts',
 52:         'syncLogger.ts'
 53:       ]
 54:     },
 55:     'functions/src': {
 56:       directories: [
 57:         'functions/src/config',
 58:         'functions/src/services',
 59:         'functions/src/test',
 60:         'functions/src/types',
 61:         'functions/src/utils'
 62:       ],
 63:       files: [
 64:         'global.d.ts',
 65:         'index.ts'
 66:       ]
 67:     },
 68:     'functions': {
 69:       directories: ['functions/src'],
 70:       files: []
 71:     }
 72:   },
 73:   root_files: [
 74:     '.env',
 75:     '.env.local',
 76:     '.eslintrc.fix.js',
 77:     '.eslintrc.js',
 78:     '.firebaserc',
 79:     'firebase.json',
 80:     'firestore.indexes.json',
 81:     'firestore.rules',
 82:     'package-lock.json',
 83:     'package.json',
 84:     'storage.rules',
 85:     'tsconfig.json'
 86:   ]
 87: }
 88: 
 89: onMounted(() => {
 90:   try {
 91:     console.log('Initializing file structure...')
 92:     fileStructure.value = simpleStructure
 93:     console.log('File structure initialized:', fileStructure.value)
 94:   } catch (err) {
 95:     error.value = err instanceof Error ? err.message : 'Failed to initialize file structure'
 96:     console.error('Error initializing file structure:', err)
 97:   }
 98: })
 99: </script>
100: 
101: <template>
102:   <div class="project-structure">
103:     <div v-if="error" class="error-message">
104:       {{ error }}
105:     </div>
106:     <div v-else-if="!fileStructure" class="loading-message">
107:       Loading file structure...
108:     </div>
109:     <FileTree
110:       v-else
111:       :fileStructure="fileStructure"
112:       :initialExpanded="false"
113:     />
114:   </div>
115: </template>
116: 
117: <style scoped>
118: .project-structure {
119:   margin: 2rem 0;
120: }
121: 
122: .error-message {
123:   color: var(--vp-c-danger);
124:   padding: 1rem;
125:   border: 1px solid currentColor;
126:   border-radius: 8px;
127:   margin: 1rem 0;
128: }
129: 
130: .loading-message {
131:   color: var(--vp-c-text-2);
132:   padding: 1rem;
133:   text-align: center;
134:   font-style: italic;
135: }
136: </style>
</file>

<file path="docs/.vitepress/components/ThemeToggle.vue">
 1: <template>
 2:     <button class="theme-toggle" @click="toggleTheme" :title="nextTheme === 'dark' ? 'Switch to dark theme' : 'Switch to light theme'">
 3:       <span class="theme-icon">{{ nextTheme === 'dark' ? '🌙' : '☀️' }}</span>
 4:     </button>
 5:   </template>
 6:   
 7:   <script setup>
 8:   import { useData } from 'vitepress'
 9:   import { ref, onMounted } from 'vue'
10:   
11:   const { isDark } = useData()
12:   const nextTheme = ref('dark')
13:   
14:   onMounted(() => {
15:     updateThemeIcon()
16:   })
17:   
18:   function toggleTheme() {
19:     isDark.value = !isDark.value
20:     updateThemeIcon()
21:   }
22:   
23:   function updateThemeIcon() {
24:     nextTheme.value = isDark.value ? 'light' : 'dark'
25:   }
26:   </script>
27:   
28:   <style scoped>
29:   .theme-toggle {
30:     border: none;
31:     background: none;
32:     padding: 0;
33:     cursor: pointer;
34:     color: var(--vp-c-text-1);
35:   }
36:   
37:   .theme-icon {
38:     font-size: 1.2rem;
39:   }
40:   </style>
</file>

<file path="docs/.vitepress/config.mts">
  1: import { defineConfig } from 'vitepress'
  2: import { getAuth } from 'firebase/auth'
  3: import { app } from './theme/firebase'
  4: 
  5: // List of public paths that don't require authentication
  6: const PUBLIC_PATHS = ['/', '/index.html', '/index.md']
  7: 
  8: async function isAuthenticated(): Promise<boolean> {
  9:   // Skip auth check during build
 10:   if (process.env.NODE_ENV === 'production' && process.env.VITEPRESS_BUILD) {
 11:     return true;
 12:   }
 13: 
 14:   // Skip auth check on server side
 15:   if (typeof window === 'undefined') {
 16:     return true;
 17:   }
 18: 
 19:   try {
 20:     const auth = getAuth(app);
 21:     return new Promise((resolve) => {
 22:       const unsubscribe = auth.onAuthStateChanged((user) => {
 23:         unsubscribe();
 24:         resolve(!!user);
 25:       });
 26:     });
 27:   } catch (error) {
 28:     console.error('Auth check failed:', error);
 29:     return false;
 30:   }
 31: }
 32: 
 33: export default defineConfig({
 34:   title: 'FFTCG Sync Service',
 35:   description: 'Documentation for the FFTCG Card and Price Sync Service',
 36:   
 37:   async transformPageData(pageData) {
 38:     const path = '/' + (pageData.relativePath === 'index.md' ? '' : pageData.relativePath)
 39:     
 40:     // Allow access to public paths without authentication
 41:     if (PUBLIC_PATHS.includes(path)) {
 42:       return pageData
 43:     }
 44: 
 45:     // Skip auth check during build
 46:     if (process.env.NODE_ENV === 'production' && process.env.VITEPRESS_BUILD) {
 47:       return pageData;
 48:     }
 49: 
 50:     // Check authentication for protected paths
 51:     const authenticated = await isAuthenticated()
 52:     if (!authenticated) {
 53:       return {
 54:         ...pageData,
 55:         frontmatter: {
 56:           ...pageData.frontmatter,
 57:           redirect: '/'
 58:         }
 59:       }
 60:     }
 61: 
 62:     return pageData
 63:   },
 64: 
 65:   themeConfig: {
 66:     nav: [
 67:       { text: 'Home', link: '/' },
 68:       { text: 'Introduction', link: '/introduction' },
 69:       { text: 'Architecture', link: '/architecture' },
 70:       { text: 'API', link: '/api/' },
 71:       { text: 'Testing', link: '/testing/' }
 72:     ],
 73: 
 74:     sidebar: [
 75:       {
 76:         text: 'Getting Started',
 77:         items: [
 78:           { text: 'Introduction', link: '/introduction' },
 79:           { text: 'Architecture', link: '/architecture' },
 80:           { text: 'Performance', link: '/performance' },
 81:           { text: 'Security', link: '/security' }
 82:         ]
 83:       },
 84:       {
 85:         text: 'Setup',
 86:         items: [
 87:           { text: 'Installation', link: '/setup/installation' },
 88:           { text: 'Configuration', link: '/setup/configuration' },
 89:           { text: 'Firebase Config', link: '/setup/firebase-config' }
 90:         ]
 91:       },
 92:       {
 93:         text: 'API',
 94:         items: [
 95:           { text: 'Overview', link: '/api/' },
 96:           { text: 'Types Reference', link: '/reference/types' }
 97:         ]
 98:       },
 99:       {
100:         text: 'Services',
101:         items: [
102:           { text: 'Card Sync', link: '/services/card-sync' },
103:           { text: 'Price Sync', link: '/services/price-sync' }
104:         ]
105:       },
106:       {
107:         text: 'Utils',
108:         items: [
109:           { text: 'Batch Processing', link: '/utils/batch' },
110:           { text: 'Cache', link: '/utils/cache' },
111:           { text: 'Error Handling', link: '/utils/error-handling' },
112:           { text: 'Image Compressor', link: '/utils/image-compressor' },
113:           { text: 'Image Handler', link: '/utils/image-handler' },
114:           { text: 'Image Validator', link: '/utils/image-validator' },
115:           { text: 'Logging', link: '/utils/logging' },
116:           { text: 'Progress', link: '/utils/progress' },
117:           { text: 'Request', link: '/utils/request' },
118:           { text: 'Sync Logger', link: '/utils/sync-logger' }
119:         ]
120:       },
121:       {
122:         text: 'Testing',
123:         items: [
124:           { text: 'Overview', link: '/testing/' },
125:           { text: 'Endpoints', link: '/testing/endpoints' },
126:           { text: 'Images', link: '/testing/images' },
127:           { text: 'Validation', link: '/testing/validation' }
128:         ]
129:       },
130:       {
131:         text: 'Deployment',
132:         items: [
133:           { text: 'Deployment Guide', link: '/deployment/' }
134:         ]
135:       },
136:       {
137:         text: 'Monitoring',
138:         items: [
139:           { text: 'System Monitoring', link: '/monitoring/' }
140:         ]
141:       },
142:       {
143:         text: 'Troubleshooting',
144:         items: [
145:           { text: 'Overview', link: '/troubleshooting' },
146:           { text: 'Common Issues', link: '/troubleshooting/common-issues' }
147:         ]
148:       },
149:       {
150:         text: 'Integrations',
151:         items: [
152:           { text: 'TCGplayer', link: '/integrations/tcgplayer' }
153:         ]
154:       }
155:     ],
156: 
157:     search: {
158:       provider: 'local',
159:       options: {
160:         detailedView: true
161:       }
162:     },
163: 
164:     socialLinks: [
165:       { icon: 'github', link: 'https://github.com/mrw1986/fftcg-sync-service' }
166:     ],
167: 
168:     footer: {
169:       message: 'Released under the MIT License.',
170:       copyright: `Copyright © ${new Date().getFullYear()}`
171:     },
172: 
173:     outline: {
174:       level: [2, 3],
175:       label: 'On this page'
176:     },
177: 
178:     lastUpdated: {
179:       text: 'Last updated',
180:       formatOptions: {
181:         dateStyle: 'full',
182:         timeStyle: 'medium'
183:       }
184:     }
185:   },
186: 
187:   vite: {
188:     define: {
189:       __VUE_PROD_HYDRATION_MISMATCH_DETAILS__: 'false'
190:     },
191:     // Add CORS and other security headers
192:     server: {
193:       headers: {
194:         'Access-Control-Allow-Origin': '*',
195:         'X-Frame-Options': 'DENY',
196:         'X-Content-Type-Options': 'nosniff',
197:         'X-XSS-Protection': '1; mode=block'
198:       }
199:     }
200:   }
201: })
</file>

<file path="docs/.vitepress/shims-vue.d.ts">
1: declare module '*.vue' {
2:     import type { DefineComponent } from 'vue'
3:     const component: DefineComponent<{}, {}, any>
4:     export default component
5:   }
</file>

<file path="docs/.vitepress/theme/authGuard.ts">
 1: import { getAuth } from 'firebase/auth'
 2: import { app } from './firebase'
 3: 
 4: export const isAuthenticated = async (): Promise<boolean> => {
 5:   const auth = getAuth(app)
 6:   
 7:   return new Promise((resolve) => {
 8:     const unsubscribe = auth.onAuthStateChanged((user) => {
 9:       unsubscribe()
10:       resolve(!!user)
11:     })
12:   })
13: }
14: 
15: export const checkAuth = async (path: string): Promise<boolean> => {
16:   const publicPaths = ['/', '/login']
17:   if (publicPaths.includes(path)) {
18:     return true
19:   }
20:   
21:   return await isAuthenticated()
22: }
</file>

<file path="docs/.vitepress/theme/custom.css">
  1: :root {
  2:   /* Brand Colors */
  3:   --vp-c-brand: #646cff;
  4:   --vp-c-brand-light: #747bff;
  5:   --vp-c-brand-lighter: #9499ff;
  6:   --vp-c-brand-dark: #535bf2;
  7:   --vp-c-brand-darker: #454ce1;
  8: 
  9:   /* Layout */
 10:   --vp-sidebar-width: 280px;
 11:   --vp-nav-height: 64px;
 12:   --vp-layout-max-width: 1440px;
 13: 
 14:   /* Typography */
 15:   --vp-font-family-base: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI',
 16:     Roboto, Oxygen, Ubuntu, Cantarell, 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
 17:     sans-serif;
 18:   --vp-font-family-mono: 'Fira Code', Menlo, Monaco, Consolas, 'Courier New',
 19:     monospace;
 20: 
 21:   /* Code Blocks */
 22:   --vp-code-block-bg: #1e1e1e;
 23:   --vp-code-block-color: #e5e7eb;
 24:   --vp-code-line-highlight-color: rgba(255, 255, 255, 0.1);
 25:   --vp-code-line-number-color: #636363;
 26: 
 27:   /* Custom Component Colors */
 28:   --custom-tree-bg: var(--vp-c-bg-soft);
 29:   --custom-tree-highlight: var(--vp-c-brand-light);
 30:   --custom-diagram-bg: var(--vp-c-bg-soft);
 31:   --custom-api-bg: var(--vp-c-bg-soft);
 32: }
 33: 
 34: /* Dark Mode Overrides */
 35: .dark {
 36:   --custom-tree-bg: var(--vp-c-bg-soft);
 37:   --custom-tree-highlight: var(--vp-c-brand-dark);
 38: }
 39: 
 40: /* Layout Structure */
 41: .VPNav {
 42:   position: fixed !important;
 43:   top: 0;
 44:   left: 0;
 45:   right: 0;
 46:   z-index: 999 !important;
 47:   background-color: var(--vp-c-bg);
 48:   border-bottom: 1px solid var(--vp-c-divider);
 49:   height: var(--vp-nav-height);
 50: }
 51: 
 52: .VPNavBar {
 53:   position: fixed;
 54:   top: 0;
 55:   left: 0;
 56:   right: 0;
 57:   z-index: 999;
 58: }
 59: 
 60: .VPNavBar .container {
 61:   display: flex;
 62:   justify-content: space-between;
 63:   align-items: center;
 64: }
 65: 
 66: .VPNavBar.has-sidebar {
 67:   padding-top: 0 !important;
 68: }
 69: 
 70: .VPContent {
 71:   padding-top: var(--vp-nav-height) !important;
 72: }
 73: 
 74: /* Main Content Area */
 75: .VPDoc {
 76:   min-height: calc(100vh - var(--vp-nav-height));
 77:   padding-top: 24px;
 78: }
 79: 
 80: /* Left Sidebar */
 81: .VPSidebar {
 82:   top: var(--vp-nav-height) !important;
 83:   padding-top: 0 !important;
 84:   height: calc(100vh - var(--vp-nav-height)) !important;
 85: }
 86: 
 87: /* Right Sidebar (On this page) */
 88: .VPDocAside {
 89:   top: var(--vp-nav-height) !important;
 90:   height: calc(100vh - var(--vp-nav-height)) !important;
 91:   padding-top: 24px !important;
 92: }
 93: 
 94: .VPDocAsideOutline .content {
 95:   position: relative;
 96:   width: 200px;
 97:   padding-right: 8px;
 98: }
 99: 
100: /* Right Sidebar Link Wrapping */
101: .VPDocAsideOutline .outline-link {
102:   position: relative;
103:   white-space: normal;
104:   word-wrap: break-word;
105:   overflow-wrap: break-word;
106:   line-height: 1.4;
107:   display: flex;
108:   align-items: center;
109:   gap: 14px;
110:   margin: 4px 0;
111:   font-size: 13px;
112:   font-weight: 400;
113:   color: var(--vp-c-text-2);
114:   transition: color 0.25s;
115:   -webkit-line-clamp: unset;
116:   line-clamp: unset;
117:   -webkit-box-orient: unset;
118:   box-orient: unset;
119:   overflow: visible;
120: }
121: 
122: .VPDocAsideOutline .outline-marker {
123:   width: 2px;
124:   background-color: var(--vp-c-brand);
125:   opacity: 0;
126:   transition: opacity 0.25s;
127:   height: 1.4em;  /* Match the line-height */
128:   align-self: center;
129: }
130: 
131: .VPDocAsideOutline .outline-link:hover {
132:   color: var(--vp-c-text-1);
133: }
134: 
135: .VPDocAsideOutline .outline-link:hover .outline-marker {
136:   opacity: 0.5;
137: }
138: 
139: .VPDocAsideOutline .outline-link.active {
140:   color: var(--vp-c-brand);
141: }
142: 
143: .VPDocAsideOutline .outline-link.active .outline-marker {
144:   opacity: 1;
145: }
146: 
147: /* Sidebar Improvements */
148: .VPSidebarItem .text {
149:   white-space: normal !important;
150:   overflow-wrap: break-word;
151:   word-wrap: break-word;
152:   hyphens: auto;
153: }
154: 
155: .VPSidebarItem {
156:   max-width: 100%;
157:   overflow: hidden;
158: }
159: 
160: /* Navigation and Search */
161: .VPNavBarSearch {
162:   margin: 0 auto !important;
163:   width: 100%;
164:   max-width: 582px;
165:   padding: 0 32px;
166:   position: relative;
167: }
168: 
169: /* Center DocSearch-Button content */
170: .DocSearch-Button {
171:   margin-left: auto;
172:   margin-right: auto;
173: }
174: 
175: /* Navigation Controls */
176: .nav-controls {
177:   display: flex;
178:   align-items: center;
179:   gap: 12px;
180:   margin-left: auto;
181:   padding-right: 32px;
182: }
183: 
184: .nav-item {
185:   display: flex;
186:   align-items: center;
187: }
188: 
189: /* Navbar Layout */
190: .VPNavBarContent {
191:   display: flex;
192:   justify-content: space-between;
193:   align-items: center;
194: }
195: 
196: .VPNavBarContent .content {
197:   flex: 1;
198: }
199: 
200: .nav-bar-content-after {
201:   display: flex;
202:   align-items: center;
203:   margin-left: auto;
204: }
205: 
206: /* Auth-specific styles */
207: .auth-container {
208:   display: flex;
209:   align-items: center;
210:   gap: 12px;
211: }
212: 
213: .auth-button {
214:   padding: 6px 12px;
215:   border-radius: 4px;
216:   transition: all 0.2s ease;
217:   cursor: pointer;
218: }
219: 
220: .login-button {
221:   background: var(--vp-c-brand);
222:   color: white;
223:   border: none;
224: }
225: 
226: .logout-button {
227:   background: transparent;
228:   border: 1px solid var(--vp-c-divider);
229:   color: var(--vp-c-text-2);
230: }
231: 
232: .auth-button:hover {
233:   opacity: 0.9;
234:   transform: translateY(-1px);
235: }
236: 
237: /* Responsive Layout */
238: @media (min-width: 960px) {
239:   :root {
240:     --vp-sidebar-width: 320px;
241:   }
242: 
243:   .VPDocAsideOutline .content {
244:     width: 220px;
245:   }
246: }
247: 
248: @media (max-width: 959px) {
249:   :root {
250:     --vp-sidebar-width: 260px;
251:   }
252:   
253:   .VPSidebarItem .text {
254:     font-size: 0.9em;
255:   }
256: 
257:   .VPDocAsideOutline .content {
258:     width: 180px;
259:   }
260: }
261: 
262: @media (max-width: 768px) {
263:   .VPNavBar.container {
264:     padding: 0 16px;
265:   }
266: 
267:   .VPNavBarSearch {
268:     padding: 0 16px;
269:   }
270: 
271:   .nav-extra {
272:     right: 60px !important;
273:   }
274: 
275:   .user-email {
276:     max-width: 150px;
277:   }
278: 
279:   .nav-controls {
280:     padding-right: 16px;
281:   }
282: }
283: 
284: /* Custom Block Styles */
285: .custom-block {
286:   border-radius: 8px;
287:   padding: 16px 20px;
288:   margin: 16px 0;
289:   font-size: 14px;
290:   line-height: 1.6;
291: }
292: 
293: /* Code Blocks */
294: .vp-doc div[class*='language-'] {
295:   margin: 16px 0;
296:   position: relative;
297:   background-color: var(--vp-code-block-bg);
298:   overflow-x: auto;
299: }
300: 
301: /* Print Styles */
302: @media print {
303:   .VPNav,
304:   .VPSidebar,
305:   .VPDocAside {
306:     display: none;
307:   }
308: 
309:   .VPDoc {
310:     padding: 0;
311:     margin: 0;
312:   }
313: }
314: 
315: /* Transitions */
316: .fade-enter-active,
317: .fade-leave-active {
318:   transition: opacity 0.3s ease;
319: }
320: 
321: .fade-enter-from,
322: .fade-leave-to {
323:   opacity: 0;
324: }
</file>

<file path="docs/.vitepress/theme/index.ts">
 1: import { h } from 'vue'
 2: import type { Theme } from 'vitepress'
 3: import DefaultTheme from 'vitepress/theme'
 4: import FileTree from '../components/FileTree.vue'
 5: import ArchitectureDiagram from '../components/ArchitectureDiagram.vue'
 6: import ApiExplorer from '../components/ApiExplorer.vue'
 7: import ProjectStructure from '../components/ProjectStructure.vue'
 8: import LogoutButton from '../components/LogoutButton.vue'
 9: import FirebaseAuth from './FirebaseAuth.vue'
10: import './custom.css'
11: 
12: export default {
13:   extends: DefaultTheme,
14:   
15:   enhanceApp({ app }) {
16:     app.component('FileTree', FileTree)
17:     app.component('ArchitectureDiagram', ArchitectureDiagram)
18:     app.component('ApiExplorer', ApiExplorer)
19:     app.component('ProjectStructure', ProjectStructure)
20:   },
21: 
22:   Layout: () => {
23:     return h(FirebaseAuth, null, {
24:       default: () => h(DefaultTheme.Layout, null, {
25:         'nav-bar-content-after': () => h('div', { class: 'nav-controls' }, [
26:           h('div', { class: 'nav-item' }, [
27:             h(LogoutButton)
28:           ])
29:         ])
30:       })
31:     })
32:   }
33: } satisfies Theme
</file>

<file path="docs/.vitepress/utils/fileStructureParser.ts">
  1: // .vitepress/utils/fileStructureParser.ts
  2: 
  3: // Define the interface once
  4: interface FileStructure {
  5:   directories: {
  6:     [key: string]: {
  7:       directories: string[]
  8:       files: string[]
  9:     }
 10:   }
 11:   root_files: string[]
 12:   metadata?: {
 13:     root_directory: string
 14:     generated_date: string
 15:   }
 16: }
 17: 
 18: // Export the interface as a type
 19: export type { FileStructure }
 20: 
 21: // Parse XML function
 22: export function parseFileStructure(xmlText: string): FileStructure {
 23:   const parser = new DOMParser()
 24:   const xmlDoc = parser.parseFromString(xmlText, 'text/xml')
 25:   
 26:   const structure: FileStructure = {
 27:     directories: {},
 28:     root_files: [],
 29:     metadata: {
 30:       root_directory: '',
 31:       generated_date: ''
 32:     }
 33:   }
 34: 
 35:   // Parse metadata
 36:   const metadata = xmlDoc.querySelector('metadata')
 37:   if (metadata) {
 38:     const rootDir = metadata.querySelector('root_directory')
 39:     const genDate = metadata.querySelector('generated_date')
 40:     structure.metadata = {
 41:       root_directory: rootDir?.textContent || '',
 42:       generated_date: genDate?.textContent || ''
 43:     }
 44:   }
 45: 
 46:   // Parse directories section
 47:   const directoriesSection = xmlDoc.querySelector('directories')
 48:   if (directoriesSection) {
 49:     // Process functions directory and its subdirectories
 50:     const functionsDir = directoriesSection.querySelector('functions')
 51:     if (functionsDir) {
 52:       // Initialize the functions directory
 53:       structure.directories['functions'] = {
 54:         directories: [],
 55:         files: []
 56:       }
 57: 
 58:       // Process subdirectories
 59:       const directories = functionsDir.querySelector('directories')
 60:       if (directories) {
 61:         directories.querySelectorAll('directory').forEach(dir => {
 62:           const dirPath = dir.textContent?.trim()
 63:           if (dirPath) {
 64:             const parts = dirPath.split('\\').join('/').split('/')
 65:             let currentPath = ''
 66:             
 67:             parts.forEach((part, index) => {
 68:               const path = index === 0 ? part : `${currentPath}/${part}`
 69:               if (!structure.directories[path]) {
 70:                 structure.directories[path] = {
 71:                   directories: [],
 72:                   files: []
 73:                 }
 74:               }
 75:               if (index > 0) {
 76:                 const parentPath = parts.slice(0, index).join('/')
 77:                 if (!structure.directories[parentPath].directories.includes(path)) {
 78:                   structure.directories[parentPath].directories.push(path)
 79:                 }
 80:               }
 81:               currentPath = path
 82:             })
 83:           }
 84:         })
 85:       }
 86: 
 87:       // Process files
 88:       const files = functionsDir.querySelector('files')
 89:       if (files) {
 90:         files.querySelectorAll('file').forEach(file => {
 91:           const filePath = file.textContent?.trim()
 92:           if (filePath) {
 93:             const normalizedPath = filePath.split('\\').join('/')
 94:             const parts = normalizedPath.split('/')
 95:             const fileName = parts.pop() || ''
 96:             const dirPath = parts.join('/')
 97:             
 98:             if (dirPath && structure.directories[dirPath]) {
 99:               if (!structure.directories[dirPath].files.includes(fileName)) {
100:                 structure.directories[dirPath].files.push(fileName)
101:               }
102:             }
103:           }
104:         })
105:       }
106:     }
107:   }
108: 
109:   // Parse root files
110:   const rootFilesSection = xmlDoc.querySelector('root_files')
111:   if (rootFilesSection) {
112:     rootFilesSection.querySelectorAll('file').forEach(file => {
113:       const fileName = file.textContent?.trim()
114:       if (fileName && !structure.root_files.includes(fileName)) {
115:         structure.root_files.push(fileName)
116:       }
117:     })
118:   }
119: 
120:   // Sort all arrays
121:   structure.root_files.sort()
122:   Object.values(structure.directories).forEach(dir => {
123:     dir.directories.sort()
124:     dir.files.sort()
125:   })
126: 
127:   return structure
128: }
129: 
130: // Helper function to normalize file paths
131: function normalizePath(path: string): string {
132:   return path.split('\\').join('/')
133: }
134: 
135: // Helper function to get file extension
136: export function getFileExtension(filename: string): string {
137:   return filename.split('.').pop()?.toLowerCase() || ''
138: }
139: 
140: // Helper function to check if a file should be hidden
141: export function isHiddenFile(filename: string): boolean {
142:   return filename.startsWith('.')
143: }
144: 
145: // Helper function to group files by type
146: export function groupFilesByType(files: string[]): Record<string, string[]> {
147:   return files.reduce((acc, file) => {
148:     const ext = getFileExtension(file)
149:     if (!acc[ext]) {
150:       acc[ext] = []
151:     }
152:     acc[ext].push(file)
153:     return acc
154:   }, {} as Record<string, string[]>)
155: }
156: 
157: // Utility function to add a directory to the structure
158: export function addDirectory(
159:   structure: FileStructure,
160:   path: string
161: ): void {
162:   const normalizedPath = normalizePath(path)
163:   if (!structure.directories[normalizedPath]) {
164:     structure.directories[normalizedPath] = {
165:       directories: [],
166:       files: []
167:     }
168:     
169:     // Update parent directory
170:     const parts = normalizedPath.split('/')
171:     if (parts.length > 1) {
172:       const parentPath = parts.slice(0, -1).join('/')
173:       if (!structure.directories[parentPath]) {
174:         addDirectory(structure, parentPath)
175:       }
176:       if (!structure.directories[parentPath].directories.includes(normalizedPath)) {
177:         structure.directories[parentPath].directories.push(normalizedPath)
178:       }
179:     }
180:   }
181: }
182: 
183: // Utility function to add a file to the structure
184: export function addFile(
185:   structure: FileStructure,
186:   filePath: string,
187:   isRootFile: boolean = false
188: ): void {
189:   const normalizedPath = normalizePath(filePath)
190:   if (isRootFile) {
191:     if (!structure.root_files.includes(normalizedPath)) {
192:       structure.root_files.push(normalizedPath)
193:     }
194:     return
195:   }
196: 
197:   const parts = normalizedPath.split('/')
198:   const fileName = parts.pop() || ''
199:   const dirPath = parts.join('/')
200: 
201:   if (dirPath) {
202:     if (!structure.directories[dirPath]) {
203:       addDirectory(structure, dirPath)
204:     }
205:     if (!structure.directories[dirPath].files.includes(fileName)) {
206:       structure.directories[dirPath].files.push(fileName)
207:     }
208:   } else {
209:     addFile(structure, fileName, true)
210:   }
211: }
212: 
213: // Utility function to validate the file structure
214: export function validateFileStructure(structure: FileStructure): boolean {
215:   // Check required properties
216:   if (!structure.directories || !structure.root_files) {
217:     return false
218:   }
219: 
220:   // Validate directories
221:   for (const [path, dir] of Object.entries(structure.directories)) {
222:     // Check directory has required properties
223:     if (!dir.directories || !dir.files) {
224:       return false
225:     }
226: 
227:     // Validate subdirectories
228:     for (const subDir of dir.directories) {
229:       if (!structure.directories[subDir]) {
230:         return false
231:       }
232:     }
233: 
234:     // Validate path format
235:     if (path.includes('\\')) {
236:       return false
237:     }
238:   }
239: 
240:   return true
241: }
</file>

<file path="docs/api/index.md">
  1: # API Documentation
  2: 
  3: ## Overview
  4: 
  5: The FFTCG Sync Service API provides endpoints for card and price synchronization,
  6:  with support for both testing and production operations. All endpoints are
  7:   HTTPS-only and most require Firebase authentication.
  8: 
  9: ## API Authentication
 10: 
 11: The service uses Firebase Authentication. Protected endpoints require a valid
 12:  Firebase ID token. For implementation details, see our [Security Guidelines](/security).
 13: 
 14: ```typescript
 15: // Get Firebase auth token
 16: const getAuthToken = async (): Promise<string | null> => {
 17:   const auth = getAuth();
 18:   const user = auth.currentUser;
 19:   if (user) {
 20:     return await user.getIdToken();
 21:   }
 22:   return null;
 23: };
 24: 
 25: // Use in requests
 26: const headers = {
 27:   'Authorization': `Bearer ${await getAuthToken()}`,
 28:   'Content-Type': 'application/json'
 29: };
 30: ```
 31: 
 32: ## Base URL
 33: 
 34: ```http
 35: https://us-central1-fftcg-sync-service.cloudfunctions.net
 36: ```
 37: 
 38: ## Endpoints
 39: 
 40: ### Card Synchronization
 41: 
 42: For detailed implementation, see [Card Sync Service](/services/card-sync).
 43: 
 44: #### Test Card Sync
 45: 
 46: Test card synchronization with configurable options.
 47: 
 48: ```http
 49: GET /testCardSync
 50: ```
 51: 
 52: Query Parameters:
 53: 
 54: | Name | Type | Required | Default | Description |
 55: |------|------|----------|---------|-------------|
 56: | dryRun | boolean | No | true | Run without making changes |
 57: | limit | number | No | 5 | Maximum number of cards to process |
 58: | groupId | string | No | - | Process specific group only |
 59: 
 60: Response:
 61: 
 62: ```typescript
 63: interface SyncMetadata {
 64:   lastSync: Date;
 65:   status: "in_progress" | "success" | "failed" | "completed_with_errors";
 66:   cardCount: number;
 67:   type: "manual" | "scheduled";
 68:   groupsProcessed: number;
 69:   groupsUpdated: number;
 70:   errors: string[];
 71:   duration?: number;
 72:   imagesProcessed?: number;
 73:   imagesUpdated?: number;
 74: }
 75: ```
 76: 
 77: #### Manual Card Sync
 78: 
 79: Trigger a full card synchronization with production settings.
 80: 
 81: ```http
 82: GET /manualCardSync
 83: ```
 84: 
 85: Response: Same as Test Card Sync
 86: 
 87: ### Price Synchronization
 88: 
 89: For detailed implementation, see [Price Sync Service](/services/price-sync).
 90: 
 91: #### Test Price Sync
 92: 
 93: Test price synchronization with configurable options.
 94: 
 95: ```http
 96: GET /testPriceSync
 97: ```
 98: 
 99: Query Parameters:
100: 
101: | Name | Type | Required | Default | Description |
102: |------|------|----------|---------|-------------|
103: | dryRun | boolean | No | true | Run without making changes |
104: | limit | number | No | - | Maximum number of prices to process |
105: | groupId | string | No | - | Process specific group only |
106: | productId | number | No | - | Process specific product only |
107: | showAll | boolean | No | false | Show all prices, including unchanged |
108: 
109: Response:
110: 
111: ```typescript
112: interface SyncMetadata {
113:   lastSync: Date;
114:   status: string;
115:   cardCount: number;
116:   type: "manual" | "scheduled";
117:   groupsProcessed: number;
118:   groupsUpdated: number;
119:   errors: string[];
120:   duration?: number;
121: }
122: ```
123: 
124: #### Manual Price Sync
125: 
126: Trigger a full price synchronization with production settings.
127: 
128: ```http
129: GET /manualPriceSync
130: ```
131: 
132: Response: Same as Test Price Sync
133: 
134: ### System Health
135: 
136: For monitoring configuration, see our [Monitoring Guide](/monitoring/index).
137: 
138: #### Health Check
139: 
140: Check system health status.
141: 
142: ```http
143: GET /healthCheck
144: ```
145: 
146: Response:
147: 
148: ```json
149: {
150:   "status": "healthy",
151:   "timestamp": "2024-11-23T01:47:16.617Z",
152:   "version": "1.0.0"
153: }
154: ```
155: 
156: ## Interactive API Explorer
157: 
158: Test the API endpoints using our interactive explorer:
159: 
160: <ApiExplorer />
161: 
162: ## Runtime Configuration
163: 
164: For detailed configuration options, see the [Configuration Guide](/setup/configuration).
165: 
166: ```typescript
167: export const runtimeOpts = {
168:   timeoutSeconds: 540,
169:   memory: "1GiB",
170: } as const;
171: ```
172: 
173: Function-specific configurations:
174: 
175: - Scheduled Functions: 3 retry attempts
176: - Request Functions: Single instance limit
177: - Health Check: 10-second timeout, 128MB memory
178: 
179: ## Rate Limiting
180: 
181: For detailed rate limiting implementation, see our [Monitoring Guide](/monitoring/index).
182: 
183: - Function timeouts: 540 seconds
184: - Memory allocation: 1GB per function
185: - Maximum instances: 1 per function
186: - Retry count: 3 (for scheduled functions)
187: - Request delay: Exponential backoff starting at 1000ms
188: 
189: ## Error Response Format
190: 
191: For complete error handling documentation, see [Error Handling](/utils/error-handling).
192: 
193: ```typescript
194: interface ErrorResponse {
195:   error: string;
196:   code?: string;
197:   details?: Record<string, unknown>;
198:   timestamp: string;
199: }
200: ```
201: 
202: Example error:
203: 
204: ```json
205: {
206:   "error": "Group not found",
207:   "code": "GROUP_NOT_FOUND",
208:   "details": {
209:     "groupId": "23783"
210:   },
211:   "timestamp": "2024-11-23T01:47:16.617Z"
212: }
213: ```
214: 
215: ## Data Models
216: 
217: For complete type definitions, see [Types Reference](/reference/types).
218: 
219: ### Card Product
220: 
221: ```typescript
222: interface CardProduct {
223:   productId: number;
224:   name: string;
225:   cleanName: string;
226:   imageUrl: string;
227:   storageImageUrl?: string;
228:   categoryId: number;
229:   groupId: number;
230:   url: string;
231:   modifiedOn: string;
232:   imageCount: number;
233:   imageMetadata?: ImageMetadata;
234:   extendedData: Array<{
235:     name: string;
236:     displayName: string;
237:     value: string;
238:   }>;
239: }
240: ```
241: 
242: ### Card Price
243: 
244: ```typescript
245: interface CardPrice {
246:   productId: number;
247:   lowPrice: number;
248:   midPrice: number;
249:   highPrice: number;
250:   marketPrice: number | null;
251:   directLowPrice: number | null;
252:   subTypeName: "Normal" | "Foil";
253: }
254: ```
255: 
256: ### Image Metadata
257: 
258: For image handling details, see [Image Handler](/utils/image-handler).
259: 
260: ```typescript
261: interface ImageMetadata {
262:   contentType: string;
263:   size: number;
264:   updated: Date;
265:   hash: string;
266:   originalUrl: string;
267:   highResUrl: string;
268:   originalSize?: number;
269:   highResSize?: number;
270: }
271: ```
272: 
273: ## Implementation Guidelines
274: 
275: ### Request Rate Limiting
276: 
277: For detailed implementation, see [Request Handler](/utils/request).
278: 
279: ```typescript
280: // Implement delays between requests
281: await new Promise(resolve => setTimeout(resolve, 1000));
282: 
283: // Use exponential backoff
284: const delay = Math.pow(2, retryCount) * 1000;
285: ```
286: 
287: ### Error Handling Implementation
288: 
289: For detailed error handling, see [Error Handling](/utils/error-handling).
290: 
291: ```typescript
292: try {
293:   const response = await fetch(endpoint);
294:   if (!response.ok) {
295:     throw new Error(`HTTP error! status: ${response.status}`);
296:   }
297:   return await response.json();
298: } catch (error) {
299:   console.error('API request failed:', error);
300:   throw error;
301: }
302: ```
303: 
304: ### Authentication Implementation
305: 
306: For security implementation details, see [Security Guidelines](/security).
307: 
308: ```typescript
309: // Check token expiration
310: const token = await getAuthToken();
311: if (!token) {
312:   throw new Error('Authentication required');
313: }
314: 
315: // Include token in requests
316: const headers = {
317:   'Authorization': `Bearer ${token}`,
318:   'Content-Type': 'application/json'
319: };
320: ```
321: 
322: ## Support
323: 
324: For API support:
325: 
326: - Check the [Troubleshooting Guide](/troubleshooting)
327: - Review [System Status](https://status.fftcg-sync-service.web.app)
328: - Contact support team
329: - See [Common Issues](/troubleshooting/common-issues)
330: 
331: ## Additional Resources
332: 
333: - [Installation Guide](/setup/installation)
334: - [Configuration Guide](/setup/configuration)
335: - [Deployment Guide](/deployment/)
336: - [Monitoring Guide](/monitoring/index)
</file>

<file path="docs/architecture.md">
  1: # System Architecture
  2: 
  3: ## Overview
  4: 
  5: FFTCG Sync Service is a Firebase-based application designed to synchronize Final
  6:  Fantasy Trading Card Game data. The system uses Firebase Cloud Functions for
  7:   serverless operations, Firestore for data storage, and Firebase Storage for
  8:    image management. For setup details, see our [Installation Guide](/setup/installation).
  9: 
 10: ## System Diagram
 11: 
 12: The diagram below illustrates the key components and their interactions. Each
 13:  color represents a different component type:
 14: 
 15: <ArchitectureDiagram :zoom="1.2" :showLabels="true" />
 16: 
 17: ::: tip Component Types
 18: 
 19: - Blue: Firebase Services (Functions, Firestore, Auth)
 20: - Green: Storage Systems (Cloud Storage, Cache)
 21: - Orange: Core Functions (Card Sync, Price Sync, Image Processing)
 22: - Gray: External Services (TCGPlayer API)
 23: :::
 24: 
 25: ## Core Components
 26: 
 27: ### Firebase Services
 28: 
 29: For detailed configuration, see [Firebase Configuration Guide](/setup/firebase-config).
 30: 
 31: #### Cloud Functions
 32: 
 33: ```typescript
 34: // Runtime Configuration
 35: export const runtimeOpts = {
 36:   timeoutSeconds: 540,
 37:   memory: "1GiB",
 38: } as const;
 39: 
 40: // Scheduled Functions
 41: export const scheduledCardSync = onSchedule({
 42:   schedule: "0 21 * * *",  // Daily at 21:00 UTC
 43:   timeZone: "UTC",
 44:   memory: runtimeOpts.memory,
 45:   timeoutSeconds: runtimeOpts.timeoutSeconds,
 46:   retryCount: 3,
 47: });
 48: 
 49: export const scheduledPriceSync = onSchedule({
 50:   schedule: "30 21 * * *", // Daily at 21:30 UTC
 51:   timeZone: "UTC",
 52:   memory: runtimeOpts.memory,
 53:   timeoutSeconds: runtimeOpts.timeoutSeconds,
 54:   retryCount: 3,
 55: });
 56: ```
 57: 
 58: #### Firestore Collections
 59: 
 60: For collection usage details, see [API Documentation](/api/).
 61: 
 62: ```typescript
 63: export const COLLECTION = {
 64:   CARDS: "cards",           // Card information
 65:   PRICES: "prices",         // Price data
 66:   SYNC_METADATA: "syncMetadata",  // Sync operation logs
 67:   LOGS: "logs",            // System logs
 68:   CARD_HASHES: "cardHashes",  // Card data version control
 69:   PRICE_HASHES: "priceHashes",  // Price data version control
 70:   IMAGE_METADATA: "imageMetadata",  // Image processing metadata
 71: };
 72: ```
 73: 
 74: #### Storage Configuration
 75: 
 76: For storage implementation details, see [Image Handler](/utils/image-handler).
 77: 
 78: ```typescript
 79: export const STORAGE = {
 80:   BUCKETS: {
 81:     CARD_IMAGES: "fftcg-sync-service.firebasestorage.app",
 82:   },
 83:   PATHS: {
 84:     IMAGES: "card-images",
 85:   },
 86: };
 87: ```
 88: 
 89: ### Core Services
 90: 
 91: #### Card Synchronization
 92: 
 93: For detailed implementation, see [Card Sync Service](/services/card-sync).
 94: 
 95: - Daily automated sync (21:00 UTC)
 96: - Image processing and optimization
 97: - Hash-based change detection
 98: - Batch processing with configurable limits
 99: 
100: #### Price Synchronization
101: 
102: For detailed implementation, see [Price Sync Service](/services/price-sync).
103: 
104: - Daily automated sync (21:30 UTC)
105: - Price history tracking
106: - Market price monitoring
107: - Batch updates with validation
108: 
109: #### Image Processing
110: 
111: For detailed implementation, see [Image Handler](/utils/image-handler) and
112:  [Image Compressor](/utils/image-compressor).
113: 
114: - Dual resolution support (200w/400w)
115: - Progressive JPEG compression
116: - Metadata tracking
117: - Cache integration
118: 
119: ### Utility Systems
120: 
121: #### Caching System
122: 
123: For implementation details, see [Cache System](/utils/cache).
124: 
125: ```typescript
126: // Multiple cache layers
127: const cacheOptions = {
128:   cardCache: {
129:     max: 500,
130:     ttl: 1000 * 60 * 60  // 1 hour
131:   },
132:   imageCache: {
133:     metadata: {
134:       max: 1000,
135:       ttl: 1000 * 60 * 60  // 1 hour
136:     },
137:     buffer: {
138:       max: 100,
139:       ttl: 1000 * 60 * 5,  // 5 minutes
140:       maxSize: 50 * 1024 * 1024  // 50MB
141:     }
142:   }
143: };
144: ```
145: 
146: #### Batch Processing
147: 
148: For implementation details, see [Batch Processing](/utils/batch).
149: 
150: ```typescript
151: interface BatchOptions {
152:   batchSize?: number;  // Default: 500
153:   delayBetweenBatches?: number;  // Default: 100ms
154:   onBatchComplete?: (stats: BatchProcessingStats) => Promise<void>;
155: }
156: ```
157: 
158: #### Error Handling
159: 
160: For detailed implementation, see [Error Handling](/utils/error-handling).
161: 
162: ```typescript
163: interface ErrorReport {
164:   timestamp: Date;
165:   context: string;
166:   error: string;
167:   stackTrace?: string;
168:   metadata?: Record<string, unknown>;
169:   severity: "ERROR" | "WARNING" | "CRITICAL";
170: }
171: ```
172: 
173: ## Data Flow
174: 
175: ### Synchronization Process
176: 
177: ```mermaid
178: sequenceDiagram
179:     participant TCG as TCGPlayer API
180:     participant Func as Cloud Functions
181:     participant Store as Firestore
182:     participant Storage as Cloud Storage
183:     participant Cache as Memory Cache
184: 
185:     Func->>TCG: Request card/price data
186:     TCG-->>Func: Return data
187:     Func->>Cache: Check hash cache
188:     Cache-->>Func: Return cache status
189:     
190:     alt Data Changed
191:         Func->>Store: Update card/price data
192:         Func->>Storage: Process images
193:         Func->>Cache: Update cache
194:     else No Change
195:         Func->>Store: Update sync metadata
196:     end
197: ```
198: 
199: ### Image Processing Pipeline
200: 
201: ```mermaid
202: graph TD
203:     A[Download Image] -->|Validate| B[Check Cache]
204:     B -->|Miss| C[Process Image]
205:     C -->|Compress| D[Store Image]
206:     D -->|Update| E[Cache Result]
207:     B -->|Hit| F[Return Cached]
208: ```
209: 
210: ## Performance Optimization
211: 
212: For detailed performance guidelines, see [Performance Guide](/performance).
213: 
214: ### Resource Management
215: 
216: - Memory allocation: 1GB per function
217: - Function timeout: 540 seconds
218: - Batch size: 500 items
219: - Cache TTL: Configurable per type
220: 
221: ### Rate Limiting
222: 
223: For rate limiting implementation, see [Request Handler](/utils/request).
224: 
225: ```typescript
226: const rateLimits = {
227:   tcgPlayer: {
228:     requestsPerMinute: 100,
229:     concurrentRequests: 10
230:   },
231:   storage: {
232:     uploadsPerMinute: 50,
233:     maxConcurrent: 5
234:   }
235: };
236: ```
237: 
238: ## Security
239: 
240: For detailed security implementation, see [Security Guidelines](/security).
241: 
242: ### Authentication
243: 
244: - Firebase Authentication
245: - Service account credentials
246: - Token-based API access
247: 
248: ### Data Protection
249: 
250: ```typescript
251: // Storage Rules
252: service firebase.storage {
253:   match /b/{bucket}/o {
254:     match /card-images/{groupId}/{imageId} {
255:       allow read: if true;
256:       allow write: if request.auth != null 
257:         && request.auth.token.admin == true;
258:     }
259:   }
260: }
261: ```
262: 
263: ## Monitoring
264: 
265: For detailed monitoring setup, see [Monitoring Guide](/monitoring/).
266: 
267: ### Health Checks
268: 
269: ```typescript
270: export const healthCheck = onRequest({
271:   timeoutSeconds: 10,
272:   memory: "128MiB",
273: }, async (_req: Request, res: Response) => {
274:   res.json({
275:     status: "healthy",
276:     timestamp: new Date().toISOString(),
277:     version: "1.0.0",
278:   });
279: });
280: ```
281: 
282: ### Logging System
283: 
284: For logging implementation details, see [Logging System](/utils/logging).
285: 
286: - Structured logging
287: - Error tracking
288: - Performance monitoring
289: - Operation auditing
290: 
291: ## Additional Resources
292: 
293: - [Installation Guide](/setup/installation)
294: - [Configuration Guide](/setup/configuration)
295: - [API Documentation](/api/)
296: - [Troubleshooting Guide](/troubleshooting)
</file>

<file path="docs/deployment/index.md">
  1: # Deployment Guide
  2: 
  3: ## Overview
  4: 
  5: This guide covers the complete deployment process for the FFTCG Sync Service,
  6:  including initial setup, Firebase configuration, and continuous deployment
  7:   practices. For base configuration, see our [Configuration Guide](/setup/configuration).
  8: 
  9: ## Prerequisites
 10: 
 11: - Node.js 18 or higher
 12: - Firebase CLI installed (`npm install -g firebase-tools`)
 13: - Firebase project created with:
 14:   - Cloud Functions enabled
 15:   - Firestore Database
 16:   - Cloud Storage
 17:   - Authentication configured
 18: 
 19: See [Installation Guide](/setup/installation) for detailed setup instructions.
 20: 
 21: ## Initial Setup
 22: 
 23: ### 1. Firebase Project Configuration
 24: 
 25: ```bash
 26: # Login to Firebase
 27: firebase login
 28: 
 29: # Initialize project
 30: firebase init
 31: 
 32: # Select required features:
 33: # - Functions
 34: # - Firestore
 35: # - Storage
 36: ```
 37: 
 38: ### 2. Environment Configuration
 39: 
 40: Create `.env` file:
 41: 
 42: ```env
 43: FIREBASE_PROJECT_ID=your-project-id
 44: FIREBASE_STORAGE_BUCKET=your-storage-bucket
 45: FIREBASE_REGION=us-central1
 46: FIREBASE_MEMORY_ALLOCATION=1GB
 47: FIREBASE_TIMEOUT=540
 48: ```
 49: 
 50: ### 3. Service Account Setup
 51: 
 52: 1. Generate service account key from Firebase Console
 53: 2. Save as `service_account_key.json`
 54: 3. Configure environment variable:
 55: 
 56: ```env
 57: FIREBASE_SERVICE_ACCOUNT_PATH=path/to/service_account_key.json
 58: ```
 59: 
 60: ## Deployment Process
 61: 
 62: ### 1. Build and Test
 63: 
 64: ```bash
 65: # Install dependencies
 66: npm install
 67: 
 68: # Run linting
 69: npm run lint
 70: 
 71: # Fix linting issues
 72: npm run lint:fix
 73: 
 74: # Build the project
 75: npm run build
 76: ```
 77: 
 78: ### 2. Function Deployment
 79: 
 80: ```bash
 81: # Deploy all functions
 82: npm run deploy
 83: 
 84: # Deploy specific function
 85: firebase deploy --only functions:functionName
 86: ```
 87: 
 88: ### 3. Security Rules Deployment
 89: 
 90: For detailed security implementation, see [Security Guidelines](/security).
 91: 
 92: #### Firestore Rules
 93: 
 94: ```typescript
 95: // firestore.rules
 96: rules_version = '2';
 97: service cloud.firestore {
 98:   match /databases/{database}/documents {
 99:     match /cards/{cardId} {
100:       allow read: if true;
101:       allow write: if request.auth != null 
102:         && request.auth.token.admin == true;
103:     }
104:     
105:     match /prices/{priceId} {
106:       allow read: if true;
107:       allow write: if request.auth != null 
108:         && request.auth.token.admin == true;
109:     }
110:   }
111: }
112: ```
113: 
114: #### Storage Rules
115: 
116: ```typescript
117: // storage.rules
118: rules_version = '2';
119: service firebase.storage {
120:   match /b/{bucket}/o {
121:     match /card-images/{groupId}/{imageId} {
122:       allow read: if true;
123:       allow write: if request.auth != null 
124:         && request.auth.token.admin == true
125:         && request.resource.size < 5 * 1024 * 1024
126:         && request.resource.contentType.matches('image/jpeg');
127:     }
128:   }
129: }
130: ```
131: 
132: ## Function Configuration
133: 
134: ### Runtime Options
135: 
136: For detailed configuration options, see [Configuration Guide](/setup/configuration).
137: 
138: ```typescript
139: export const runtimeOpts = {
140:   timeoutSeconds: 540,
141:   memory: "1GiB",
142: } as const;
143: ```
144: 
145: ### Scheduled Functions
146: 
147: For service implementation details, see [Card Sync Service](/services/card-sync)
148:  and [Price Sync Service](/services/price-sync).
149: 
150: ```typescript
151: export const scheduledCardSync = onSchedule({
152:   schedule: "0 21 * * *",  // Daily at 21:00 UTC
153:   timeZone: "UTC",
154:   memory: runtimeOpts.memory,
155:   timeoutSeconds: runtimeOpts.timeoutSeconds,
156:   retryCount: 3,
157: });
158: ```
159: 
160: ## Post-Deployment Verification
161: 
162: ### 1. Health Check
163: 
164: ```bash
165: curl https://${REGION}-${PROJECT_ID}.cloudfunctions.net/healthCheck
166: ```
167: 
168: Expected response:
169: 
170: ```json
171: {
172:   "status": "healthy",
173:   "timestamp": "2024-11-23T01:47:16.617Z",
174:   "version": "1.0.0"
175: }
176: ```
177: 
178: ### 2. Test Sync Operations
179: 
180: For API endpoints documentation, see [API Documentation](/api/).
181: 
182: ```bash
183: # Test card sync
184: curl https://${REGION}-${PROJECT_ID}.cloudfunctions.net/testCardSync?dryRun=true&limit=5
185: 
186: # Test price sync
187: curl https://${REGION}-${PROJECT_ID}.cloudfunctions.net/testPriceSync?dryRun=true&limit=5
188: ```
189: 
190: ## Deployment Checklist
191: 
192: ### Pre-Deployment
193: 
194: - [ ] All tests passing
195: - [ ] Linting issues resolved
196: - [ ] Environment variables configured
197: - [ ] Security rules updated
198: - [ ] Dependencies updated
199: 
200: ### Deployment
201: 
202: - [ ] Build successful
203: - [ ] Functions deployed
204: - [ ] Security rules deployed
205: - [ ] Storage rules deployed
206: 
207: ### Post-Deployment
208: 
209: - [ ] Health check passing
210: - [ ] Test syncs successful
211: - [ ] Logs accessible
212: - [ ] Monitoring configured
213: 
214: ## Rollback Procedures
215: 
216: ### Function Rollback
217: 
218: ```bash
219: # List previous versions
220: firebase functions:list
221: 
222: # Rollback to specific version
223: firebase functions:rollback <version>
224: ```
225: 
226: ### Security Rules Rollback
227: 
228: ```bash
229: # Firestore rules
230: firebase firestore:rules:list
231: firebase firestore:rules:rollback <version>
232: 
233: # Storage rules
234: firebase storage:rules:list
235: firebase storage:rules:rollback <version>
236: ```
237: 
238: ## Best Practices
239: 
240: ### Security
241: 
242: For security implementation details, see [Security Guidelines](/security).
243: 
244: - Implement proper IAM roles
245: - Use secure environment variables
246: - Regular security audits
247: - Monitor access patterns
248: 
249: ### Performance
250: 
251: For performance optimization details, see [Performance Guide](/performance).
252: 
253: - Configure appropriate memory
254: - Set proper timeouts
255: - Implement caching
256: - Monitor resource usage
257: 
258: ### Maintenance
259: 
260: For monitoring setup, see [Monitoring Guide](/monitoring/).
261: 
262: - Regular dependency updates
263: - Log rotation
264: - Performance monitoring
265: - Error tracking
266: 
267: ## Related Documentation
268: 
269: - [Configuration Guide](/setup/configuration)
270: - [Security Guidelines](/security)
271: - [Monitoring Guide](/monitoring/)
272: - [Troubleshooting Guide](/troubleshooting/common-issues)
</file>

<file path="docs/env.d.ts">
 1: /// <reference types="vite/client" />
 2: 
 3: interface ImportMetaEnv {
 4:     readonly VITE_FIREBASE_API_KEY: string
 5:     readonly VITE_FIREBASE_AUTH_DOMAIN: string
 6:     readonly VITE_FIREBASE_PROJECT_ID: string
 7:     readonly VITE_FIREBASE_STORAGE_BUCKET: string
 8:     readonly VITE_FIREBASE_MESSAGING_SENDER_ID: string
 9:     readonly VITE_FIREBASE_APP_ID: string
10:   }
11:   
12:   interface ImportMeta {
13:     readonly env: ImportMetaEnv
14:   }
</file>

<file path="docs/faq.md">
  1: # Frequently Asked Questions
  2: 
  3: ## General
  4: 
  5: ### What is FFTCG Sync Service?
  6: 
  7: A Firebase-based service that synchronizes Final Fantasy Trading Card Game data
  8:  from TCGplayer, including card information, prices, and images.
  9: 
 10: ### What are the system requirements?
 11: 
 12: - Node.js 18 or higher
 13: - Firebase CLI
 14: - Firebase project with Firestore and Storage enabled
 15: - 1GB minimum memory allocation
 16: - Sufficient storage quota for card images
 17: 
 18: ### How often does the service sync data?
 19: 
 20: - Cards: Daily at 21:00 UTC
 21: - Prices: Daily at 21:30 UTC
 22: - Images: During card synchronization
 23: 
 24: ## Synchronization
 25: 
 26: ### How do I manually trigger a sync?
 27: 
 28: ```typescript
 29: // For cards
 30: await syncCards({
 31:   dryRun: false,
 32:   limit: undefined,
 33:   groupId: undefined
 34: });
 35: 
 36: // For prices
 37: await syncPrices({
 38:   dryRun: false,
 39:   limit: undefined,
 40:   groupId: undefined
 41: });
 42: ```
 43: 
 44: ### What is dry run mode?
 45: 
 46: Dry run mode (`dryRun: true`) allows you to test synchronization without making
 47:  any changes to the database. It's useful for:
 48: 
 49: - Validating data before actual sync
 50: - Testing configuration changes
 51: - Debugging sync issues
 52: 
 53: ### How do I sync specific card groups?
 54: 
 55: ```typescript
 56: const options = {
 57:   groupId: "23783",  // Specific group ID
 58:   dryRun: false
 59: };
 60: await syncCards(options);
 61: ```
 62: 
 63: ### Why are some syncs skipped?
 64: 
 65: Syncs may be skipped when:
 66: 
 67: - Data hasn't changed (verified via hash comparison)
 68: - Rate limits are reached
 69: - Previous sync is still in progress
 70: - Network issues occur
 71: 
 72: ## Image Processing
 73: 
 74: ### What image formats are supported?
 75: 
 76: Currently, only JPEG images are supported. The service:
 77: 
 78: - Validates JPEG format
 79: - Checks file signatures
 80: - Enforces size limits (5MB max)
 81: 
 82: ### How are images optimized?
 83: 
 84: Images are processed in two ways:
 85: 
 86: - Standard resolution (200px width)
 87: - High resolution (400px width)
 88: 
 89: Both versions are:
 90: 
 91: - Compressed using mozjpeg
 92: - Progressive loading enabled
 93: - Quality optimized (85-90%)
 94: 
 95: ### Why are some images not updating?
 96: 
 97: Images might not update if:
 98: 
 99: - Hash matches existing image
100: - Validation fails
101: - Storage quota is exceeded
102: - Network errors occur
103: 
104: ## Firebase Integration
105: 
106: ### How is data stored in Firestore?
107: 
108: Data is organized in collections:
109: 
110: - `cards`: Card information
111: - `prices`: Price history
112: - `cardHashes`: Change detection
113: - `priceHashes`: Price updates
114: - `imageMetadata`: Image information
115: - `syncMetadata`: Sync status
116: - `logs`: System logs
117: 
118: ### How are images stored?
119: 
120: Images are stored in Firebase Storage:
121: 
122: - Path format: `card-images/{groupId}/{productId}_{resolution}.jpg`
123: - Metadata includes hash and timestamp
124: - URLs are signed for long-term access
125: 
126: ### What happens if Firebase quotas are exceeded?
127: 
128: The service will:
129: 
130: 1. Log the quota error
131: 2. Pause operations
132: 3. Retry with exponential backoff
133: 4. Skip non-critical updates
134: 
135: ## Rate Limiting
136: 
137: ### How does rate limiting work?
138: 
139: ```typescript
140: const rateLimiter = {
141:   tokens: 100,
142:   refillRate: 10,
143:   interval: 1000
144: };
145: ```
146: 
147: - Token bucket algorithm
148: - Configurable limits
149: - Automatic retry handling
150: 
151: ### What are the default rate limits?
152: 
153: - API requests: 100 per minute
154: - Image processing: 25 concurrent operations
155: - Database writes: Batch size of 500
156: - Storage operations: 10 concurrent uploads
157: 
158: ### How do I adjust rate limits?
159: 
160: Modify the configuration in your environment:
161: 
162: ```typescript
163: const runtimeOpts = {
164:   timeoutSeconds: 540,
165:   memory: "1GiB",
166: } as const;
167: ```
168: 
169: ## Caching
170: 
171: ### What is cached?
172: 
173: - Card data: 1 hour TTL
174: - Image metadata: 1 hour TTL
175: - Image buffers: 5 minutes TTL
176: - API responses: Request-specific TTL
177: 
178: ### How does the cache hierarchy work?
179: 
180: 1. Memory cache (L1)
181: 2. LRU cache (L2)
182: 3. Firestore (persistent)
183: 
184: ### How do I clear the cache?
185: 
186: ```typescript
187: // Clear specific cache
188: imageCache.clear();
189: cardCache.clear();
190: 
191: // Clear all caches
192: await clearAllCaches();
193: ```
194: 
195: ## Error Handling
196: 
197: ### How are errors logged?
198: 
199: ```typescript
200: // Error logging with context
201: await logDetailedError(
202:   error,
203:   "operationContext",
204:   { metadata: "details" },
205:   "ERROR"
206: );
207: ```
208: 
209: ### What retry mechanisms are in place?
210: 
211: - Maximum 3 retries
212: - Exponential backoff
213: - Configurable delay
214: - Operation-specific handling
215: 
216: ### How do I debug sync failures?
217: 
218: 1. Check sync metadata collection
219: 2. Review error logs
220: 3. Use dry run mode
221: 4. Monitor rate limits
222: 
223: ## Deployment
224: 
225: ### How do I deploy updates?
226: 
227: ```bash
228: # Deploy all functions
229: npm run deploy
230: 
231: # Deploy specific function
232: firebase deploy --only functions:functionName
233: ```
234: 
235: ### How do I test before deployment?
236: 
237: ```bash
238: # Run tests
239: npm run test:images
240: 
241: # Validate sync
242: npm run validate-sync
243: 
244: # Local emulation
245: npm run serve
246: ```
247: 
248: ### What's the deployment rollback process?
249: 
250: 1. Use Firebase Console
251: 2. Select previous version
252: 3. Click "Rollback"
253: 4. Verify functionality
254: 
255: ## Monitoring
256: 
257: ### How do I monitor sync status?
258: 
259: 1. Check sync metadata collection
260: 2. Review logging dashboard
261: 3. Use health check endpoint
262: 4. Monitor performance metrics
263: 
264: ### What metrics are available?
265: 
266: - Sync completion rates
267: - Processing times
268: - Error rates
269: - Cache hit rates
270: - Storage usage
271: - API response times
272: 
273: ### How do I set up alerts?
274: 
275: Configure Firebase Alert conditions for:
276: 
277: - Function failures
278: - High error rates
279: - Quota approaching limits
280: - Sync failures
281: - Performance degradation
</file>

<file path="docs/file_structure.ps1">
  1: # Set working directory
  2: Set-Location -Path "C:\VSCode\fftcg-sync-service\docs"
  3: 
  4: # Create exclusion filters
  5: $excludedDirs = @(
  6:     'node_modules', 
  7:     'functions-backup', 
  8:     'functions\lib', 
  9:     'functions\node_modules',
 10:     '.vitepress\cache',
 11:     '.vitepress\dist'
 12: )
 13: $excludedExtensions = @('.tmp', '.temp', '.log')
 14: $excludedRootFiles = @(
 15:     '.gitignore',
 16:     'codebase.xml',
 17:     'file_structure.ps1',
 18:     'file_structure.xml',
 19:     'service_account_key.json'
 20: )
 21: 
 22: # Initialize XML content
 23: $xmlContent = @"
 24: <?xml version="1.0" encoding="UTF-8"?>
 25: <file_structure>
 26:     <metadata>
 27:         <root_directory>C:\VSCode\fftcg-sync-service\docs</root_directory>
 28:         <generated_date>$((Get-Date -Format "yyyy-MM-dd HH:mm:ss"))</generated_date>
 29:     </metadata>
 30:     <directories>
 31: "@
 32: 
 33: # Function to process directory
 34: function Get-DirectoryStructure {
 35:     param (
 36:         [string]$dirPath,
 37:         [string]$indentation = "        "
 38:     )
 39: 
 40:     $xmlContent = ""
 41:     $xmlContent += "$indentation<$($dirPath.TrimStart('.\'))>`n"
 42:     $xmlContent += "$indentation    <directories>`n"
 43: 
 44:     # Get directories
 45:     $dirs = Get-ChildItem -Path $dirPath -Directory -Recurse | 
 46:         Where-Object { 
 47:             $dir = $_.FullName.Replace("$PWD\", "")
 48:             -not ($excludedDirs | Where-Object { $dir -like "$_*" })
 49:         }
 50: 
 51:     foreach ($dir in $dirs) {
 52:         $relativePath = $dir.FullName.Replace("$PWD\", "")
 53:         $xmlContent += "$indentation        <directory>$([System.Security.SecurityElement]::Escape($relativePath))</directory>`n"
 54:     }
 55: 
 56:     $xmlContent += "$indentation    </directories>`n"
 57:     $xmlContent += "$indentation    <files>`n"
 58: 
 59:     # Get files
 60:     $files = Get-ChildItem -Path $dirPath -File -Recurse | 
 61:         Where-Object { 
 62:             $file = $_
 63:             $relativePath = $file.FullName.Replace("$PWD\", "")
 64:             -not ($excludedDirs | Where-Object { $relativePath -like "$_*" }) -and
 65:             -not ($excludedExtensions | Where-Object { $file.Extension -eq $_ })
 66:         }
 67: 
 68:     foreach ($file in $files) {
 69:         $path = [System.Security.SecurityElement]::Escape($file.FullName.Replace("$PWD\", ""))
 70:         $xmlContent += "$indentation        <file>$path</file>`n"
 71:     }
 72: 
 73:     $xmlContent += "$indentation    </files>`n"
 74:     $xmlContent += "$indentation</$($dirPath.TrimStart('.\'))>`n"
 75: 
 76:     return $xmlContent
 77: }
 78: 
 79: # Process each directory
 80: $directories = @('.vitepress', 'api', 'services', 'setup', 'utils')
 81: foreach ($dir in $directories) {
 82:     $xmlContent += Get-DirectoryStructure -dirPath ".\$dir"
 83: }
 84: 
 85: # Add root files section
 86: $xmlContent += @"
 87:     </directories>
 88:     <root_files>
 89: "@
 90: 
 91: # Get root files
 92: $rootFiles = Get-ChildItem -Path "." -File | 
 93:     Where-Object { 
 94:         -not ($excludedRootFiles -contains $_.Name) -and
 95:         -not ($excludedExtensions | Where-Object { $_.Extension -eq $_ })
 96:     }
 97: 
 98: foreach ($file in $rootFiles) {
 99:     $path = [System.Security.SecurityElement]::Escape($file.FullName.Replace("$PWD\", ""))
100:     $xmlContent += "        <file>$path</file>`n"
101: }
102: 
103: $xmlContent += @"
104:     </root_files>
105: </file_structure>
106: "@
107: 
108: # Save the XML file
109: $xmlContent | Out-File -FilePath "file_structure.xml" -Encoding UTF8
110: 
111: Write-Host "file_structure.xml has been created successfully!"
</file>

<file path="docs/index.md">
 1: ---
 2: layout: home
 3: hero:
 4:   name: FFTCG Sync Service
 5:   text: Card and Price Synchronization Service
 6:   tagline: Automated synchronization and management of FFTCG card data and prices
 7:   actions:
 8:     - theme: brand
 9:       text: Get Started
10:       link: /introduction
11:     - theme: alt
12:       text: View API
13:       link: /api/
14: features:
15:   - title: Card Synchronization
16:     details: Automatically sync card information from external sources
17:   - title: Price Tracking
18:     details: Monitor and update card prices in real-time
19:   - title: Image Processing
20:     details: Automated image downloading, optimization, and storage
21:   - title: Caching System
22:     details: Efficient caching mechanism for improved performance
23: ---
</file>

<file path="docs/integrations/tcgplayer.md">
  1: # TCGPlayer Integration
  2: 
  3: ## Overview
  4: 
  5: The FFTCG Sync Service integrates with TCGPlayer's API to fetch card data, prices,
  6:  and images. This integration forms the core data source for the synchronization
  7:   service.
  8: 
  9: ## API Configuration
 10: 
 11: ### Base Configuration
 12: 
 13: ```typescript
 14: // Base configuration for TCGPlayer API
 15: export const BASE_URL = "https://tcgcsv.com";
 16: export const FFTCG_CATEGORY_ID = "24";
 17: ```
 18: 
 19: ### Authentication
 20: 
 21: ```typescript
 22: const headers = {
 23:   "Accept": "application/json",
 24:   "User-Agent": "FFTCG-Sync-Service/1.0",
 25:   "Authorization": `Bearer ${token}`
 26: };
 27: ```
 28: 
 29: ## Endpoints
 30: 
 31: ### Card Data Endpoints
 32: 
 33: #### Get Card Groups
 34: 
 35: ```http
 36: GET /{categoryId}/groups
 37: ```
 38: 
 39: Response:
 40: 
 41: ```json
 42: {
 43:   "results": [
 44:     {
 45:       "groupId": "23783",
 46:       "name": "FFVII Boss Deck",
 47:       "categoryId": 24,
 48:       "modifiedOn": "2024-01-15T00:00:00"
 49:     }
 50:   ]
 51: }
 52: ```
 53: 
 54: #### Get Group Products
 55: 
 56: ```http
 57: GET /{categoryId}/{groupId}/products
 58: ```
 59: 
 60: Response:
 61: 
 62: ```json
 63: {
 64:   "results": [
 65:     {
 66:       "productId": 477236,
 67:       "name": "Cloud",
 68:       "cleanName": "cloud",
 69:       "imageUrl": "https://tcgplayer-cdn.tcgplayer.com/product/477236_200w.jpg",
 70:       "categoryId": 24,
 71:       "groupId": 23783,
 72:       "url": "https://tcgplayer.com/...",
 73:       "modifiedOn": "2024-01-15T00:00:00",
 74:       "imageCount": 1
 75:     }
 76:   ]
 77: }
 78: ```
 79: 
 80: ### Price Endpoints
 81: 
 82: #### Get Group Prices
 83: 
 84: ```http
 85: GET /{categoryId}/{groupId}/prices
 86: ```
 87: 
 88: Response:
 89: 
 90: ```json
 91: {
 92:   "results": [
 93:     {
 94:       "productId": 477236,
 95:       "lowPrice": 1.99,
 96:       "midPrice": 2.99,
 97:       "highPrice": 4.99,
 98:       "marketPrice": 2.50,
 99:       "directLowPrice": 1.89,
100:       "subTypeName": "Normal"
101:     }
102:   ]
103: }
104: ```
105: 
106: ## Rate Limiting
107: 
108: ### Limits
109: 
110: - 100 requests per minute
111: - 10 concurrent requests maximum
112: - 30-second timeout per request
113: 
114: ### Implementation
115: 
116: ```typescript
117: const rateLimiter = {
118:   tokens: 100,
119:   refillRate: 10,
120:   interval: 1000,
121:   maxConcurrent: 10
122: };
123: ```
124: 
125: ## Error Handling
126: 
127: ### Request Retry Logic
128: 
129: ```typescript
130: const MAX_RETRIES = 3;
131: const BASE_DELAY = 1000; // 1 second
132: 
133: async function makeRequest<T>(
134:   endpoint: string,
135:   options: RequestOptions = {}
136: ): Promise<T> {
137:   const {retryCount = 0} = options;
138:   
139:   try {
140:     // Request implementation
141:   } catch (error) {
142:     if (retryCount < MAX_RETRIES - 1) {
143:       const delay = Math.pow(2, retryCount) * BASE_DELAY;
144:       await logWarning(`Retrying in ${delay}ms...`);
145:       return makeRequest<T>(endpoint, {
146:         ...options,
147:         retryCount: retryCount + 1
148:       });
149:     }
150:     throw error;
151:   }
152: }
153: ```
154: 
155: ## Data Processing
156: 
157: ### Card Data Processing
158: 
159: ```typescript
160: interface CardProduct {
161:   productId: number;
162:   name: string;
163:   cleanName: string;
164:   imageUrl: string;
165:   categoryId: number;
166:   groupId: number;
167:   url: string;
168:   modifiedOn: string;
169:   imageCount: number;
170: }
171: ```
172: 
173: ### Price Data Processing
174: 
175: ```typescript
176: interface CardPrice {
177:   productId: number;
178:   lowPrice: number;
179:   midPrice: number;
180:   highPrice: number;
181:   marketPrice: number | null;
182:   directLowPrice: number | null;
183:   subTypeName: "Normal" | "Foil";
184: }
185: ```
186: 
187: ## Image Handling
188: 
189: ### Image URLs
190: 
191: - Standard resolution: `{productId}_200w.jpg`
192: - High resolution: `{productId}_400w.jpg`
193: 
194: ### Image Processing Pipeline
195: 
196: 1. Download from TCGPlayer CDN
197: 2. Validate format and dimensions
198: 3. Compress and optimize
199: 4. Store in Firebase Storage
200: 5. Update image metadata
201: 
202: ## Best Practices
203: 
204: ### 1. Request Management
205: 
206: - Implement proper rate limiting
207: - Use exponential backoff
208: - Cache responses when possible
209: - Monitor API usage
210: 
211: ### 2. Error Handling
212: 
213: - Validate response data
214: - Handle network errors gracefully
215: - Log all API interactions
216: - Maintain fallback options
217: 
218: ### 3. Data Integrity
219: 
220: - Verify data consistency
221: - Track modification dates
222: - Implement version control
223: - Maintain audit logs
224: 
225: ## Troubleshooting
226: 
227: ### Common Issues
228: 
229: 1. Rate Limit Exceeded
230:    - Implement proper delays
231:    - Monitor request patterns
232:    - Use batch processing
233:    - Cache frequently accessed data
234: 
235: 2. Data Inconsistencies
236:    - Verify API responses
237:    - Check data transformation
238:    - Validate before storage
239:    - Monitor sync status
240: 
241: 3. Image Processing Failures
242:    - Verify URL patterns
243:    - Check image formats
244:    - Monitor storage quotas
245:    - Validate compression results
246: 
247: ## Related Documentation
248: 
249: - [Card Sync Service](/services/card-sync)
250: - [Price Sync Service](/services/price-sync)
251: - [Image Handler](/utils/image-handler)
252: - [Request Utility](/utils/request)
</file>

<file path="docs/introduction.md">
 1: # FFTCG Sync Service Documentation
 2: 
 3: ## Overview
 4: 
 5: FFTCG Sync Service is a specialized Firebase application designed to synchronize
 6:  Final Fantasy Trading Card Game (FFTCG) card data, prices, and images. The
 7:  service provides automated synchronization of card information, price tracking,
 8:  and image optimization through Firebase Functions.
 9: 
10: ## Core Features
11: 
12: ### Card Synchronization
13: 
14: - Automated card data synchronization from TCGPlayer
15: - Batch processing for efficient data handling
16: - Data validation and error handling
17: - Support for dry-run operations
18: 
19: ### Price Tracking
20: 
21: - Real-time price monitoring
22: - Support for both normal and foil card prices
23: - Price history tracking
24: - Configurable sync intervals
25: 
26: ### Image Processing
27: 
28: - Automatic image downloading and optimization
29: - Multiple resolution support (200w and 400w)
30: - Image compression with quality preservation
31: - Efficient caching system
32: - Firebase Storage integration
33: 
34: ### System Architecture
35: 
36: - Firebase Functions for serverless operation
37: - Firestore for data storage
38: - Firebase Storage for image management
39: - LRU caching for performance optimization
40: 
41: ## Technical Stack
42: 
43: - **Runtime**: Node.js 18
44: - **Framework**: Firebase Functions v6
45: - **Database**: Firestore
46: - **Storage**: Firebase Storage
47: - **Image Processing**: Sharp
48: - **HTTP Client**: Axios
49: - **Caching**: LRU Cache
50: - **Language**: TypeScript
51: 
52: ## Key Components
53: 
54: ### Services
55: 
56: - `cardSync`: Manages card data synchronization
57: - `priceSync`: Handles price updates and tracking
58: 
59: ### Utilities
60: 
61: - `ImageHandler`: Manages image processing and storage
62: - `ImageCompressor`: Handles image optimization
63: - `ImageCache`: Provides caching functionality
64: - `Logger`: Manages application logging
65: - `BatchProcessor`: Handles batch operations
66: 
67: ## Getting Started
68: 
69: To get started with the FFTCG Sync Service, see:
70: 
71: - [Installation Guide](./setup/installation)
72: - [Configuration Guide](./setup/configuration)
73: - [API Documentation](./api/)
</file>

<file path="docs/monitoring/index.md">
  1: # System Monitoring Guide
  2: 
  3: ## Overview
  4: 
  5: This guide covers the comprehensive monitoring setup for the FFTCG Sync Service,
  6:  including performance tracking, error detection, and system health monitoring.
  7: 
  8: ## Core Metrics
  9: 
 10: ### Service Health
 11: 
 12: ```typescript
 13: interface HealthMetrics {
 14:   status: "healthy" | "degraded" | "down";
 15:   lastSync: Date;
 16:   syncSuccess: boolean;
 17:   responseTime: number;
 18:   errorRate: number;
 19:   resourceUsage: {
 20:     memory: number;
 21:     cpu: number;
 22:     storage: number;
 23:   };
 24: }
 25: ```
 26: 
 27: ### Performance Metrics
 28: 
 29: ```typescript
 30: interface PerformanceMetrics {
 31:   syncDuration: number;
 32:   processedItems: number;
 33:   batchSize: number;
 34:   cacheHitRate: number;
 35:   imageProcessingTime: number;
 36:   databaseLatency: number;
 37: }
 38: ```
 39: 
 40: ## Monitoring Components
 41: 
 42: ### 1. Function Monitoring
 43: 
 44: #### Runtime Statistics
 45: 
 46: ```typescript
 47: const runtimeStats = {
 48:   memory: process.memoryUsage(),
 49:   uptime: process.uptime(),
 50:   cpuUsage: process.cpuUsage(),
 51:   timestamp: new Date()
 52: };
 53: ```
 54: 
 55: #### Performance Tracking
 56: 
 57: ```typescript
 58: async function trackPerformance<T>(
 59:   operation: () => Promise<T>,
 60:   context: string
 61: ): Promise<T> {
 62:   const start = Date.now();
 63:   try {
 64:     const result = await operation();
 65:     const duration = Date.now() - start;
 66:     
 67:     await logInfo("Performance metrics", {
 68:       operation: context,
 69:       duration,
 70:       timestamp: new Date(),
 71:       memory: process.memoryUsage()
 72:     });
 73:     
 74:     return result;
 75:   } catch (error) {
 76:     await logError(error, `${context}:performance`);
 77:     throw error;
 78:   }
 79: }
 80: ```
 81: 
 82: ### 2. Database Monitoring
 83: 
 84: #### Query Performance
 85: 
 86: ```typescript
 87: interface QueryMetrics {
 88:   collection: string;
 89:   operation: "read" | "write" | "delete";
 90:   duration: number;
 91:   documentCount: number;
 92:   timestamp: Date;
 93: }
 94: 
 95: async function trackQuery(
 96:   queryFn: () => Promise<any>,
 97:   collection: string,
 98:   operation: "read" | "write" | "delete"
 99: ): Promise<any> {
100:   const start = Date.now();
101:   const result = await queryFn();
102:   const duration = Date.now() - start;
103: 
104:   await logInfo("Database operation", {
105:     collection,
106:     operation,
107:     duration,
108:     timestamp: new Date()
109:   });
110: 
111:   return result;
112: }
113: ```
114: 
115: ### 3. Cache Monitoring
116: 
117: ```typescript
118: interface CacheMetrics {
119:   hits: number;
120:   misses: number;
121:   size: number;
122:   evictions: number;
123:   hitRate: number;
124: }
125: 
126: function getCacheMetrics(): CacheMetrics {
127:   return {
128:     hits: imageCache.getStats().hits,
129:     misses: imageCache.getStats().misses,
130:     size: imageCache.size,
131:     evictions: imageCache.evictions,
132:     hitRate: imageCache.getStats().hits / 
133:       (imageCache.getStats().hits + imageCache.getStats().misses)
134:   };
135: }
136: ```
137: 
138: ## Alert Configuration
139: 
140: ### Error Rate Alerts
141: 
142: ```typescript
143: const ERROR_THRESHOLDS = {
144:   WARNING: 0.05,  // 5% error rate
145:   CRITICAL: 0.10  // 10% error rate
146: };
147: 
148: async function checkErrorRate(): Promise<void> {
149:   const recentLogs = await db.collection(COLLECTION.LOGS)
150:     .where("timestamp", ">=", new Date(Date.now() - 3600000))
151:     .get();
152: 
153:   const errorRate = recentLogs.docs.filter(
154:     doc => doc.data().level === "ERROR"
155:   ).length / recentLogs.size;
156: 
157:   if (errorRate >= ERROR_THRESHOLDS.CRITICAL) {
158:     await logError(
159:       new Error(`Critical error rate: ${errorRate.toFixed(2)}`),
160:       "errorRate",
161:       { severity: "CRITICAL" }
162:     );
163:   } else if (errorRate >= ERROR_THRESHOLDS.WARNING) {
164:     await logWarning(
165:       `High error rate: ${errorRate.toFixed(2)}`,
166:       { severity: "WARNING" }
167:     );
168:   }
169: }
170: ```
171: 
172: ### Performance Alerts
173: 
174: ```typescript
175: const PERFORMANCE_THRESHOLDS = {
176:   SYNC_DURATION: 30 * 60 * 1000,  // 30 minutes
177:   IMAGE_PROCESSING: 30 * 1000,    // 30 seconds
178:   DATABASE_LATENCY: 1000,         // 1 second
179:   MEMORY_USAGE: 900 * 1024 * 1024 // 900MB
180: };
181: 
182: async function checkPerformance(metrics: PerformanceMetrics): Promise<void> {
183:   if (metrics.syncDuration > PERFORMANCE_THRESHOLDS.SYNC_DURATION) {
184:     await logWarning("Sync duration exceeded threshold", {
185:       duration: metrics.syncDuration,
186:       threshold: PERFORMANCE_THRESHOLDS.SYNC_DURATION
187:     });
188:   }
189: 
190:   if (process.memoryUsage().heapUsed > PERFORMANCE_THRESHOLDS.MEMORY_USAGE) {
191:     await logWarning("High memory usage", {
192:       usage: process.memoryUsage().heapUsed,
193:       threshold: PERFORMANCE_THRESHOLDS.MEMORY_USAGE
194:     });
195:   }
196: }
197: ```
198: 
199: ## Logging System
200: 
201: ### Structured Logging
202: 
203: ```typescript
204: interface DetailedLog {
205:   timestamp: Date;
206:   level: "INFO" | "WARNING" | "ERROR";
207:   message: string;
208:   context: string;
209:   metadata?: Record<string, unknown>;
210:   metrics?: PerformanceMetrics;
211:   error?: Error;
212: }
213: 
214: async function logWithMetrics(
215:   log: DetailedLog
216: ): Promise<void> {
217:   const enrichedLog = {
218:     ...log,
219:     system: {
220:       memory: process.memoryUsage(),
221:       uptime: process.uptime()
222:     }
223:   };
224: 
225:   await db.collection(COLLECTION.LOGS).add(enrichedLog);
226: }
227: ```
228: 
229: ### Log Analysis
230: 
231: ```typescript
232: interface LogAnalysis {
233:   errorCount: number;
234:   warningCount: number;
235:   averageSyncDuration: number;
236:   failurePatterns: Record<string, number>;
237:   topErrors: Array<{
238:     message: string;
239:     count: number;
240:   }>;
241: }
242: 
243: async function analyzeLogs(
244:   startTime: Date,
245:   endTime: Date
246: ): Promise<LogAnalysis> {
247:   const logs = await db.collection(COLLECTION.LOGS)
248:     .where("timestamp", ">=", startTime)
249:     .where("timestamp", "<=", endTime)
250:     .get();
251: 
252:   // Analysis implementation
253: }
254: ```
255: 
256: ## Resource Monitoring
257: 
258: ### Storage Usage
259: 
260: ```typescript
261: async function checkStorageUsage(): Promise<void> {
262:   const [files] = await storage
263:     .bucket(STORAGE.BUCKETS.CARD_IMAGES)
264:     .getFiles();
265: 
266:   const totalSize = files.reduce(
267:     (sum, file) => sum + parseInt(file.metadata.size || "0"),
268:     0
269:   );
270: 
271:   await logInfo("Storage metrics", {
272:     totalFiles: files.length,
273:     totalSize,
274:     timestamp: new Date()
275:   });
276: }
277: ```
278: 
279: ### Memory Usage
280: 
281: ```typescript
282: function trackMemoryUsage(): void {
283:   const memoryUsage = process.memoryUsage();
284:   
285:   if (memoryUsage.heapUsed > PERFORMANCE_THRESHOLDS.MEMORY_USAGE) {
286:     global.gc?.();  // Trigger garbage collection if available
287:   }
288: 
289:   logInfo("Memory usage", {
290:     heap: memoryUsage.heapUsed,
291:     external: memoryUsage.external,
292:     timestamp: new Date()
293:   });
294: }
295: ```
296: 
297: ## Health Checks
298: 
299: ### Automated Health Check
300: 
301: ```typescript
302: async function performHealthCheck(): Promise<HealthMetrics> {
303:   const metrics: HealthMetrics = {
304:     status: "healthy",
305:     lastSync: new Date(),
306:     syncSuccess: true,
307:     responseTime: 0,
308:     errorRate: 0,
309:     resourceUsage: {
310:       memory: process.memoryUsage().heapUsed,
311:       cpu: process.cpuUsage().user,
312:       storage: 0
313:     }
314:   };
315: 
316:   // Perform checks and update metrics
317:   return metrics;
318: }
319: ```
320: 
321: ## Dashboard Integration
322: 
323: ### Metrics Export
324: 
325: ```typescript
326: interface DashboardMetrics {
327:   timestamp: Date;
328:   syncStats: {
329:     success: number;
330:     failure: number;
331:     duration: number;
332:   };
333:   resourceUsage: {
334:     memory: number;
335:     storage: number;
336:   };
337:   performance: {
338:     responseTime: number;
339:     errorRate: number;
340:   };
341: }
342: 
343: async function exportMetrics(): Promise<void> {
344:   const metrics: DashboardMetrics = {
345:     timestamp: new Date(),
346:     // Collect metrics
347:   };
348: 
349:   await db.collection("dashboardMetrics").add(metrics);
350: }
351: ```
352: 
353: ## Best Practices
354: 
355: ### Monitoring
356: 
357: - Regular health checks
358: - Automated alerting
359: - Performance tracking
360: - Resource monitoring
361: 
362: ### Logging
363: 
364: - Structured log format
365: - Appropriate log levels
366: - Regular log analysis
367: - Log rotation
368: 
369: ### Performance
370: 
371: - Track critical metrics
372: - Monitor resource usage
373: - Set appropriate thresholds
374: - Implement auto-scaling
375: 
376: ## Related Documentation
377: 
378: - [Error Handling](/utils/error-handling)
379: - [Logging System](/utils/logging)
380: - [Deployment Guide](/deployment/)
381: - [Troubleshooting Guide](/troubleshooting/common-issues)
</file>

<file path="docs/package.json">
  1: {
  2:   "name": "fftcg-sync-docs",
  3:   "version": "1.0.0",
  4:   "description": "Documentation for FFTCG Sync Service",
  5:   "type": "module",
  6:   "scripts": {
  7:     "docs:dev": "vitepress dev",
  8:     "docs:build": "cross-env VITEPRESS_BUILD=true vitepress build",
  9:     "docs:preview": "vitepress preview"
 10:   },
 11:   "keywords": [],
 12:   "author": "",
 13:   "license": "ISC",
 14:   "devDependencies": {
 15:     "@types/lodash": "^4.17.13",
 16:     "@types/node": "^22.9.1",
 17:     "@vueuse/core": "^10.7.0",
 18:     "cross-env": "^7.0.3",
 19:     "firebase": "^10.14.1",
 20:     "typescript": "^5.6.3",
 21:     "vitepress": "^1.5.0",
 22:     "vue": "^3.5.13"
 23:   },
 24:   "main": "index.js",
 25:   "dependencies": {
 26:     "algoliasearch": "^5.15.0",
 27:     "ansi-regex": "^5.0.1",
 28:     "ansi-styles": "^4.3.0",
 29:     "birpc": "^0.2.19",
 30:     "ccount": "^2.0.1",
 31:     "character-entities-html4": "^2.1.0",
 32:     "character-entities-legacy": "^3.0.0",
 33:     "cliui": "^8.0.1",
 34:     "color-convert": "^2.0.1",
 35:     "color-name": "^1.1.4",
 36:     "comma-separated-tokens": "^2.0.3",
 37:     "copy-anything": "^3.0.5",
 38:     "csstype": "^3.1.3",
 39:     "dequal": "^2.0.3",
 40:     "devlop": "^1.1.0",
 41:     "emoji-regex": "^8.0.0",
 42:     "emoji-regex-xs": "^1.0.0",
 43:     "entities": "^4.5.0",
 44:     "esbuild": "^0.21.5",
 45:     "escalade": "^3.2.0",
 46:     "estree-walker": "^2.0.2",
 47:     "faye-websocket": "^0.11.4",
 48:     "focus-trap": "^7.6.2",
 49:     "get-caller-file": "^2.0.5",
 50:     "hast-util-to-html": "^9.0.3",
 51:     "hast-util-whitespace": "^3.0.0",
 52:     "hookable": "^5.5.3",
 53:     "html-void-elements": "^3.0.0",
 54:     "http-parser-js": "^0.5.8",
 55:     "idb": "^7.1.1",
 56:     "is-fullwidth-code-point": "^3.0.0",
 57:     "is-what": "^4.1.16",
 58:     "lodash": "^4.17.21",
 59:     "lodash.camelcase": "^4.3.0",
 60:     "long": "^5.2.3",
 61:     "magic-string": "^0.30.13",
 62:     "mark.js": "^8.11.1",
 63:     "mdast-util-to-hast": "^13.2.0",
 64:     "micromark-util-character": "^2.1.1",
 65:     "micromark-util-encode": "^2.0.1",
 66:     "micromark-util-sanitize-uri": "^2.0.1",
 67:     "micromark-util-symbol": "^2.0.1",
 68:     "micromark-util-types": "^2.0.1",
 69:     "minisearch": "^7.1.1",
 70:     "mitt": "^3.0.1",
 71:     "nanoid": "^3.3.7",
 72:     "oniguruma-to-es": "^0.4.1",
 73:     "perfect-debounce": "^1.0.0",
 74:     "picocolors": "^1.1.1",
 75:     "postcss": "^8.4.49",
 76:     "preact": "^10.24.3",
 77:     "property-information": "^6.5.0",
 78:     "protobufjs": "^7.4.0",
 79:     "regex": "^5.0.2",
 80:     "regex-recursion": "^4.2.1",
 81:     "regex-utilities": "^2.3.0",
 82:     "require-directory": "^2.1.1",
 83:     "rfdc": "^1.4.1",
 84:     "rollup": "^4.27.3",
 85:     "safe-buffer": "^5.2.1",
 86:     "search-insights": "^2.17.3",
 87:     "shiki": "^1.23.1",
 88:     "source-map-js": "^1.2.1",
 89:     "space-separated-tokens": "^2.0.2",
 90:     "speakingurl": "^14.0.1",
 91:     "string-width": "^4.2.3",
 92:     "stringify-entities": "^4.0.4",
 93:     "strip-ansi": "^6.0.1",
 94:     "superjson": "^2.2.1",
 95:     "tabbable": "^6.2.0",
 96:     "trim-lines": "^3.0.1",
 97:     "tslib": "^2.8.1",
 98:     "undici": "^6.19.7",
 99:     "undici-types": "^6.19.8",
100:     "unist-util-is": "^6.0.0",
101:     "unist-util-position": "^5.0.0",
102:     "unist-util-stringify-position": "^4.0.0",
103:     "unist-util-visit": "^5.0.0",
104:     "unist-util-visit-parents": "^6.0.1",
105:     "vfile": "^6.0.3",
106:     "vfile-message": "^4.0.2",
107:     "vite": "^5.4.11",
108:     "websocket-driver": "^0.7.4",
109:     "websocket-extensions": "^0.1.4",
110:     "wrap-ansi": "^7.0.0",
111:     "y18n": "^5.0.8",
112:     "yargs": "^17.7.2",
113:     "yargs-parser": "^21.1.1",
114:     "zwitch": "^2.0.4"
115:   }
116: }
</file>

<file path="docs/performance.md">
  1: # Performance Guide
  2: 
  3: ## Optimization Overview
  4: 
  5: This guide covers performance optimization strategies implemented in the FFTCG Sync Service, including caching, batch processing, memory management, and monitoring.
  6: 
  7: ## Resource Management
  8: 
  9: ### Memory Allocation
 10: 
 11: ```typescript
 12: // Default runtime options
 13: const runtimeOpts = {
 14:   timeoutSeconds: 540,
 15:   memory: "1GiB"
 16: } as const;
 17: ```
 18: 
 19: Memory optimization techniques:
 20: 
 21: - Batch processing to control memory usage
 22: - Automatic garbage collection
 23: - Resource cleanup after operations
 24: - Stream processing for large datasets
 25: 
 26: ### Resource Cleanup
 27: 
 28: ```typescript
 29: async function cleanupResources(): Promise<void> {
 30:   // Clear image cache
 31:   await imageCache.clear();
 32:  
 33:   // Force garbage collection if available
 34:   global.gc && global.gc();
 35:  
 36:   // Clear other caches
 37:   cardCache.clear();
 38: }
 39: ```
 40: 
 41: ## Caching Strategy
 42: 
 43: ### Multi-Level Caching
 44: 
 45: ```typescript
 46: // L1 Cache (Memory)
 47: private l1Cache = new Map<string, T>();
 48: 
 49: // L2 Cache (LRU)
 50: private l2Cache: LRUCache<string, T> = new LRUCache<string, T>({
 51:   max: options.maxSize,
 52:   ttl: options.ttl
 53: });
 54: ```
 55: 
 56: Cache hierarchy:
 57: 
 58: 1. In-memory cache for frequent access
 59: 2. LRU cache for larger datasets
 60: 3. Persistent storage for backups
 61: 
 62: ### Cache Configuration
 63: 
 64: ```typescript
 65: const cacheOptions = {
 66:   // Card cache settings
 67:   cardCache: {
 68:     max: 500,
 69:     ttl: 1000 * 60 * 60 // 1 hour
 70:   },
 71:  
 72:   // Image cache settings
 73:   imageCache: {
 74:     metadata: {
 75:       max: 1000,
 76:       ttl: 1000 * 60 * 60 // 1 hour
 77:     },
 78:     buffer: {
 79:       max: 100,
 80:       ttl: 1000 * 60 * 5, // 5 minutes
 81:       maxSize: 50 * 1024 * 1024 // 50MB
 82:     }
 83:   }
 84: };
 85: ```
 86: 
 87: ## Batch Processing
 88: 
 89: ### Adaptive Batch Processing
 90: 
 91: ```typescript
 92: class AdaptiveBatchProcessor {
 93:   private optimalBatchSize: number = 100;
 94:   private processingTimes: number[] = [];
 95: 
 96:   async processBatch<T>(
 97:     items: T[],
 98:     processor: (batch: T[]) => Promise<void>
 99:   ): Promise<void> {
100:     for (let i = 0; i < items.length; i += this.optimalBatchSize) {
101:       const start = Date.now();
102:       const batch = items.slice(i, i + this.optimalBatchSize);
103:      
104:       await processor(batch);
105:      
106:       this.adjustBatchSize(Date.now() - start);
107:     }
108:   }
109: 
110:   private adjustBatchSize(lastProcessingTime: number): void {
111:     // Dynamically adjust batch size based on processing time
112:     if (lastProcessingTime > 1000) {
113:       this.optimalBatchSize = Math.max(10, this.optimalBatchSize * 0.8);
114:     } else if (lastProcessingTime < 500) {
115:       this.optimalBatchSize = Math.min(1000, this.optimalBatchSize * 1.2);
116:     }
117:   }
118: }
119: ```
120: 
121: ### Batch Size Optimization
122: 
123: ```typescript
124: const batchOptions = {
125:   batchSize: 100,
126:   delayBetweenBatches: 1000,
127:   onBatchComplete: async (stats) => {
128:     console.log(`Processed: ${stats.processed}/${stats.total}`);
129:   }
130: };
131: ```
132: 
133: ## Image Processing Optimization
134: 
135: ### Compression Settings
136: 
137: ```typescript
138: const compressionOptions = {
139:   quality: {
140:     HIGH_RES: 90,
141:     LOW_RES: 85
142:   },
143:   dimensions: {
144:     HIGH_RES: 400,
145:     LOW_RES: 200
146:   }
147: };
148: ```
149: 
150: ### Progressive Loading
151: 
152: ```typescript
153: const imageProcessingOptions = {
154:   progressive: true,
155:   mozjpeg: true,
156:   optimizationLevel: 3
157: };
158: ```
159: 
160: ## Database Optimization
161: 
162: ### Batch Operations
163: 
164: ```typescript
165: async function batchWrite(updates: any[]): Promise<void> {
166:   const batch = db.batch();
167:   updates.forEach(update => {
168:     const ref = db.collection('cards').doc(update.id);
169:     batch.update(ref, update.data);
170:   });
171:   await batch.commit();
172: }
173: ```
174: 
175: ### Index Optimization
176: 
177: ```json
178: {
179:   "indexes": [
180:     {
181:       "collectionGroup": "cards",
182:       "queryScope": "COLLECTION",
183:       "fields": [
184:         { "fieldPath": "groupId", "order": "ASCENDING" },
185:         { "fieldPath": "lastUpdated", "order": "DESCENDING" }
186:       ]
187:     }
188:   ]
189: }
190: ```
191: 
192: ## Rate Limiting
193: 
194: ### Token Bucket Implementation
195: 
196: ```typescript
197: const rateLimiter = {
198:   tokens: 100,
199:   refillRate: 10,
200:   interval: 1000,
201: 
202:   async acquire(): Promise<boolean> {
203:     if (this.tokens > 0) {
204:       this.tokens--;
205:       return true;
206:     }
207:     return false;
208:   }
209: };
210: ```
211: 
212: ### Request Throttling
213: 
214: ```typescript
215: async function makeThrottledRequest<T>(
216:   endpoint: string,
217:   options: RequestOptions = {}
218: ): Promise<T> {
219:   if (!await rateLimiter.acquire()) {
220:     throw new Error("Rate limit exceeded");
221:   }
222:   return makeRequest<T>(endpoint, options);
223: }
224: ```
225: 
226: ## Performance Monitoring
227: 
228: ### Progress Tracking
229: 
230: ```typescript
231: export class EnhancedProgressTracker {
232:   private calculateStats(): ProgressStats {
233:     const now = Date.now();
234:     const elapsed = (now - this.startTime) / 1000;
235:     const percent = (this.current / this.total) * 100;
236:     const rate = this.current / elapsed;
237:    
238:     return {
239:       current: this.current,
240:       total: this.total,
241:       percent,
242:       elapsed,
243:       rate,
244:       remaining: this.total - this.current,
245:       eta: (this.total - this.current) / rate
246:     };
247:   }
248: }
249: ```
250: 
251: ### Performance Metrics
252: 
253: ```typescript
254: interface PerformanceMetrics {
255:   timestamp: Date;
256:   operation: string;
257:   duration: number;
258:   memory: {
259:     heapUsed: number;
260:     heapTotal: number;
261:   };
262:   success: boolean;
263: }
264: 
265: async function trackPerformance(
266:   operation: string,
267:   task: () => Promise<void>
268: ): Promise<void> {
269:   const start = Date.now();
270:   const startMemory = process.memoryUsage();
271:  
272:   try {
273:     await task();
274:     const endMemory = process.memoryUsage();
275:    
276:     await logInfo("Performance metrics", {
277:       operation,
278:       duration: Date.now() - start,
279:       memoryDelta: {
280:         heapUsed: endMemory.heapUsed - startMemory.heapUsed,
281:         heapTotal: endMemory.heapTotal - startMemory.heapTotal
282:       }
283:     });
284:   } catch (error) {
285:     await logError(error, "performanceTracking");
286:     throw error;
287:   }
288: }
289: ```
290: 
291: ## Best Practices
292: 
293: ### Memory Management
294: 
295: 1. Use streams for large file operations
296: 2. Implement cleanup routines
297: 3. Monitor memory usage
298: 4. Set appropriate cache limits
299: 5. Use batch processing
300: 
301: ### Network Optimization
302: 
303: 1. Implement request caching
304: 2. Use compression
305: 3. Batch API requests
306: 4. Handle rate limits
307: 5. Implement retry strategies
308: 
309: ### Database Efficiency
310: 
311: 1. Use batch operations
312: 2. Optimize indexes
313: 3. Implement caching
314: 4. Monitor query performance
315: 5. Use appropriate batch sizes
316: 
317: ### Image Processing
318: 
319: 1. Use progressive loading
320: 2. Implement size limits
321: 3. Optimize compression
322: 4. Cache processed images
323: 5. Use appropriate quality settings
324: 
325: ## Monitoring and Alerts
326: 
327: ### Key Metrics
328: 
329: ```typescript
330: interface SystemMetrics {
331:   syncDuration: number;
332:   memoryUsage: number;
333:   processedItems: number;
334:   errorRate: number;
335:   cacheHitRate: number;
336: }
337: 
338: async function monitorSystem(): Promise<SystemMetrics> {
339:   return {
340:     syncDuration: calculateSyncDuration(),
341:     memoryUsage: process.memoryUsage().heapUsed,
342:     processedItems: getProcessedCount(),
343:     errorRate: calculateErrorRate(),
344:     cacheHitRate: calculateCacheHitRate()
345:   };
346: }
347: ```
348: 
349: ### Alert Thresholds
350: 
351: ```typescript
352: const alertThresholds = {
353:   syncDuration: 1000 * 60 * 30, // 30 minutes
354:   memoryUsage: 900 * 1024 * 1024, // 900MB
355:   errorRate: 0.05, // 5%
356:   cacheHitRate: 0.7 // 70%
357: };
358: ```
</file>

<file path="docs/reference/types.md">
  1: # Type Reference Guide
  2: 
  3: ## Core Types
  4: 
  5: ### Card Types
  6: 
  7: #### CardProduct
  8: 
  9: ```typescript
 10: interface CardProduct {
 11:   productId: number;
 12:   name: string;
 13:   cleanName: string;
 14:   imageUrl: string;
 15:   storageImageUrl?: string;
 16:   categoryId: number;
 17:   groupId: number;
 18:   url: string;
 19:   modifiedOn: string;
 20:   imageCount: number;
 21:   imageMetadata?: ImageMetadata;
 22:   extendedData: Array<{
 23:     name: string;
 24:     displayName: string;
 25:     value: string;
 26:   }>;
 27: }
 28: ```
 29: 
 30: #### CardPrice
 31: 
 32: ```typescript
 33: interface CardPrice {
 34:   productId: number;
 35:   lowPrice: number;
 36:   midPrice: number;
 37:   highPrice: number;
 38:   marketPrice: number | null;
 39:   directLowPrice: number | null;
 40:   subTypeName: "Normal" | "Foil";
 41: }
 42: ```
 43: 
 44: ### Synchronization Types
 45: 
 46: #### SyncOptions
 47: 
 48: ```typescript
 49: interface SyncOptions {
 50:   dryRun?: boolean;
 51:   limit?: number;
 52:   groupId?: string;
 53:   productId?: number;
 54:   showAll?: boolean;
 55:   skipImages?: boolean;
 56: }
 57: ```
 58: 
 59: #### SyncMetadata
 60: 
 61: ```typescript
 62: interface SyncMetadata {
 63:   lastSync: Date;
 64:   status: "in_progress" | "success" | "failed" | "completed_with_errors";
 65:   cardCount: number;
 66:   type: "manual" | "scheduled";
 67:   groupsProcessed: number;
 68:   groupsUpdated: number;
 69:   errors: string[];
 70:   duration?: number;
 71:   imagesProcessed?: number;
 72:   imagesUpdated?: number;
 73: }
 74: ```
 75: 
 76: ### Image Processing Types
 77: 
 78: #### ImageMetadata
 79: 
 80: ```typescript
 81: interface ImageMetadata {
 82:   contentType: string;
 83:   size: number;
 84:   updated: Date;
 85:   hash: string;
 86:   originalUrl: string;
 87:   highResUrl: string;
 88:   groupId?: string;
 89:   productId?: number;
 90:   lastUpdated?: Date;
 91:   originalSize?: number;
 92:   highResSize?: number;
 93: }
 94: ```
 95: 
 96: #### ImageProcessingResult
 97: 
 98: ```typescript
 99: interface ImageProcessingResult {
100:   url: string;
101:   metadata: ImageMetadata;
102:   updated: boolean;
103: }
104: ```
105: 
106: #### ImageValidationError
107: 
108: ```typescript
109: interface ImageValidationError {
110:   code: "FILE_TOO_LARGE" | "INVALID_FORMAT" | "VALIDATION_ERROR";
111:   message: string;
112: }
113: ```
114: 
115: ### Error Handling Types
116: 
117: #### GenericError
118: 
119: ```typescript
120: interface GenericError extends Error {
121:   code?: string;
122:   message: string;
123:   stack?: string;
124: }
125: ```
126: 
127: #### ErrorReport
128: 
129: ```typescript
130: interface ErrorReport {
131:   timestamp: Date;
132:   context: string;
133:   error: string;
134:   stackTrace?: string;
135:   metadata?: Record<string, unknown>;
136:   severity: "ERROR" | "WARNING" | "CRITICAL";
137: }
138: ```
139: 
140: ### Cache Types
141: 
142: #### CacheOptions
143: 
144: ```typescript
145: interface CacheOptions {
146:   max: number;
147:   ttl: number;
148: }
149: ```
150: 
151: #### CacheEntry
152: 
153: ```typescript
154: interface CacheEntry<T> {
155:   data: T;
156:   timestamp: number;
157:   expires: number;
158: }
159: ```
160: 
161: ### Batch Processing Types
162: 
163: #### BatchProcessingStats
164: 
165: ```typescript
166: interface BatchProcessingStats {
167:   total: number;
168:   processed: number;
169:   successful: number;
170:   failed: number;
171:   skipped: number;
172: }
173: ```
174: 
175: #### BatchOptions
176: 
177: ```typescript
178: interface BatchOptions {
179:   batchSize?: number;
180:   delayBetweenBatches?: number;
181:   onBatchComplete?: (stats: BatchProcessingStats) => Promise<void>;
182:   skipImages?: boolean;
183:   retryFailedImages?: boolean;
184: }
185: ```
186: 
187: ## Type Usage Examples
188: 
189: ### Using SyncOptions
190: 
191: ```typescript
192: // Test sync with specific group
193: const options: SyncOptions = {
194:   dryRun: true,
195:   limit: 5,
196:   groupId: "23783"
197: };
198: 
199: await syncCards(options);
200: ```
201: 
202: ### Error Handling Example
203: 
204: ```typescript
205: try {
206:   // Operation code
207: } catch (error) {
208:   const errorReport: ErrorReport = {
209:     timestamp: new Date(),
210:     context: "cardSync",
211:     error: error.message,
212:     stackTrace: error.stack,
213:     severity: "ERROR"
214:   };
215:   await logError(errorReport);
216: }
217: ```
218: 
219: ### Batch Processing Example
220: 
221: ```typescript
222: const batchOptions: BatchOptions = {
223:   batchSize: 100,
224:   delayBetweenBatches: 1000,
225:   onBatchComplete: async (stats) => {
226:     console.log(`Processed: ${stats.processed}/${stats.total}`);
227:   }
228: };
229: 
230: await processBatch(items, processor, batchOptions);
231: ```
232: 
233: ## Type Guards and Validation
234: 
235: ### Card Type Guard
236: 
237: ```typescript
238: function isCardProduct(obj: unknown): obj is CardProduct {
239:   return (
240:     typeof obj === "object" &&
241:     obj !== null &&
242:     "productId" in obj &&
243:     "name" in obj &&
244:     "groupId" in obj
245:   );
246: }
247: ```
248: 
249: ### Price Type Guard
250: 
251: ```typescript
252: function isCardPrice(obj: unknown): obj is CardPrice {
253:   return (
254:     typeof obj === "object" &&
255:     obj !== null &&
256:     "productId" in obj &&
257:     "midPrice" in obj &&
258:     "subTypeName" in obj
259:   );
260: }
261: ```
262: 
263: ## Best Practices
264: 
265: ### Type Safety
266: 
267: - Use strict TypeScript configuration
268: - Implement proper type guards
269: - Avoid type assertions when possible
270: - Maintain comprehensive interfaces
271: 
272: ### Error Handling
273: 
274: - Use specific error types
275: - Implement proper error inheritance
276: - Include detailed error metadata
277: - Maintain error tracking
278: 
279: ### Performance
280: 
281: - Use efficient type definitions
282: - Implement proper generics
283: - Avoid unnecessary type complexity
284: - Maintain clear type hierarchies
285: 
286: ## Related Documentation
287: 
288: - [Error Handling](/utils/error-handling)
289: - [Cache System](/utils/cache)
290: - [Batch Processing](/utils/batch)
291: - [Image Processing](/utils/image-handler)
</file>

<file path="docs/security.md">
  1: # Security Guidelines
  2: 
  3: ## Overview
  4: 
  5: This guide outlines security best practices and implementations for the FFTCG Sync Service, covering authentication, data validation, rate limiting, and other security considerations.
  6: 
  7: ## Authentication
  8: 
  9: ### Firebase Authentication
 10: 
 11: ```typescript
 12: // Verify Firebase authentication token
 13: async function verifyAuth(req: Request): Promise<void> {
 14:   const token = req.headers.authorization?.split("Bearer ")[1];
 15:   if (!token) {
 16:     throw new Error("No authentication token provided");
 17:   }
 18: 
 19:   try {
 20:     await admin.auth().verifyIdToken(token);
 21:   } catch (error) {
 22:     throw new Error("Invalid authentication token");
 23:   }
 24: }
 25: ```
 26: 
 27: ### Service Account Security
 28: 
 29: ```typescript
 30: // Service account initialization
 31: async function initializeFirebase(): Promise<FirebaseFirestore.Firestore> {
 32:   try {
 33:     const serviceAccountPath = path.resolve(__dirname, "../../../service_account_key.json");
 34:     const serviceAccount = JSON.parse(await fs.readFile(serviceAccountPath, "utf8"));
 35: 
 36:     if (!admin.apps.length) {
 37:       admin.initializeApp({
 38:         credential: admin.credential.cert(serviceAccount)
 39:       });
 40:     }
 41: 
 42:     return admin.firestore();
 43:   } catch (error) {
 44:     throw new Error("Failed to initialize Firebase: " + error);
 45:   }
 46: }
 47: ```
 48: 
 49: ## Input Validation
 50: 
 51: ### Request Validation
 52: 
 53: ```typescript
 54: // Validate sync options
 55: function validateSyncOptions(options: unknown): asserts options is SyncOptions {
 56:   if (!options || typeof options !== "object") {
 57:     throw new Error("Invalid options object");
 58:   }
 59: 
 60:   const opts = options as Record<string, unknown>;
 61:  
 62:   if (opts.limit && typeof opts.limit !== "number") {
 63:     throw new Error("Limit must be a number");
 64:   }
 65: 
 66:   if (opts.groupId && typeof opts.groupId !== "string") {
 67:     throw new Error("GroupId must be a string");
 68:   }
 69: }
 70: ```
 71: 
 72: ### Image Validation
 73: 
 74: ```typescript
 75: class ImageValidator {
 76:   private static readonly MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB
 77: 
 78:   static async validateImage(buffer: Buffer): Promise<ImageValidationError | null> {
 79:     // Check file size
 80:     if (buffer.length > this.MAX_FILE_SIZE) {
 81:       return {
 82:         code: "FILE_TOO_LARGE",
 83:         message: `Image exceeds maximum size of ${this.MAX_FILE_SIZE / 1024 / 1024}MB`
 84:       };
 85:     }
 86: 
 87:     // Verify file signature
 88:     if (!this.isJpeg(buffer)) {
 89:       return {
 90:         code: "INVALID_FORMAT",
 91:         message: "Image must be in JPEG format"
 92:       };
 93:     }
 94: 
 95:     return null;
 96:   }
 97: }
 98: ```
 99: 
100: ## Rate Limiting
101: 
102: ### API Rate Limiting
103: 
104: ```typescript
105: const rateLimiter = {
106:   tokens: 100,
107:   refillRate: 10,
108:   interval: 1000,
109: 
110:   async acquire(): Promise<boolean> {
111:     if (this.tokens > 0) {
112:       this.tokens--;
113:       return true;
114:     }
115:     return false;
116:   }
117: };
118: ```
119: 
120: ### Function Concurrency Control
121: 
122: ```typescript
123: // Configure function instance limits
124: exports.syncCards = onRequest({
125:   timeoutSeconds: runtimeOpts.timeoutSeconds,
126:   memory: runtimeOpts.memory,
127:   maxInstances: 1
128: }, async (req: Request, res: Response) => {
129:   // Function implementation
130: });
131: ```
132: 
133: ## Data Protection
134: 
135: ### Data Encryption
136: 
137: ```typescript
138: // Hash sensitive data
139: function getDataHash(data: any): string {
140:   return crypto.createHash("md5")
141:     .update(JSON.stringify(data, Object.keys(data).sort()))
142:     .digest("hex");
143: }
144: ```
145: 
146: ### Secure Storage Access
147: 
148: ```typescript
149: // Secure URL generation
150: async function getSecureImageUrl(path: string): Promise<string> {
151:   const [url] = await storage
152:     .bucket(STORAGE.BUCKETS.CARD_IMAGES)
153:     .file(path)
154:     .getSignedUrl({
155:       action: "read",
156:       expires: "03-01-2500"
157:     });
158:   return url;
159: }
160: ```
161: 
162: ## Error Handling
163: 
164: ### Secure Error Logging
165: 
166: ```typescript
167: export async function logDetailedError(
168:   error: Error,
169:   context: string,
170:   metadata?: Record<string, unknown>,
171:   severity: "ERROR" | "WARNING" | "CRITICAL" = "ERROR"
172: ): Promise<void> {
173:   const report: ErrorReport = {
174:     timestamp: new Date(),
175:     context,
176:     error: error.message,
177:     stackTrace: error.stack,
178:     metadata,
179:     severity
180:   };
181: 
182:   // Sanitize sensitive information before logging
183:   const sanitizedReport = sanitizeErrorReport(report);
184:   await db.collection(COLLECTION.LOGS).add(sanitizedReport);
185: }
186: ```
187: 
188: ### Error Response Sanitization
189: 
190: ```typescript
191: function sanitizeErrorMessage(error: Error): string {
192:   // Remove sensitive information from error messages
193:   return error.message.replace(/([a-zA-Z0-9._-]+@[a-zA-Z0-9._-]+\.[a-zA-Z0-9_-]+)/gi, '[EMAIL]')
194:     .replace(/\b\d{4}\b/g, '[ID]');
195: }
196: ```
197: 
198: ## Network Security
199: 
200: ### Request Configuration
201: 
202: ```typescript
203: const secureRequestConfig = {
204:   timeout: 30000,
205:   headers: {
206:     "Accept": "application/json",
207:     "User-Agent": "FFTCG-Sync-Service/1.0"
208:   },
209:   validateStatus: (status: number) => status < 400
210: };
211: ```
212: 
213: ### HTTPS Enforcement
214: 
215: ```typescript
216: // Ensure HTTPS usage
217: const BASE_URL = "https://tcgcsv.com";
218: const SECURE_STORAGE_URL = "https://storage.googleapis.com";
219: ```
220: 
221: ## Firestore Security Rules
222: 
223: ```typescript
224: // firestore.rules
225: rules_version = '2';
226: service cloud.firestore {
227:   match /databases/{database}/documents {
228:     // Card collection rules
229:     match /cards/{cardId} {
230:       allow read: if true;
231:       allow write: if request.auth != null 
232:         && request.auth.token.admin == true;
233:     }
234: 
235:     // Price collection rules
236:     match /prices/{priceId} {
237:       allow read: if true;
238:       allow write: if request.auth != null 
239:         && request.auth.token.admin == true;
240:     }
241: 
242:     // Sync metadata rules
243:     match /syncMetadata/{docId} {
244:       allow read: if request.auth != null;
245:       allow write: if request.auth != null 
246:         && request.auth.token.admin == true;
247:     }
248:   }
249: }
250: ```
251: 
252: ## Storage Security Rules
253: 
254: ```typescript
255: // storage.rules
256: rules_version = '2';
257: service firebase.storage {
258:   match /b/{bucket}/o {
259:     match /card-images/{groupId}/{imageId} {
260:       allow read: if true;
261:       allow write: if request.auth != null 
262:         && request.auth.token.admin == true
263:         && request.resource.size < 5 * 1024 * 1024
264:         && request.resource.contentType.matches('image/jpeg');
265:     }
266:   }
267: }
268: ```
269: 
270: ## Best Practices
271: 
272: ### API Security
273: 
274: 1. Use HTTPS for all requests
275: 2. Implement proper authentication
276: 3. Validate all inputs
277: 4. Rate limit requests
278: 5. Monitor for suspicious activity
279: 
280: ### Data Security
281: 
282: 1. Minimize sensitive data storage
283: 2. Encrypt sensitive information
284: 3. Implement proper access controls
285: 4. Regular security audits
286: 5. Secure backup procedures
287: 
288: ### Error Management
289: 
290: 1. Sanitize error messages
291: 2. Avoid exposing internal details
292: 3. Log security events
293: 4. Monitor error patterns
294: 5. Implement proper error recovery
295: 
296: ### Function Security
297: 
298: 1. Use minimal permissions
299: 2. Implement request validation
300: 3. Control function concurrency
301: 4. Monitor function execution
302: 5. Regular security updates
303: 
304: ## Security Monitoring
305: 
306: ### Logging Security Events
307: 
308: ```typescript
309: interface SecurityEvent {
310:   timestamp: Date;
311:   eventType: "AUTH" | "ACCESS" | "ERROR" | "MODIFICATION";
312:   severity: "LOW" | "MEDIUM" | "HIGH" | "CRITICAL";
313:   details: Record<string, unknown>;
314: }
315: 
316: async function logSecurityEvent(event: SecurityEvent): Promise<void> {
317:   await db.collection("securityLogs").add({
318:     ...event,
319:     timestamp: new Date()
320:   });
321: }
322: ```
323: 
324: ### Audit Trail
325: 
326: ```typescript
327: interface AuditLog {
328:   timestamp: Date;
329:   userId: string;
330:   action: string;
331:   resource: string;
332:   changes: Record<string, unknown>;
333: }
334: 
335: async function createAuditLog(
336:   action: string,
337:   resource: string,
338:   changes: Record<string, unknown>
339: ): Promise<void> {
340:   await db.collection("auditLogs").add({
341:     timestamp: new Date(),
342:     action,
343:     resource,
344:     changes
345:   });
346: }
347: ```
348: 
349: ### Security Metrics
350: 
351: ```typescript
352: interface SecurityMetrics {
353:   failedAuthAttempts: number;
354:   rateLimitExceeded: number;
355:   suspiciousRequests: number;
356:   securityEvents: number;
357: }
358: 
359: async function trackSecurityMetrics(): Promise<SecurityMetrics> {
360:   // Implementation of security metrics tracking
361:   return {
362:     failedAuthAttempts: 0,
363:     rateLimitExceeded: 0,
364:     suspiciousRequests: 0,
365:     securityEvents: 0
366:   };
367: }
368: ```
</file>

<file path="docs/services/card-sync.md">
  1: # Card Synchronization Service
  2: 
  3: ## Overview
  4: 
  5: The Card Synchronization service (`cardSync.ts`) manages the automated synchronization of FFTCG card data from TCGPlayer's API. It handles card information updates, image processing, and maintains data consistency through hash-based versioning.
  6: 
  7: ## Core Features
  8: 
  9: - Automated card data synchronization
 10: - Image processing and storage
 11: - Batch processing
 12: - Error handling and retry logic
 13: - Dry run capability for testing
 14: - Progress tracking and logging
 15: 
 16: ## API Reference
 17: 
 18: ### Main Function
 19: 
 20: ```typescript
 21: async function syncCards(options: SyncOptions = {}): Promise<SyncMetadata>
 22: ```
 23: 
 24: #### Options
 25: 
 26: ```typescript
 27: interface SyncOptions {
 28:   dryRun?: boolean;      // Run without making changes
 29:   limit?: number;        // Limit number of cards processed
 30:   groupId?: string;      // Process specific group only
 31:   skipImages?: boolean;  // Skip image processing
 32: }
 33: ```
 34: 
 35: #### Response
 36: 
 37: ```typescript
 38: interface SyncMetadata {
 39:   lastSync: Date;
 40:   status: "in_progress" | "success" | "failed" | "completed_with_errors";
 41:   cardCount: number;
 42:   type: "manual" | "scheduled";
 43:   groupsProcessed: number;
 44:   groupsUpdated: number;
 45:   errors: string[];
 46:   duration?: number;
 47:   imagesProcessed?: number;
 48:   imagesUpdated?: number;
 49: }
 50: ```
 51: 
 52: ## Usage Examples
 53: 
 54: ### Scheduled Sync
 55: 
 56: The service runs automatically on a daily schedule:
 57: 
 58: ```typescript
 59: exports.scheduledCardSync = onSchedule({
 60:   schedule: "0 21 * * *", // Daily at 21:00 UTC
 61:   timeZone: "UTC",
 62:   memory: runtimeOpts.memory,
 63:   timeoutSeconds: runtimeOpts.timeoutSeconds,
 64:   retryCount: 3,
 65: });
 66: ```
 67: 
 68: ### Manual Sync
 69: 
 70: Test specific groups or cards:
 71: 
 72: ```typescript
 73: // Test sync with limits
 74: await syncCards({
 75:   dryRun: true,
 76:   limit: 5,
 77:   groupId: "23783"
 78: });
 79: 
 80: // Full manual sync
 81: await syncCards({
 82:   dryRun: false
 83: });
 84: ```
 85: 
 86: ## Error Handling
 87: 
 88: The service implements comprehensive error handling:
 89: 
 90: ```typescript
 91: class SyncError extends Error implements GenericError {
 92:   constructor(
 93:     message: string,
 94:     code?: string,
 95:     public details?: Record<string, unknown>
 96:   ) {
 97:     super(message);
 98:     this.name = "SyncError";
 99:     this.code = code;
100:   }
101: }
102: ```
103: 
104: ### Retry Logic
105: 
106: ```typescript
107: const MAX_RETRIES = 3;
108: const BASE_DELAY = 1000; // 1 second
109: 
110: // Exponential backoff
111: const delay = Math.pow(2, retryCount) * BASE_DELAY;
112: ```
113: 
114: ## Data Processing
115: 
116: ### Batch Processing
117: 
118: ```typescript
119: async function processBatch<T>(
120:   items: T[],
121:   processor: (batch: T[]) => Promise<void>,
122:   options: BatchOptions = {}
123: ): Promise<void>
124: ```
125: 
126: ### Hash Generation
127: 
128: ```typescript
129: function getDataHash(data: any): string {
130:   return crypto.createHash("md5")
131:     .update(JSON.stringify(data, Object.keys(data).sort()))
132:     .digest("hex");
133: }
134: ```
135: 
136: ## Monitoring
137: 
138: ### Progress Tracking
139: 
140: The service logs detailed progress information:
141: 
142: - Groups processed
143: - Cards updated
144: - Images processed
145: - Processing duration
146: - Error counts
147: 
148: ### Success Metrics
149: 
150: - Number of groups updated
151: - Number of cards processed
152: - Number of images updated
153: - Processing duration
154: - Error rate
155: 
156: ## Best Practices
157: 
158: 1. Testing Changes:
159: 
160: ```typescript
161: // Always test with dry run first
162: await syncCards({
163:   dryRun: true,
164:   limit: 5
165: });
166: ```
167: 
168: 1. Error Monitoring:
169: 
170: ```typescript
171: // Check sync metadata for errors
172: const metadata = await syncCards();
173: if (metadata.errors.length > 0) {
174:   console.error("Sync completed with errors:", metadata.errors);
175: }
176: ```
177: 
178: 1. Resource Management:
179: 
180: ```typescript
181: // Use limits when testing
182: const options: SyncOptions = {
183:   limit: 10,
184:   dryRun: true
185: };
186: ```
187: 
188: ## Troubleshooting
189: 
190: ### Common Issues
191: 
192: 1. Rate Limiting:
193:    - Implement proper delays between requests
194:    - Use batch processing
195:    - Follow exponential backoff
196: 
197: 2. Image Processing:
198:    - Verify storage permissions
199:    - Check image URLs
200:    - Monitor storage quotas
201: 
202: 3. Data Consistency:
203:    - Use hash verification
204:    - Implement proper error handling
205:    - Monitor sync metadata
206: 
207: ### Debug Mode
208: 
209: Enable detailed logging:
210: 
211: ```typescript
212: // Enable debug logging
213: await syncCards({
214:   dryRun: true,
215:   debug: true
216: });
217: ```
218: 
219: ## Related Components
220: 
221: - [Price Sync Service](./price-sync)
222: - [Image Handler](../utils/image-handler)
223: - [Cache System](../utils/cache)
224: - [Error Handling](../utils/error-handling)
</file>

<file path="docs/services/price-sync.md">
  1: # Price Synchronization Service
  2: 
  3: ## Overview
  4: 
  5: The Price Synchronization service (`priceSync.ts`) manages automated price updates for FFTCG cards. It handles both normal and foil price variants, implements version control through hashing, and provides detailed logging of price changes.
  6: 
  7: ## Core Features
  8: 
  9: - Real-time price synchronization
 10: - Support for multiple price variants (Normal/Foil)
 11: - Hash-based version control
 12: - Batch processing
 13: - Detailed price change logging
 14: - Configurable sync intervals
 15: 
 16: ## API Reference
 17: 
 18: ### Main Function
 19: 
 20: ```typescript
 21: async function syncPrices(options: SyncOptions = {}): Promise<SyncMetadata>
 22: ```
 23: 
 24: #### Options
 25: 
 26: ```typescript
 27: interface SyncOptions {
 28:   dryRun?: boolean;      // Run without making changes
 29:   limit?: number;        // Limit number of prices processed
 30:   groupId?: string;      // Process specific group only
 31:   productId?: number;    // Process specific product only
 32:   showAll?: boolean;     // Show all prices, including unchanged
 33: }
 34: ```
 35: 
 36: #### Price Data Structure
 37: 
 38: ```typescript
 39: interface CardPrice {
 40:   productId: number;
 41:   lowPrice: number;
 42:   midPrice: number;
 43:   highPrice: number;
 44:   marketPrice: number | null;
 45:   directLowPrice: number | null;
 46:   subTypeName: "Normal" | "Foil";
 47: }
 48: 
 49: interface PriceData {
 50:   normal?: CardPrice;
 51:   foil?: CardPrice;
 52:   lastUpdated: Date;
 53: }
 54: ```
 55: 
 56: ## Usage Examples
 57: 
 58: ### Scheduled Sync
 59: 
 60: Automated daily price updates:
 61: 
 62: ```typescript
 63: exports.scheduledPriceSync = onSchedule({
 64:   schedule: "30 21 * * *", // Daily at 21:30 UTC
 65:   timeZone: "UTC",
 66:   memory: runtimeOpts.memory,
 67:   timeoutSeconds: runtimeOpts.timeoutSeconds,
 68:   retryCount: 3,
 69: });
 70: ```
 71: 
 72: ### Manual Price Checks
 73: 
 74: ```typescript
 75: // Test specific product
 76: await syncPrices({
 77:   dryRun: true,
 78:   productId: 477236,
 79:   showAll: true
 80: });
 81: 
 82: // Check specific group
 83: await syncPrices({
 84:   dryRun: true,
 85:   groupId: "23783",
 86:   limit: 10
 87: });
 88: ```
 89: 
 90: ## Price Processing
 91: 
 92: ### Price Data Processing
 93: 
 94: ```typescript
 95: function processPrices(prices: CardPrice[]): Record<number, PriceData> {
 96:   const priceMap: Record<number, PriceData> = {};
 97: 
 98:   prices.forEach((price) => {
 99:     if (!priceMap[price.productId]) {
100:       priceMap[price.productId] = {
101:         lastUpdated: new Date(),
102:       };
103:     }
104: 
105:     if (price.subTypeName === "Normal") {
106:       priceMap[price.productId].normal = price;
107:     } else {
108:       priceMap[price.productId].foil = price;
109:     }
110:   });
111: 
112:   return priceMap;
113: }
114: ```
115: 
116: ### Batch Processing
117: 
118: ```typescript
119: async function processBatch<T>(
120:   items: T[],
121:   processor: (batch: T[]) => Promise<void>,
122:   batchSize: number = 500
123: ): Promise<void>
124: ```
125: 
126: ## Error Handling
127: 
128: ### Error Types
129: 
130: ```typescript
131: class SyncError extends Error implements GenericError {
132:   code?: string;
133: 
134:   constructor(
135:     message: string,
136:     code?: string,
137:     public details?: Record<string, unknown>
138:   ) {
139:     super(message);
140:     this.name = "SyncError";
141:     this.code = code;
142:   }
143: }
144: ```
145: 
146: ### Request Retry Logic
147: 
148: ```typescript
149: const MAX_RETRIES = 3;
150: const BASE_DELAY = 1000; // 1 second base delay
151: 
152: // Exponential backoff implementation
153: if (retryCount < MAX_RETRIES - 1) {
154:   const delay = Math.pow(2, retryCount) * BASE_DELAY;
155:   await logWarning(`Request failed, retrying in ${delay}ms...`);
156: }
157: ```
158: 
159: ## Monitoring
160: 
161: ### Price Change Tracking
162: 
163: The service tracks:
164: 
165: - Price updates per group
166: - Number of cards processed
167: - Processing duration
168: - Error rates
169: - Price change percentages
170: 
171: ### Success Metrics
172: 
173: ```typescript
174: interface SyncMetadata {
175:   lastSync: Date;
176:   status: "in_progress" | "success" | "failed" | "completed_with_errors";
177:   cardCount: number;
178:   type: "manual" | "scheduled";
179:   groupsProcessed: number;
180:   groupsUpdated: number;
181:   errors: string[];
182:   duration?: number;
183: }
184: 
185: 
186: ## Best Practices
187: 
188: 1. Regular Monitoring:
189:    - Check sync metadata regularly
190:    - Monitor price change patterns
191:    - Track error rates
192: 
193: 1. Testing Changes:
194: 
195: ```typescript
196: // Always test with dry run
197: const testSync = await syncPrices({
198:   dryRun: true,
199:   limit: 5,
200:   showAll: true
201: });
202: ```
203: 
204: 1. Error Handling:
205: 
206: ```typescript
207: // Implement proper error checking
208: const sync = await syncPrices(options);
209: if (sync.status === "completed_with_errors") {
210:   console.error("Sync errors:", sync.errors);
211: }
212: ```
213: 
214: ## Troubleshooting
215: 
216: ### Common Issues
217: 
218: 1. Price Discrepancies:
219:    - Verify data source connection
220:    - Check price format consistency
221:    - Monitor exchange rate impacts
222: 
223: 2. Sync Failures:
224:    - Check network connectivity
225:    - Verify API rate limits
226:    - Monitor service quotas
227: 
228: 3. Performance Issues:
229:    - Use appropriate batch sizes
230:    - Implement proper delays
231:    - Monitor memory usage
232: 
233: ### Validation
234: 
235: ```typescript
236: // Validate price data
237: if (price.midPrice < 0 || price.lowPrice < 0) {
238:   throw new Error("Invalid price values detected");
239: }
240: ```
241: 
242: ## Related Components
243: 
244: - [Card Sync Service](./card-sync)
245: - [Cache System](../utils/cache)
246: - [Error Handling](../utils/error-handling)
247: - [Logger](../utils/logging)
</file>

<file path="docs/setup/configuration.md">
  1: # Configuration Guide
  2: 
  3: ## Firebase Configuration
  4: 
  5: ### Environment Variables
  6: 
  7: Create a `.env.local` file in your project root:
  8: 
  9: ```env
 10: FIREBASE_PROJECT_ID=your-project-id
 11: FIREBASE_STORAGE_BUCKET=your-storage-bucket
 12: ```
 13: 
 14: ### Firebase Console Settings
 15: 
 16: 1. Firestore Database:
 17: 
 18: - Collection structure:
 19:   - `cards`: Stores card information
 20:   - `prices`: Stores price data
 21:   - `syncMetadata`: Stores sync operation logs
 22:   - `logs`: System logs
 23:   - `cardHashes`: Card data version control
 24:   - `priceHashes`: Price data version control
 25:   - `imageMetadata`: Image processing metadata
 26: 
 27: 1. Storage:
 28: 
 29: - Bucket structure:
 30:   - `/card-images/{groupId}/{productId}_200w.jpg`
 31:   - `/card-images/{groupId}/{productId}_400w.jpg`
 32: 
 33: ## Application Configuration
 34: 
 35: ### Runtime Options
 36: 
 37: Located in `src/config/firebase.ts`:
 38: 
 39: ```typescript
 40: export const runtimeOpts = {
 41:   timeoutSeconds: 540,
 42:   memory: "1GiB",
 43: } as const;
 44: ```
 45: 
 46: ### API Configuration
 47: 
 48: Base URL and category settings:
 49: 
 50: ```typescript
 51: export const BASE_URL = "https://tcgcsv.com";
 52: export const FFTCG_CATEGORY_ID = "24";
 53: ```
 54: 
 55: ### Collection Names
 56: 
 57: ```typescript
 58: export const COLLECTION = {
 59:   CARDS: "cards",
 60:   PRICES: "prices",
 61:   SYNC_METADATA: "syncMetadata",
 62:   LOGS: "logs",
 63:   CARD_HASHES: "cardHashes",
 64:   PRICE_HASHES: "priceHashes",
 65:   IMAGE_METADATA: "imageMetadata",
 66: };
 67: ```
 68: 
 69: ## Sync Configuration
 70: 
 71: ### Card Sync Schedule
 72: 
 73: ```typescript
 74: exports.scheduledCardSync = onSchedule({
 75:   schedule: "0 21 * * *", // Daily at 21:00 UTC
 76:   timeZone: "UTC",
 77:   memory: runtimeOpts.memory,
 78:   timeoutSeconds: runtimeOpts.timeoutSeconds,
 79:   retryCount: 3,
 80: });
 81: ```
 82: 
 83: ### Price Sync Schedule
 84: 
 85: ```typescript
 86: exports.scheduledPriceSync = onSchedule({
 87:   schedule: "30 21 * * *", // Daily at 21:30 UTC
 88:   timeZone: "UTC",
 89:   memory: runtimeOpts.memory,
 90:   timeoutSeconds: runtimeOpts.timeoutSeconds,
 91:   retryCount: 3,
 92: });
 93: ```
 94: 
 95: ## Image Processing Configuration
 96: 
 97: ### Compression Settings
 98: 
 99: ```typescript
100: private static readonly QUALITY = {
101:   HIGH_RES: 90,
102:   LOW_RES: 85,
103: };
104: 
105: private static readonly DIMENSIONS = {
106:   HIGH_RES: 400,
107:   LOW_RES: 200,
108: };
109: ```
110: 
111: ### Cache Settings
112: 
113: ```typescript
114: const options = {
115:   max: 500,
116:   ttl: 1000 * 60 * 60, // 1 hour
117: };
118: ```
119: 
120: ## Testing Configuration
121: 
122: ### Test Cases
123: 
124: ```typescript
125: const TEST_CASES = [
126:   {
127:     imageUrl: "https://tcgplayer-cdn.tcgplayer.com/product/477236_200w.jpg",
128:     groupId: "23783",
129:     productId: 477236,
130:     description: "FFVII Boss Deck",
131:   },
132: ];
133: ```
134: 
135: ## Error Handling Configuration
136: 
137: ### Log Levels
138: 
139: ```typescript
140: export interface ErrorReport {
141:   timestamp: Date;
142:   context: string;
143:   error: string;
144:   stackTrace?: string;
145:   metadata?: Record<string, unknown>;
146:   severity: "ERROR" | "WARNING" | "CRITICAL";
147: }
148: ```
</file>

<file path="docs/setup/firebase-config.md">
  1: # Firebase Configuration Guide
  2: 
  3: ## Overview
  4: 
  5: This guide details the Firebase configuration for the FFTCG Sync Service,
  6:  including Cloud Functions setup, database rules, storage configuration, and
  7:   security settings.
  8: 
  9: ## Cloud Functions Configuration
 10: 
 11: ### Runtime Options
 12: 
 13: ```typescript
 14: export const runtimeOpts = {
 15:   timeoutSeconds: 540,
 16:   memory: "1GiB",
 17: } as const;
 18: ```
 19: 
 20: ### Scheduled Functions
 21: 
 22: #### Card Sync Schedule
 23: 
 24: ```typescript
 25: export const scheduledCardSync = onSchedule({
 26:   schedule: "0 21 * * *",  // Daily at 21:00 UTC
 27:   timeZone: "UTC",
 28:   memory: runtimeOpts.memory,
 29:   timeoutSeconds: runtimeOpts.timeoutSeconds,
 30:   retryCount: 3,
 31: });
 32: ```
 33: 
 34: #### Price Sync Schedule
 35: 
 36: ```typescript
 37: export const scheduledPriceSync = onSchedule({
 38:   schedule: "30 21 * * *", // Daily at 21:30 UTC
 39:   timeZone: "UTC",
 40:   memory: runtimeOpts.memory,
 41:   timeoutSeconds: runtimeOpts.timeoutSeconds,
 42:   retryCount: 3,
 43: });
 44: ```
 45: 
 46: ### HTTP Functions
 47: 
 48: #### Request Configuration
 49: 
 50: ```typescript
 51: export const testCardSync = onRequest({
 52:   timeoutSeconds: runtimeOpts.timeoutSeconds,
 53:   memory: runtimeOpts.memory,
 54:   maxInstances: 1,
 55: });
 56: ```
 57: 
 58: ## Firestore Configuration
 59: 
 60: ### Collections Structure
 61: 
 62: ```typescript
 63: export const COLLECTION = {
 64:   CARDS: "cards",           // Card information
 65:   PRICES: "prices",         // Price data
 66:   SYNC_METADATA: "syncMetadata",  // Sync operation logs
 67:   LOGS: "logs",            // System logs
 68:   CARD_HASHES: "cardHashes",  // Card data version control
 69:   PRICE_HASHES: "priceHashes",  // Price data version control
 70:   IMAGE_METADATA: "imageMetadata",  // Image processing metadata
 71: };
 72: ```
 73: 
 74: ### Security Rules
 75: 
 76: ```javascript
 77: rules_version = '2';
 78: service cloud.firestore {
 79:   match /databases/{database}/documents {
 80:     // Card collection rules
 81:     match /cards/{cardId} {
 82:       allow read: if true;
 83:       allow write: if request.auth != null 
 84:         && request.auth.token.admin == true;
 85:     }
 86: 
 87:     // Price collection rules
 88:     match /prices/{priceId} {
 89:       allow read: if true;
 90:       allow write: if request.auth != null 
 91:         && request.auth.token.admin == true;
 92:     }
 93: 
 94:     // Sync metadata rules
 95:     match /syncMetadata/{docId} {
 96:       allow read: if request.auth != null;
 97:       allow write: if request.auth != null 
 98:         && request.auth.token.admin == true;
 99:     }
100:   }
101: }
102: ```
103: 
104: ## Storage Configuration
105: 
106: ### Bucket Configuration
107: 
108: ```typescript
109: export const STORAGE = {
110:   BUCKETS: {
111:     CARD_IMAGES: "fftcg-sync-service.firebasestorage.app",
112:   },
113:   PATHS: {
114:     IMAGES: "card-images",
115:   },
116: };
117: ```
118: 
119: ### Storage Rules
120: 
121: ```javascript
122: rules_version = '2';
123: service firebase.storage {
124:   match /b/{bucket}/o {
125:     match /card-images/{groupId}/{imageId} {
126:       allow read: if true;
127:       allow write: if request.auth != null 
128:         && request.auth.token.admin == true
129:         && request.resource.size < 5 * 1024 * 1024
130:         && request.resource.contentType.matches('image/jpeg');
131:     }
132:   }
133: }
134: ```
135: 
136: ## Authentication Configuration
137: 
138: ### Service Account
139: 
140: ```typescript
141: async function initializeFirebase(): Promise<FirebaseFirestore.Firestore> {
142:   const serviceAccountPath = path.resolve(__dirname, "../service_account_key.json");
143:   const serviceAccount = JSON.parse(
144:     await fs.readFile(serviceAccountPath, "utf8")
145:   );
146: 
147:   if (!admin.apps.length) {
148:     admin.initializeApp({
149:       credential: admin.credential.cert(serviceAccount)
150:     });
151:   }
152: 
153:   return admin.firestore();
154: }
155: ```
156: 
157: ## Environment Configuration
158: 
159: ### Required Environment Variables
160: 
161: ```env
162: FIREBASE_PROJECT_ID=your-project-id
163: FIREBASE_STORAGE_BUCKET=your-storage-bucket
164: FIREBASE_SERVICE_ACCOUNT_PATH=path/to/service-account.json
165: ```
166: 
167: ### Optional Environment Variables
168: 
169: ```env
170: FIREBASE_REGION=us-central1
171: FIREBASE_MEMORY_ALLOCATION=1GB
172: FIREBASE_TIMEOUT=540
173: ```
174: 
175: ## Performance Optimization
176: 
177: ### Function Configuration
178: 
179: - Memory allocation: 1GB per function
180: - Timeout: 540 seconds
181: - Instance limits: Single instance per function
182: - Retry count: 3 (scheduled functions)
183: 
184: ### Database Optimization
185: 
186: - Proper indexing
187: - Batch operations
188: - Caching implementation
189: - Query optimization
190: 
191: ## Monitoring Setup
192: 
193: ### Logging Configuration
194: 
195: ```typescript
196: const db = admin.firestore();
197: db.settings({
198:   ignoreUndefinedProperties: true,
199:   timestampsInSnapshots: true,
200: });
201: ```
202: 
203: ### Health Check Function
204: 
205: ```typescript
206: export const healthCheck = onRequest({
207:   timeoutSeconds: 10,
208:   memory: "128MiB",
209: }, async (_req: Request, res: Response) => {
210:   res.json({
211:     status: "healthy",
212:     timestamp: new Date().toISOString(),
213:     version: "1.0.0",
214:   });
215: });
216: ```
217: 
218: ## Deployment Configuration
219: 
220: ### Firebase Configuration File
221: 
222: ```json
223: {
224:   "functions": {
225:     "source": "functions",
226:     "runtime": "nodejs18",
227:     "predeploy": [
228:       "npm --prefix \"$RESOURCE_DIR\" run lint",
229:       "npm --prefix \"$RESOURCE_DIR\" run build"
230:     ]
231:   },
232:   "firestore": {
233:     "rules": "firestore.rules",
234:     "indexes": "firestore.indexes.json"
235:   },
236:   "storage": {
237:     "rules": "storage.rules"
238:   }
239: }
240: ```
241: 
242: ## Best Practices
243: 
244: ### Security
245: 
246: - Enable Authentication
247: - Implement proper IAM roles
248: - Use secure environment variables
249: - Regular security audits
250: 
251: ### Performance
252: 
253: - Optimize function memory
254: - Implement proper caching
255: - Use batch operations
256: - Monitor resource usage
257: 
258: ### Maintenance
259: 
260: - Regular deployment checks
261: - Log monitoring
262: - Error tracking
263: - Version control
264: 
265: ## Related Documentation
266: 
267: - [Installation Guide](/setup/installation)
268: - [Configuration Guide](/setup/configuration)
269: - [Security Guidelines](/security)
270: - [Performance Guide](/performance)
</file>

<file path="docs/setup/installation.md">
  1: # Installation Guide
  2: 
  3: ## Prerequisites
  4: 
  5: - Node.js 18 or higher
  6: - Firebase CLI (`npm install -g firebase-tools`)
  7: - Git for version control
  8: - A Firebase project with Firestore and Storage enabled
  9: 
 10: ## Firebase Project Setup
 11: 
 12: 1. Create or select a Firebase project:
 13: 
 14:    ```bash
 15:    # Login to Firebase
 16:    firebase login
 17: 
 18:    # List projects
 19:    firebase projects:list
 20: 
 21:    # Set project
 22:    firebase use your-project-id
 23:    ```
 24: 
 25: 2. Enable required services in Firebase Console:
 26:    - Firestore Database
 27:    - Cloud Storage
 28:    - Cloud Functions
 29:    - Authentication
 30: 
 31: 3. Configure Firebase project settings:
 32: 
 33:    ```typescript
 34:    // src/config/firebase.ts
 35:    export const COLLECTION = {
 36:      CARDS: "cards",
 37:      PRICES: "prices",
 38:      SYNC_METADATA: "syncMetadata",
 39:      LOGS: "logs",
 40:      CARD_HASHES: "cardHashes",
 41:      PRICE_HASHES: "priceHashes",
 42:      IMAGE_METADATA: "imageMetadata",
 43:    };
 44: 
 45:    export const STORAGE = {
 46:      BUCKETS: {
 47:        CARD_IMAGES: "your-project-id.firebasestorage.app",
 48:      },
 49:      PATHS: {
 50:        IMAGES: "card-images",
 51:      },
 52:    };
 53:    ```
 54: 
 55: ## Local Development Setup
 56: 
 57: 1. Clone the repository:
 58: 
 59:    ```bash
 60:    git clone <repository-url>
 61:    cd fftcg-sync-service
 62:    ```
 63: 
 64: 2. Install dependencies:
 65: 
 66:    ```bash
 67:    npm install
 68:    ```
 69: 
 70: 3. Set up ESLint configuration:
 71: 
 72:    ```json
 73:    // .eslintrc.js
 74:    {
 75:      "root": true,
 76:      "env": {
 77:        "es6": true,
 78:        "node": true
 79:      },
 80:      "extends": [
 81:        "eslint:recommended",
 82:        "plugin:import/errors",
 83:        "plugin:import/warnings",
 84:        "plugin:import/typescript",
 85:        "google",
 86:        "plugin:@typescript-eslint/recommended"
 87:      ],
 88:      "parser": "@typescript-eslint/parser",
 89:      "parserOptions": {
 90:        "project": ["tsconfig.json", "tsconfig.dev.json"],
 91:        "sourceType": "module"
 92:      }
 93:    }
 94:    ```
 95: 
 96: 4. Configure TypeScript:
 97: 
 98:    ```json
 99:    // tsconfig.json
100:    {
101:      "compilerOptions": {
102:        "module": "commonjs",
103:        "noImplicitReturns": true,
104:        "noUnusedLocals": true,
105:        "outDir": "lib",
106:        "sourceMap": true,
107:        "strict": true,
108:        "target": "es2017",
109:        "esModuleInterop": true,
110:        "skipLibCheck": true,
111:        "types": ["node", "express"],
112:        "baseUrl": "./src",
113:        "lib": ["es2017", "dom"]
114:      },
115:      "compileOnSave": true,
116:      "include": [
117:        "src/**/*"
118:      ]
119:    }
120:    ```
121: 
122: ## Project Structure
123: 
124: The project follows this structure:
125: 
126: <ProjectStructure />
127: 
128: Key directories:
129: 
130: - `/src/config`: Configuration files
131: - `/src/services`: Core service implementations
132: - `/src/utils`: Utility functions
133: - `/src/types`: TypeScript type definitions
134: - `/src/test`: Test implementations
135: 
136: ## Function Configuration
137: 
138: Configure Cloud Functions runtime options:
139: 
140: ```typescript
141: // src/config/firebase.ts
142: export const runtimeOpts = {
143:   timeoutSeconds: 540,
144:   memory: "1GiB",
145: } as const;
146: ```
147: 
148: ## Available Scripts
149: 
150: ```json
151: {
152:   "scripts": {
153:     "clean": "rimraf lib",
154:     "lint": "eslint --ext .js,.ts .",
155:     "lint:fix": "eslint --ext .js,.ts . --fix",
156:     "build": "npm run clean && tsc",
157:     "build:watch": "tsc --watch",
158:     "serve": "npm run build && firebase emulators:start --only functions,firestore,storage",
159:     "shell": "npm run build && firebase functions:shell",
160:     "start": "npm run shell",
161:     "deploy": "npm run lint:fix && firebase deploy --only functions",
162:     "logs": "firebase functions:log",
163:     "test:images": "ts-node src/test/testImageHandler.ts"
164:   }
165: }
166: ```
167: 
168: ## Testing Setup
169: 
170: 1. Configure test endpoints:
171: 
172:    ```typescript
173:    // src/test/testEndpoints.ts
174:    const FIREBASE_REGION = "us-central1";
175:    const PROJECT_ID = "your-project-id";
176:    const BASE_URL = `https://${FIREBASE_REGION}-${PROJECT_ID}.cloudfunctions.net`;
177:    ```
178: 
179: 2. Run image processing tests:
180: 
181:    ```bash
182:    npm run test:images
183:    ```
184: 
185: 3. Test sync operations:
186: 
187:    ```typescript
188:    // src/test/testSync.ts
189:    const testSync = async () => {
190:      // Test card sync
191:      const cardSyncResult = await runSyncTest("testCardSync", {
192:        limit: 5,
193:        dryRun: true,
194:        groupId: "23783"
195:      }, "Card Sync");
196: 
197:      // Test price sync
198:      const priceSyncResult = await runSyncTest("testPriceSync", {
199:        groupId: "23783",
200:        dryRun: true,
201:        limit: 5
202:      }, "Price Sync");
203:    };
204:    ```
205: 
206: ## Deployment
207: 
208: 1. Build the project:
209: 
210:    ```bash
211:    npm run build
212:    ```
213: 
214: 2. Deploy to Firebase:
215: 
216:    ```bash
217:    npm run deploy
218:    ```
219: 
220: 3. Verify deployment:
221: 
222:    ```bash
223:    firebase functions:log
224:    ```
225: 
226: ## Environment Configuration
227: 
228: Set up environment variables in Firebase:
229: 
230: ```bash
231: firebase functions:config:set tcgplayer.base_url="https://tcgcsv.com"
232: firebase functions:config:set tcgplayer.category_id="24"
233: ```
234: 
235: ## Firebase Security Rules
236: 
237: 1. Storage Rules:
238: 
239:    ```typescript
240:    rules_version = '2';
241:    service firebase.storage {
242:      match /b/{bucket}/o {
243:        match /card-images/{groupId}/{imageId} {
244:          allow read: if true;
245:          allow write: if request.auth != null 
246:            && request.auth.token.admin == true;
247:        }
248:      }
249:    }
250:    ```
251: 
252: 2. Firestore Rules:
253: 
254:    ```typescript
255:    rules_version = '2';
256:    service cloud.firestore {
257:      match /databases/{database}/documents {
258:        match /{document=**} {
259:          allow read: if true;
260:          allow write: if request.auth != null 
261:            && request.auth.token.admin == true;
262:        }
263:      }
264:    }
265:    ```
266: 
267: ## Post-Installation Verification
268: 
269: 1. Check system health:
270: 
271:    ```bash
272:    curl https://${REGION}-${PROJECT_ID}.cloudfunctions.net/healthCheck
273:    ```
274: 
275: 2. Run validation:
276: 
277:    ```bash
278:    ts-node src/test/validateSync.ts
279:    ```
280: 
281: 3. Monitor logs:
282: 
283:    ```bash
284:    firebase functions:log --only syncCards,syncPrices
285:    ```
286: 
287: ## Troubleshooting
288: 
289: Common installation issues:
290: 
291: 1. **Node.js Version Mismatch**:
292: 
293:    ```bash
294:    # Check Node.js version
295:    node --version
296: 
297:    # Should be >= 18.0.0
298:    ```
299: 
300: 2. **Firebase CLI Authentication**:
301: 
302:    ```bash
303:    # Re-authenticate
304:    firebase logout
305:    firebase login
306:    ```
307: 
308: 3. **Build Errors**:
309: 
310:    ```bash
311:    # Clear build cache
312:    npm run clean
313: 
314:    # Reinstall dependencies
315:    rm -rf node_modules
316:    npm install
317: 
318:    # Rebuild
319:    npm run build
320:    ```
321: 
322: ## Next Steps
323: 
324: 1. [Configure the service](/setup/configuration)
325: 2. [Review the API documentation](/api/)
326: 3. [Check the architecture overview](/architecture)
327: 4. [View the troubleshooting guide](/troubleshooting)
</file>

<file path="docs/testing/endpoints.md">
  1: # Endpoint Testing Guide
  2: 
  3: ## Overview
  4: 
  5: This guide covers comprehensive testing of the FFTCG Sync Service API endpoints
  6:  using the `testEndpoints.ts` test suite.
  7: 
  8: ## Test Configuration
  9: 
 10: ### Base Configuration
 11: 
 12: ```typescript
 13: const FIREBASE_REGION = "us-central1";
 14: const PROJECT_ID = "fftcg-sync-service";
 15: const BASE_URL = `https://${FIREBASE_REGION}-${PROJECT_ID}.cloudfunctions.net`;
 16: ```
 17: 
 18: ### Response Interface
 19: 
 20: ```typescript
 21: interface SyncResponse {
 22:   lastSync: Date;
 23:   status: string;
 24:   cardCount: number;
 25:   type: string;
 26:   groupsProcessed: number;
 27:   groupsUpdated: number;
 28:   errors: string[];
 29:   duration?: number;
 30: }
 31: ```
 32: 
 33: ## Endpoint Tests
 34: 
 35: ### Card Synchronization Tests
 36: 
 37: #### Test Card Sync
 38: 
 39: ```typescript
 40: async function testCardSync() {
 41:   const response = await axios.get<SyncResponse>(
 42:     `${BASE_URL}/testCardSync`,
 43:     {
 44:       params: {
 45:         limit: 5,
 46:         dryRun: true,
 47:         groupId: "23783"
 48:       }
 49:     }
 50:   );
 51:   
 52:   console.log("Card sync results:", JSON.stringify(response.data, null, 2));
 53:   return response.data;
 54: }
 55: ```
 56: 
 57: #### Manual Card Sync
 58: 
 59: ```typescript
 60: async function testManualCardSync() {
 61:   const response = await axios.get<SyncResponse>(
 62:     `${BASE_URL}/manualCardSync`
 63:   );
 64:   
 65:   console.log("Manual sync results:", JSON.stringify(response.data, null, 2));
 66:   return response.data;
 67: }
 68: ```
 69: 
 70: ### Price Synchronization Tests
 71: 
 72: #### Test Price Sync
 73: 
 74: ```typescript
 75: async function testPriceSync() {
 76:   const response = await axios.get<SyncResponse>(
 77:     `${BASE_URL}/testPriceSync`,
 78:     {
 79:       params: {
 80:         groupId: "23783",
 81:         dryRun: true,
 82:         limit: 5,
 83:         showAll: true
 84:       }
 85:     }
 86:   );
 87:   
 88:   console.log("Price sync results:", JSON.stringify(response.data, null, 2));
 89:   return response.data;
 90: }
 91: ```
 92: 
 93: ### Health Check Tests
 94: 
 95: ```typescript
 96: async function testHealthCheck() {
 97:   const response = await axios.get(
 98:     `${BASE_URL}/healthCheck`
 99:   );
100:   
101:   console.log("Health check response:", JSON.stringify(response.data, null, 2));
102:   return response.data;
103: }
104: ```
105: 
106: ## Error Handling Tests
107: 
108: ### Authentication Errors
109: 
110: ```typescript
111: async function testAuthenticationError() {
112:   try {
113:     await axios.get(`${BASE_URL}/manualCardSync`, {
114:       headers: { Authorization: 'Bearer invalid_token' }
115:     });
116:   } catch (error) {
117:     if (isAxiosError(error)) {
118:       console.error("Auth error:", error.response?.data);
119:       console.error("Status:", error.response?.status);
120:     }
121:   }
122: }
123: ```
124: 
125: ### Rate Limiting Tests
126: 
127: ```typescript
128: async function testRateLimiting() {
129:   const requests = Array(10).fill(null).map(() => 
130:     axios.get(`${BASE_URL}/testCardSync`)
131:   );
132:   
133:   const results = await Promise.allSettled(requests);
134:   const rejected = results.filter(r => r.status === 'rejected');
135:   console.log(`Rate limit test: ${rejected.length} requests rejected`);
136: }
137: ```
138: 
139: ## Test Utilities
140: 
141: ### Response Validation
142: 
143: ```typescript
144: function validateSyncResponse(response: SyncResponse): boolean {
145:   return (
146:     response.status !== undefined &&
147:     typeof response.cardCount === 'number' &&
148:     Array.isArray(response.errors) &&
149:     ['manual', 'scheduled'].includes(response.type)
150:   );
151: }
152: ```
153: 
154: ### Test Runner
155: 
156: ```typescript
157: async function runEndpointTests() {
158:   try {
159:     console.log("Starting endpoint tests...");
160: 
161:     // Test card sync
162:     const cardSyncResult = await testCardSync();
163:     console.assert(validateSyncResponse(cardSyncResult));
164: 
165:     // Test price sync
166:     const priceSyncResult = await testPriceSync();
167:     console.assert(validateSyncResponse(priceSyncResult));
168: 
169:     // Test health check
170:     const healthCheckResult = await testHealthCheck();
171:     console.assert(healthCheckResult.status === "healthy");
172: 
173:     console.log("All tests completed!");
174:   } catch (error) {
175:     console.error("Test suite failed:", error);
176:     process.exit(1);
177:   }
178: }
179: ```
180: 
181: ## Test Scenarios
182: 
183: ### Success Scenarios
184: 
185: 1. Basic Card Sync
186: 
187: await testCardSync();
188: 
189: 1. Full Price Sync
190: 
191: await testPriceSync();
192: 
193: 1. Health Check
194: 
195: await testHealthCheck();
196: 
197: ### Error Scenarios
198: 
199: 1. Invalid Group ID
200: 
201: await testCardSync({
202:   groupId: "invalid_group"
203: });
204: 
205: 1. Rate Limit Exceeded
206: 
207: await testRateLimiting();
208: 
209: 1. Authentication Failure
210: 
211: await testAuthenticationError();
212: 
213: ## Test Reports
214: 
215: ### Success Report Example
216: 
217: ```json
218: {
219:   "lastSync": "2024-11-23T01:47:16.617Z",
220:   "status": "success",
221:   "cardCount": 5,
222:   "type": "manual",
223:   "groupsProcessed": 1,
224:   "groupsUpdated": 1,
225:   "errors": [],
226:   "duration": 2.5
227: }
228: ```
229: 
230: ### Error Report Example
231: 
232: ```json
233: {
234:   "error": "Group not found",
235:   "code": "GROUP_NOT_FOUND",
236:   "details": {
237:     "groupId": "invalid_group"
238:   },
239:   "timestamp": "2024-11-23T01:47:16.617Z"
240: }
241: ```
242: 
243: ## Best Practices
244: 
245: ### Test Organization
246: 
247: - Group related tests
248: - Maintain test independence
249: - Clean up after tests
250: - Use descriptive names
251: 
252: ### Error Handling
253: 
254: - Test error scenarios
255: - Validate error responses
256: - Check status codes
257: - Verify error messages
258: 
259: ### Performance
260: 
261: - Monitor response times
262: - Test concurrent requests
263: - Verify rate limiting
264: - Check resource usage
265: 
266: ## Related Documentation
267: 
268: - [API Documentation](/api/)
269: - [Error Handling](/utils/error-handling)
270: - [Testing Overview](/testing/)
271: - [Configuration Guide](/setup/configuration)
</file>

<file path="docs/testing/images.md">
  1: # Image Processing Tests
  2: 
  3: ## Overview
  4: 
  5: This guide covers the automated testing of image processing functionality using
  6:  `testImageHandler.ts`. The tests verify image downloading, compression, caching,
  7:   and storage operations.
  8: 
  9: ## Test Configuration
 10: 
 11: ### Test Cases
 12: 
 13: ```typescript
 14: const TEST_CASES = [
 15:   {
 16:     imageUrl: "https://tcgplayer-cdn.tcgplayer.com/product/477236_200w.jpg",
 17:     groupId: "23783",
 18:     productId: 477236,
 19:     description: "FFVII Boss Deck"
 20:   }
 21: ];
 22: ```
 23: 
 24: ## Core Test Components
 25: 
 26: ### Basic Image Processing
 27: 
 28: ```typescript
 29: async function testImageProcessing() {
 30:   console.log("\n=== Testing Image Handler ===");
 31:   const imageHandler = new ImageHandler();
 32: 
 33:   for (const testCase of TEST_CASES) {
 34:     console.log(`\nProcessing: ${testCase.description}`);
 35:     console.log("URLs:");
 36:     console.log(`- Original: ${testCase.imageUrl}`);
 37:     console.log(`- High-res: ${testCase.imageUrl.replace("_200w.jpg", "_400w.jpg")}`);
 38: 
 39:     // Test compression independently
 40:     const response = await fetch(testCase.imageUrl);
 41:     const buffer = Buffer.from(await response.arrayBuffer());
 42: 
 43:     // Process both resolutions
 44:     const [lowResResult, highResResult] = await Promise.all([
 45:       ImageCompressor.compress(buffer, false),
 46:       ImageCompressor.compress(buffer, true)
 47:     ]);
 48: 
 49:     // Log compression results
 50:     console.log("Low-res:");
 51:     console.log(`- Original: ${(buffer.length / 1024).toFixed(2)}KB`);
 52:     console.log(`- Compressed: ${(lowResResult.buffer.length / 1024).toFixed(2)}KB`);
 53:     console.log(`- Reduction: ${((1 - lowResResult.buffer.length /
 54:      buffer.length) * 100).toFixed(1)}%`);
 55:     console.log(`- Dimensions: ${lowResResult.info.width}x${lowResResult.info.height}`);
 56:   }
 57: }
 58: ```
 59: 
 60: ### Cache Testing
 61: 
 62: ```typescript
 63: async function testCaching() {
 64:   const imageHandler = new ImageHandler();
 65:   
 66:   // First request - should process and cache
 67:   const initialResult = await imageHandler.processImage(
 68:     testCase.imageUrl,
 69:     testCase.groupId,
 70:     testCase.productId
 71:   );
 72: 
 73:   // Second request - should use cache
 74:   const cachedResult = await imageHandler.processImage(
 75:     testCase.imageUrl,
 76:     testCase.groupId,
 77:     testCase.productId
 78:   );
 79: 
 80:   console.log("Cache Results:");
 81:   console.log(`- Cached: ${!cachedResult.updated}`);
 82:   console.log(`- Original Size: ${(cachedResult.metadata.originalSize || 0) / 1024}KB`);
 83:   console.log(`- High-res Size: ${(cachedResult.metadata.highResSize || 0) / 1024}KB`);
 84: }
 85: ```
 86: 
 87: ### Error Handling Tests
 88: 
 89: ```typescript
 90: async function testErrorHandling() {
 91:   const imageHandler = new ImageHandler();
 92: 
 93:   // Test invalid URL
 94:   const invalidResult = await imageHandler.processImage(
 95:     "https://invalid-url.com/image.jpg",
 96:     TEST_CASES[0].groupId,
 97:     TEST_CASES[0].productId
 98:   );
 99: 
100:   console.log("Error Results:");
101:   console.log(`- Fallback: ${invalidResult.originalUrl === "https://invalid-url.com/image.jpg"}`);
102:   console.log(`- Updated: ${invalidResult.updated}`);
103:   console.log("- Error Handled: true");
104: }
105: ```
106: 
107: ## Test Categories
108: 
109: ### 1. Image Compression Tests
110: 
111: #### Resolution Verification
112: 
113: ```typescript
114: const dimensions = {
115:   standard: {
116:     width: 200,
117:     height: 200
118:   },
119:   highRes: {
120:     width: 400,
121:     height: 400
122:   }
123: };
124: 
125: // Verify dimensions
126: expect(lowResResult.info.width).toBeLessThanOrEqual(dimensions.standard.width);
127: expect(highResResult.info.width).toBeLessThanOrEqual(dimensions.highRes.width);
128: ```
129: 
130: #### Quality Settings
131: 
132: ```typescript
133: const QUALITY = {
134:   HIGH_RES: 90,
135:   LOW_RES: 85
136: };
137: 
138: // Verify compression quality
139: expect(lowResResult.info.quality).toBe(QUALITY.LOW_RES);
140: expect(highResResult.info.quality).toBe(QUALITY.HIGH_RES);
141: ```
142: 
143: ### 2. Storage Integration Tests
144: 
145: ```typescript
146: async function testStorageIntegration() {
147:   const result = await imageHandler.processImage(
148:     testCase.imageUrl,
149:     testCase.groupId,
150:     testCase.productId
151:   );
152: 
153:   console.log("Storage Results:");
154:   console.log(`- Status: ${result.updated ? "Updated" : "Unchanged"}`);
155:   console.log(`- Original Size: ${(result.metadata.originalSize || 0) / 1024}KB`);
156:   console.log(`- High-res Size: ${(result.metadata.highResSize || 0) / 1024}KB`);
157:   console.log(`- Content Type: ${result.metadata.contentType}`);
158:   console.log(`- Last Updated: ${result.metadata.updated.toISOString()}`);
159: }
160: ```
161: 
162: ### 3. Cache System Tests
163: 
164: ```typescript
165: async function testCacheSystem() {
166:   // Test metadata cache
167:   const metadataKey = imageCache.getMetadataCacheKey(
168:     testCase.groupId,
169:     testCase.productId,
170:     false
171:   );
172:   
173:   // Test buffer cache
174:   const bufferKey = imageCache.getBufferCacheKey(testCase.imageUrl);
175:   
176:   // Test existence cache
177:   const existsKey = imageCache.getExistsCacheKey(
178:     testCase.groupId,
179:     testCase.productId,
180:     false
181:   );
182: 
183:   console.log("Cache System Tests:");
184:   console.log(`- Metadata Cached: ${await imageCache.getMetadata(metadataKey)
185:    !== undefined}`);
186:   console.log(`- Buffer Cached: ${await imageCache.getBuffer(bufferKey) !== undefined}`);
187:   console.log(`- Exists Cached: ${imageCache.getExists(existsKey) !== undefined}`);
188: }
189: ```
190: 
191: ## Test Execution
192: 
193: ### Running Tests
194: 
195: ```bash
196: # Run all image tests
197: npm run test:images
198: 
199: # Run specific test categories
200: npm run test:images -- --filter=compression
201: npm run test:images -- --filter=cache
202: npm run test:images -- --filter=storage
203: ```
204: 
205: ### Test Output Example
206: 
207: ```text
208: === Testing Image Handler ===
209: Processing: FFVII Boss Deck
210: URLs:
211: - Original: https://tcgplayer-cdn.tcgplayer.com/product/477236_200w.jpg
212: - High-res: https://tcgplayer-cdn.tcgplayer.com/product/477236_400w.jpg
213: 
214: === Compression Test ===
215: Low-res:
216: - Original: 45.23KB
217: - Compressed: 32.15KB
218: - Reduction: 28.9%
219: - Dimensions: 200x278
220: 
221: High-res:
222: - Original: 89.45KB
223: - Compressed: 65.32KB
224: - Reduction: 27.0%
225: - Dimensions: 400x556
226: ```
227: 
228: ## Best Practices
229: 
230: ### Test Organization
231: 
232: - Isolate test cases
233: - Clean up after tests
234: - Use meaningful descriptions
235: - Log detailed results
236: 
237: ### Performance Considerations
238: 
239: - Monitor memory usage
240: - Track processing times
241: - Verify cache effectiveness
242: - Test concurrent processing
243: 
244: ### Error Handling
245: 
246: - Test invalid inputs
247: - Verify error recovery
248: - Check fallback behavior
249: - Validate error messages
250: 
251: ## Related Documentation
252: 
253: - [Image Handler](/utils/image-handler)
254: - [Image Compressor](/utils/image-compressor)
255: - [Image Validator](/utils/image-validator)
256: - [Cache System](/utils/cache)
</file>

<file path="docs/testing/index.md">
  1: # Testing Guide
  2: 
  3: ## Overview
  4: 
  5: This guide covers the testing infrastructure and procedures for the FFTCG Sync
  6:  Service. The testing suite includes endpoint testing, image processing validation,
  7:   and data integrity checks.
  8: 
  9: ## Test Categories
 10: 
 11: ### 1. Endpoint Testing
 12: 
 13: - API endpoint validation
 14: - Response format verification
 15: - Authentication testing
 16: - Error handling verification
 17: 
 18: ### 2. Image Processing Tests
 19: 
 20: - Compression validation
 21: - Resolution checks
 22: - Cache operations
 23: - Storage integration
 24: 
 25: ### 3. Data Validation
 26: 
 27: - Card data integrity
 28: - Price data accuracy
 29: - Metadata validation
 30: - Collection structure verification
 31: 
 32: ## Running Tests
 33: 
 34: ### Prerequisites
 35: 
 36: - Node.js 18 or higher
 37: - Firebase CLI
 38: - Service account credentials configured
 39: 
 40: ### Common Test Commands
 41: 
 42: ```bash
 43: # Run all tests
 44: npm run test
 45: 
 46: # Test image processing
 47: npm run test:images
 48: 
 49: # Validate sync operations
 50: npm run validate-sync
 51: 
 52: # Test endpoints
 53: npm run test:endpoints
 54: ```
 55: 
 56: ### Test Configuration
 57: 
 58: ```typescript
 59: // Test environment configuration
 60: const TEST_CONFIG = {
 61:   FIREBASE_REGION: "us-central1",
 62:   PROJECT_ID: "fftcg-sync-service",
 63:   TEST_GROUP_ID: "23783",
 64:   SAMPLE_PRODUCT_ID: 477236
 65: };
 66: ```
 67: 
 68: ## Test Architecture
 69: 
 70: ### Directory Structure
 71: 
 72: ```text
 73: src/test/
 74: ├── testEndpoints.ts     # API endpoint tests
 75: ├── testImageHandler.ts  # Image processing tests
 76: ├── testSync.ts         # Sync operation tests
 77: └── validateSync.ts     # Data validation tests
 78: ```
 79: 
 80: ### Test Data Management
 81: 
 82: - Sample data sets
 83: - Test fixtures
 84: - Mock responses
 85: - Validation schemas
 86: 
 87: ## Continuous Integration
 88: 
 89: ### Automated Testing
 90: 
 91: - Pre-deployment validation
 92: - Scheduled test runs
 93: - Error reporting
 94: - Performance benchmarking
 95: 
 96: ### Test Environment
 97: 
 98: ```typescript
 99: // Environment configuration
100: const testEnv = {
101:   isProduction: false,
102:   useEmulator: true,
103:   timeoutSeconds: 540,
104:   memory: "1GiB"
105: };
106: ```
107: 
108: ## Best Practices
109: 
110: ### 1. Test Isolation
111: 
112: - Independent test cases
113: - Clean state between tests
114: - Proper teardown
115: - Environment isolation
116: 
117: ### 2. Error Handling
118: 
119: - Comprehensive error checking
120: - Detailed error logging
121: - Recovery procedures
122: - Cleanup on failure
123: 
124: ### 3. Performance Testing
125: 
126: - Response time monitoring
127: - Resource usage tracking
128: - Concurrency testing
129: - Rate limit verification
130: 
131: ## Troubleshooting
132: 
133: ### Common Issues
134: 
135: 1. Authentication Failures
136:    - Check service account configuration
137:    - Verify Firebase project settings
138:    - Confirm API credentials
139: 
140: 2. Timeout Issues
141:    - Adjust timeouts for long-running tests
142:    - Monitor network conditions
143:    - Check resource constraints
144: 
145: 3. Data Inconsistencies
146:    - Verify test data integrity
147:    - Check database connections
148:    - Validate schema changes
149: 
150: ## Related Documentation
151: 
152: - [Endpoint Tests](./endpoints)
153: - [Image Processing Tests](./images)
154: - [Validation Tests](./validation)
155: - [Configuration Guide](/setup/configuration)
</file>

<file path="docs/testing/validation.md">
  1: # Validation Testing Guide
  2: 
  3: ## Overview
  4: 
  5: This guide covers the validation testing suite (`validateSync.ts`) which
  6:  ensures data integrity and consistency across the FFTCG Sync Service.
  7: 
  8: ## Validation Configuration
  9: 
 10: ### Firebase Initialization
 11: 
 12: ```typescript
 13: async function initializeFirebase(): Promise<FirebaseFirestore.Firestore> {
 14:   try {
 15:     const serviceAccountPath = path.resolve(
 16:       __dirname,
 17:       "../../../service_account_key.json"
 18:     );
 19:     const serviceAccount = JSON.parse(
 20:       await fs.readFile(serviceAccountPath, "utf8")
 21:     );
 22: 
 23:     if (!admin.apps.length) {
 24:       admin.initializeApp({
 25:         credential: admin.credential.cert(serviceAccount)
 26:       });
 27:     }
 28: 
 29:     return admin.firestore();
 30:   } catch (error) {
 31:     console.error("Failed to initialize Firebase:", error);
 32:     throw error;
 33:   }
 34: }
 35: ```
 36: 
 37: ## Validation Functions
 38: 
 39: ### Collection Validation
 40: 
 41: ```typescript
 42: async function validateCollection(
 43:   db: FirebaseFirestore.Firestore,
 44:   collectionName: string,
 45:   validator: (doc: FirebaseFirestore.DocumentData) => boolean,
 46:   options: ValidationOptions = {}
 47: ): Promise<ValidationResult> {
 48:   const result: ValidationResult = {
 49:     collection: collectionName,
 50:     documentsChecked: 0,
 51:     documentsValid: 0,
 52:     errors: [],
 53:     details: {}
 54:   };
 55: 
 56:   try {
 57:     let query = db.collection(collectionName)
 58:       .orderBy("lastUpdated", "desc");
 59: 
 60:     if (options.limit) {
 61:       query = query.limit(options.limit);
 62:     }
 63: 
 64:     if (options.groupId) {
 65:       query = query.where("groupId", "==", options.groupId);
 66:     }
 67: 
 68:     const snapshot = await query.get();
 69:     result.documentsChecked = snapshot.size;
 70: 
 71:     snapshot.forEach((doc) => {
 72:       const data = doc.data();
 73:       try {
 74:         if (validator(data)) {
 75:           result.documentsValid++;
 76:           if (options.verbose) {
 77:             result.details![doc.id] = data;
 78:           }
 79:         } else {
 80:           result.errors.push(`Document ${doc.id} failed validation`);
 81:         }
 82:       } catch (error) {
 83:         result.errors.push(`Error validating ${doc.id}: ${error}`);
 84:       }
 85:     });
 86:   } catch (error) {
 87:     result.errors.push(`Error accessing collection: ${error}`);
 88:   }
 89: 
 90:   return result;
 91: }
 92: ```
 93: 
 94: ## Validation Rules
 95: 
 96: ### Card Data Validation
 97: 
 98: ```typescript
 99: const cardValidator = (data: FirebaseFirestore.DocumentData): boolean => {
100:   return (
101:     typeof data.productId === "number" &&
102:     typeof data.name === "string" &&
103:     typeof data.lastUpdated === "object" &&
104:     data.lastUpdated instanceof Timestamp
105:   );
106: };
107: ```
108: 
109: ### Price Data Validation
110: 
111: ```typescript
112: const priceValidator = (data: FirebaseFirestore.DocumentData): boolean => {
113:   return (
114:     data.lastUpdated instanceof Timestamp &&
115:     (!data.normal || typeof data.normal.midPrice === "number") &&
116:     (!data.foil || typeof data.foil.midPrice === "number")
117:   );
118: };
119: ```
120: 
121: ### Sync Metadata Validation
122: 
123: ```typescript
124: const syncMetadataValidator = (data: FirebaseFirestore.DocumentData):
125:  boolean => {
126:   return (
127:     data.lastSync instanceof Timestamp &&
128:     typeof data.status === "string" &&
129:     typeof data.cardCount === "number" &&
130:     Array.isArray(data.errors)
131:   );
132: };
133: ```
134: 
135: ## Running Validations
136: 
137: ### Full Validation
138: 
139: ```typescript
140: async function validateSync(options: ValidationOptions = {}) {
141:   console.log("Starting sync validation...");
142:   console.log("Options:", JSON.stringify(options, null, 2));
143: 
144:   const db = await initializeFirebase();
145: 
146:   // Validate cards
147:   const cardResult = await validateCollection(
148:     db,
149:     COLLECTION.CARDS,
150:     cardValidator,
151:     options
152:   );
153: 
154:   // Validate prices
155:   const priceResult = await validateCollection(
156:     db,
157:     COLLECTION.PRICES,
158:     priceValidator,
159:     options
160:   );
161: 
162:   // Validate sync metadata
163:   const metadataResult = await validateCollection(
164:     db,
165:     COLLECTION.SYNC_METADATA,
166:     syncMetadataValidator,
167:     options
168:   );
169: 
170:   // Print results
171:   printResults([cardResult, priceResult, metadataResult]);
172: }
173: ```
174: 
175: ### Results Output
176: 
177: ```typescript
178: function printResults(results: ValidationResult[]) {
179:   console.log("\nValidation Results:");
180:   
181:   results.forEach((result) => {
182:     console.log(`\n${result.collection}:`);
183:     console.log(`Documents Checked: ${result.documentsChecked}`);
184:     console.log(`Valid Documents: ${result.documentsValid}`);
185:     
186:     if (result.errors.length > 0) {
187:       console.log("Errors:");
188:       result.errors.forEach((error) => console.log(`- ${error}`));
189:     }
190:   });
191: }
192: ```
193: 
194: ## Command Line Interface
195: 
196: ### Command Line Options
197: 
198: ```typescript
199: const args = process.argv.slice(2);
200: const options: ValidationOptions = {
201:   limit: args.includes("--limit") ? 
202:     parseInt(args[args.indexOf("--limit") + 1]) : undefined,
203:   verbose: args.includes("--verbose"),
204:   groupId: args.includes("--groupId") ? 
205:     args[args.indexOf("--groupId") + 1] : undefined,
206: };
207: ```
208: 
209: ### Usage Examples
210: 
211: ```bash
212: # Run basic validation
213: npm run validate-sync
214: 
215: # Run validation with limit
216: npm run validate-sync -- --limit 100
217: 
218: # Run verbose validation for specific group
219: npm run validate-sync -- --verbose --groupId 23783
220: ```
221: 
222: ## Validation Results
223: 
224: ### Success Example
225: 
226: ```json
227: {
228:   "collection": "cards",
229:   "documentsChecked": 100,
230:   "documentsValid": 100,
231:   "errors": [],
232:   "details": {}
233: }
234: ```
235: 
236: ### Error Example
237: 
238: ```json
239: {
240:   "collection": "prices",
241:   "documentsChecked": 50,
242:   "documentsValid": 48,
243:   "errors": [
244:     "Document abc123 failed validation",
245:     "Error validating def456: Invalid price format"
246:   ],
247:   "details": {}
248: }
249: ```
250: 
251: ## Best Practices
252: 
253: ### Validation Strategy
254: 
255: - Validate all required fields
256: - Check data types
257: - Verify relationships
258: - Monitor performance
259: 
260: ### Error Handling
261: 
262: - Log validation errors
263: - Provide detailed messages
264: - Track error patterns
265: - Implement recovery
266: 
267: ### Performance
268: 
269: - Use appropriate limits
270: - Implement batching
271: - Monitor resource usage
272: - Cache results when appropriate
273: 
274: ## Related Documentation
275: 
276: - [Data Models](/reference/types)
277: - [Error Handling](/utils/error-handling)
278: - [Testing Overview](/testing/)
279: - [Configuration Guide](/setup/configuration)
</file>

<file path="docs/troubleshooting.md">
  1: # Troubleshooting Guide
  2: 
  3: ## Quick Diagnosis
  4: 
  5: ### System Status Check
  6: 
  7: ```bash
  8: # Check service health
  9: curl https://${REGION}-${PROJECT_ID}.cloudfunctions.net/healthCheck
 10: 
 11: # Expected Response
 12: {
 13:   "status": "healthy",
 14:   "timestamp": "2024-11-22T01:47:16.617Z",
 15:   "version": "1.0.0"
 16: }
 17: ```
 18: 
 19: ### Log Analysis
 20: 
 21: ```typescript
 22: // View recent logs
 23: firebase functions:log
 24: 
 25: // Filter for errors
 26: firebase functions:log --only errors
 27: 
 28: // View specific function logs
 29: firebase functions:log --only syncCards
 30: ```
 31: 
 32: ## Common Issues
 33: 
 34: ### Synchronization Failures
 35: 
 36: #### Cards Not Syncing
 37: 
 38: **Symptoms:**
 39: 
 40: - Missing card data
 41: - Outdated information
 42: - Sync operation completes without updates
 43: 
 44: **Solutions:**
 45: 
 46: 1. Check API access:
 47: 
 48: ```typescript
 49: // Test API connection
 50: const response = await makeRequest<{ results: any[] }>(
 51:   `${FFTCG_CATEGORY_ID}/groups`,
 52:   {metadata: {operation: "fetchGroups"}}
 53: );
 54: ```
 55: 
 56: 1. Verify hash comparison:
 57: 
 58: ```typescript
 59: // Force sync by clearing hashes
 60: await db.collection(COLLECTION.CARD_HASHES).doc(groupId).delete();
 61: ```
 62: 
 63: 1. Check rate limits:
 64: 
 65: ```typescript
 66: // Monitor rate limit logs
 67: await logInfo("Rate limit status", {
 68:   remaining: rateLimiter.tokens,
 69:   nextRefill: rateLimiter.nextRefillTime
 70: });
 71: ```
 72: 
 73: #### Price Updates Failed
 74: 
 75: **Symptoms:**
 76: 
 77: - Outdated prices
 78: - Partial updates
 79: - Sync metadata shows errors
 80: 
 81: **Solutions:**
 82: 
 83: 1. Validate price data:
 84: 
 85: ```typescript
 86: const priceResult = await validateCollection(
 87:   db,
 88:   COLLECTION.PRICES,
 89:   (data) => {
 90:     return (
 91:       data.lastUpdated instanceof Timestamp &&
 92:       (!data.normal || typeof data.normal.midPrice === "number") &&
 93:       (!data.foil || typeof data.foil.midPrice === "number")
 94:     );
 95:   }
 96: );
 97: ```
 98: 
 99: 1. Force price sync:
100: 
101: ```typescript
102: await syncPrices({
103:   dryRun: false,
104:   groupId: specificGroupId,
105:   forceUpdate: true
106: });
107: ```
108: 
109: ### Image Processing Issues
110: 
111: #### Image Upload Failures
112: 
113: **Symptoms:**
114: 
115: - Missing images in storage
116: - Failed compression attempts
117: - Storage quota errors
118: 
119: **Solutions:**
120: 
121: 1. Check image validation:
122: 
123: ```typescript
124: const validationResult = await ImageValidator.validateImage(buffer);
125: if (validationResult) {
126:   console.error("Validation failed:", validationResult.message);
127: }
128: ```
129: 
130: 1. Verify storage permissions:
131: 
132: ```typescript
133: try {
134:   await storage.bucket(STORAGE.BUCKETS.CARD_IMAGES).file(path).save(buffer);
135: } catch (error) {
136:   console.error("Storage access error:", error);
137: }
138: ```
139: 
140: 1. Monitor storage quota:
141: 
142: ```typescript
143: const [usage] = await storage.bucket().getMetadata();
144: console.log("Storage usage:", usage.size);
145: ```
146: 
147: #### Image Compression Problems
148: 
149: **Symptoms:**
150: 
151: - Large file sizes
152: - Poor image quality
153: - Processing timeouts
154: 
155: **Solutions:**
156: 
157: 1. Adjust compression settings:
158: 
159: ```typescript
160: const compressionOptions = {
161:   quality: ImageCompressor.QUALITY.HIGH_RES,
162:   progressive: true,
163:   mozjpeg: true
164: };
165: ```
166: 
167: 1. Debug compression process:
168: 
169: ```typescript
170: const result = await ImageCompressor.compress(buffer, false);
171: console.log("Compression results:", {
172:   originalSize: buffer.length,
173:   compressedSize: result.buffer.length,
174:   ratio: result.buffer.length / buffer.length
175: });
176: ```
177: 
178: ### Database Issues
179: 
180: #### Write Operations Failed
181: 
182: **Symptoms:**
183: 
184: - Timeout errors
185: - Batch operation failures
186: - Inconsistent data state
187: 
188: **Solutions:**
189: 
190: 1. Check batch size:
191: 
192: ```typescript
193: // Reduce batch size
194: const batchOptions = {
195:   batchSize: 100,  // Decrease from default 500
196:   delayBetweenBatches: 1000
197: };
198: ```
199: 
200: 1. Monitor write operations:
201: 
202: ```typescript
203: const stats = {
204:   attempted: 0,
205:   successful: 0,
206:   failed: 0
207: };
208: 
209: await processBatch(items, async (batch) => {
210:   try {
211:     await writeBatch.commit();
212:     stats.successful += batch.length;
213:   } catch (error) {
214:     stats.failed += batch.length;
215:     await logError(error, "writeBatch");
216:   }
217:   stats.attempted += batch.length;
218: });
219: ```
220: 
221: #### Cache Inconsistency
222: 
223: **Symptoms:**
224: 
225: - Stale data
226: - Memory usage spikes
227: - Inconsistent results
228: 
229: **Solutions:**
230: 
231: 1. Clear caches:
232: 
233: ```typescript
234: // Clear specific cache
235: imageCache.clear();
236: cardCache.clear();
237: 
238: // Clear all caches
239: await Promise.all([
240:   imageCache.clear(),
241:   cardCache.clear(),
242:   db.clearPersistence()
243: ]);
244: ```
245: 
246: 1. Verify cache settings:
247: 
248: ```typescript
249: const cacheOptions = {
250:   max: 500,
251:   ttl: 1000 * 60 * 60, // 1 hour
252:   updateAgeOnGet: true
253: };
254: ```
255: 
256: ### Performance Issues
257: 
258: #### High Memory Usage
259: 
260: **Symptoms:**
261: 
262: - Function timeouts
263: - Out of memory errors
264: - Slow processing
265: 
266: **Solutions:**
267: 
268: 1. Monitor memory usage:
269: 
270: ```typescript
271: const used = process.memoryUsage();
272: await logInfo("Memory usage", {
273:   heapUsed: `${Math.round(used.heapUsed / 1024 / 1024 * 100) / 100} MB`,
274:   heapTotal: `${Math.round(used.heapTotal / 1024 / 1024 * 100) / 100} MB`,
275: });
276: ```
277: 
278: 1. Implement cleanup:
279: 
280: ```typescript
281: async function cleanupResources(): Promise<void> {
282:   await imageCache.clear();
283:   global.gc && global.gc();
284: }
285: ```
286: 
287: #### Slow Synchronization
288: 
289: **Symptoms:**
290: 
291: - Long sync duration
292: - Timeout errors
293: - Queue buildup
294: 
295: **Solutions:**
296: 
297: 1. Enable progress tracking:
298: 
299: ```typescript
300: const progress = new EnhancedProgressTracker(
301:   totalItems,
302:   "Processing Cards",
303:   { updateInterval: 1000 }
304: );
305: 
306: // Monitor progress
307: progress.update(1);
308: const stats = progress.getProgress();
309: ```
310: 
311: 1. Optimize batch processing:
312: 
313: ```typescript
314: const optimizedBatch = new AdaptiveBatchProcessor();
315: await optimizedBatch.processBatch(items, processor);
316: ```
317: 
318: ### Network Issues
319: 
320: #### API Connection Failures
321: 
322: **Symptoms:**
323: 
324: - Request timeouts
325: - Connection refused
326: - DNS resolution failed
327: 
328: **Solutions:**
329: 
330: 1. Implement retry logic:
331: 
332: ```typescript
333: const requestWithRetry = async () => {
334:   const retryStrategy = new RetryStrategy();
335:   return retryStrategy.executeWithRetry(
336:     operation,
337:     "API_REQUEST"
338:   );
339: };
340: ```
341: 
342: 1. Check network status:
343: 
344: ```typescript
345: async function checkConnectivity(): Promise<boolean> {
346:   try {
347:     await axios.get(BASE_URL, { timeout: 5000 });
348:     return true;
349:   } catch (error) {
350:     await logError(error, "connectivityCheck");
351:     return false;
352:   }
353: }
354: ```
355: 
356: ## Debugging Tools
357: 
358: ### Logging and Diagnostics
359: 
360: ```typescript
361: // Enable detailed logging
362: const logger = new SyncLogger({
363:   type: "manual",
364:   limit: 10,
365:   dryRun: true,
366:   verbose: true
367: });
368: 
369: // Track specific operations
370: await logger.logGroupDetails(groupId, products.length, prices.length);
371: ```
372: 
373: ### Validation Tools
374: 
375: ```typescript
376: // Validate sync state
377: await validateSync({
378:   limit: 100,
379:   verbose: true,
380:   groupId: "test_group"
381: });
382: 
383: // Check data integrity
384: const integrityCheck = await validateCollection(db, COLLECTION.CARDS);
385: console.log("Integrity check results:", integrityCheck);
386: ```
387: 
388: ### Performance Monitoring
389: 
390: ```typescript
391: // Track operation timing
392: const timer = {
393:   start: Date.now(),
394:   checkPoint(operation: string) {
395:     const duration = Date.now() - this.start;
396:     console.log(`${operation}: ${duration}ms`);
397:   }
398: };
399: 
400: // Monitor async operations
401: async function trackAsyncOperation<T>(
402:   operation: () => Promise<T>,
403:   name: string
404: ): Promise<T> {
405:   const start = Date.now();
406:   try {
407:     const result = await operation();
408:     const duration = Date.now() - start;
409:     await logInfo(`${name} completed`, { duration });
410:     return result;
411:   } catch (error) {
412:     await logError(error, name);
413:     throw error;
414:   }
415: }
416: ```
417: 
418: ## Recovery Procedures
419: 
420: ### Data Recovery
421: 
422: 1. Backup verification:
423: 
424: ```typescript
425: async function verifyBackups(): Promise<boolean> {
426:   const backups = await db.collection('backups').get();
427:   return backups.size > 0;
428: }
429: ```
430: 
431: 1. Restore procedure:
432: 
433: ```typescript
434: async function restoreData(timestamp: Date): Promise<void> {
435:   const backup = await db.collection('backups')
436:     .where('timestamp', '<=', timestamp)
437:     .orderBy('timestamp', 'desc')
438:     .limit(1)
439:     .get();
440:    
441:   if (!backup.empty) {
442:     await restoreFromBackup(backup.docs[0]);
443:   }
444: }
445: ```
446: 
447: ### Error Recovery
448: 
449: 1. Clear error state:
450: 
451: ```typescript
452: async function clearErrorState(): Promise<void> {
453:   await db.collection(COLLECTION.SYNC_METADATA)
454:     .where('status', '==', 'failed')
455:     .get()
456:     .then(snapshot => {
457:       const batch = db.batch();
458:       snapshot.forEach(doc => {
459:         batch.update(doc.ref, { status: 'ready' });
460:       });
461:       return batch.commit();
462:     });
463: }
464: ```
465: 
466: 1. Reset sync state:
467: 
468: ```typescript
469: async function resetSyncState(): Promise<void> {
470:   await Promise.all([
471:     db.collection(COLLECTION.CARD_HASHES).get()
472:       .then(snapshot => {
473:         const batch = db.batch();
474:         snapshot.forEach(doc => batch.delete(doc.ref));
475:         return batch.commit();
476:       }),
477:     db.collection(COLLECTION.PRICE_HASHES).get()
478:       .then(snapshot => {
479:         const batch = db.batch();
480:         snapshot.forEach(doc => batch.delete(doc.ref));
481:         return batch.commit();
482:       })
483:   ]);
484: }
485: ```
</file>

<file path="docs/troubleshooting/common-issues.md">
  1: # Common Issues and Solutions
  2: 
  3: ## Overview
  4: 
  5: This guide covers common issues encountered in the FFTCG Sync Service and their
  6:  solutions, including synchronization problems, image processing errors,
  7:   and performance issues.
  8: 
  9: ## Synchronization Issues
 10: 
 11: ### 1. Sync Operation Timeouts
 12: 
 13: **Symptoms:**
 14: 
 15: - Function execution timeouts
 16: - Incomplete synchronization
 17: - Missing card data
 18: 
 19: **Solutions:**
 20: 
 21: ```typescript
 22: // Implement batch processing with proper sizing
 23: const batchOptions = {
 24:   batchSize: 100,  // Reduce from default 500
 25:   delayBetweenBatches: 1000,
 26:   onBatchComplete: async (stats) => {
 27:     console.log(`Processed ${stats.processed}/${stats.total}`);
 28:   }
 29: };
 30: 
 31: // Use proper timeouts
 32: export const runtimeOpts = {
 33:   timeoutSeconds: 540,  // Increase if needed
 34:   memory: "1GiB"
 35: };
 36: ```
 37: 
 38: ### 2. Data Inconsistency
 39: 
 40: **Symptoms:**
 41: 
 42: - Mismatched card data
 43: - Missing prices
 44: - Incorrect image URLs
 45: 
 46: **Solutions:**
 47: 
 48: ```typescript
 49: // Validate data integrity
 50: async function validateData(groupId: string): Promise<void> {
 51:   const cards = await db.collection(COLLECTION.CARDS)
 52:     .where("groupId", "==", groupId)
 53:     .get();
 54: 
 55:   const prices = await db.collection(COLLECTION.PRICES)
 56:     .where("groupId", "==", groupId)
 57:     .get();
 58: 
 59:   // Cross-reference and fix inconsistencies
 60:   for (const card of cards.docs) {
 61:     const cardData = card.data();
 62:     const priceDoc = prices.docs
 63:       .find(doc => doc.id === cardData.productId.toString());
 64: 
 65:     if (!priceDoc) {
 66:       await logError(
 67:         new Error(`Missing price data for card ${cardData.productId}`),
 68:         "dataValidation"
 69:       );
 70:     }
 71:   }
 72: }
 73: ```
 74: 
 75: ## Image Processing Issues
 76: 
 77: ### 1. Image Download Failures
 78: 
 79: **Symptoms:**
 80: 
 81: - Failed image downloads
 82: - Timeout errors
 83: - Missing images
 84: 
 85: **Solutions:**
 86: 
 87: ```typescript
 88: // Implement retry logic with exponential backoff
 89: async function downloadImageWithRetry(
 90:   url: string,
 91:   maxRetries: number = 3
 92: ): Promise<Buffer> {
 93:   for (let attempt = 0; attempt < maxRetries; attempt++) {
 94:     try {
 95:       const response = await axios.get(url, {
 96:         responseType: "arraybuffer",
 97:         timeout: 30000,
 98:       });
 99:       return Buffer.from(response.data);
100:     } catch (error) {
101:       const delay = Math.pow(2, attempt) * 1000;
102:       await new Promise(resolve => setTimeout(resolve, delay));
103:     }
104:   }
105:   throw new Error(`Failed to download image after ${maxRetries} attempts`);
106: }
107: ```
108: 
109: ### 2. Storage Quota Issues
110: 
111: **Symptoms:**
112: 
113: - Storage quota exceeded
114: - Failed image uploads
115: - Missing processed images
116: 
117: **Solutions:**
118: 
119: ```typescript
120: // Implement storage cleanup
121: async function cleanupOldImages(): Promise<void> {
122:   const cutoffDate = new Date();
123:   cutoffDate.setDate(cutoffDate.getDate() - 30);
124: 
125:   const [files] = await storage
126:     .bucket(STORAGE.BUCKETS.CARD_IMAGES)
127:     .getFiles();
128: 
129:   for (const file of files) {
130:     const metadata = file.metadata;
131:     if (new Date(metadata.timeCreated) < cutoffDate) {
132:       await file.delete();
133:     }
134:   }
135: }
136: ```
137: 
138: ## Performance Issues
139: 
140: ### 1. High Memory Usage
141: 
142: **Symptoms:**
143: 
144: - Out of memory errors
145: - Function crashes
146: - Slow processing
147: 
148: **Solutions:**
149: 
150: ```typescript
151: // Implement memory monitoring and cleanup
152: function monitorMemory(): void {
153:   const memoryUsage = process.memoryUsage();
154:   const threshold = 900 * 1024 * 1024; // 900MB
155: 
156:   if (memoryUsage.heapUsed > threshold) {
157:     // Clear caches
158:     imageCache.clear();
159:     cardCache.clear();
160:     
161:     // Force garbage collection if available
162:     global.gc?.();
163:     
164:     logWarning("High memory usage detected", {
165:       usage: memoryUsage.heapUsed,
166:       threshold
167:     });
168:   }
169: }
170: ```
171: 
172: ### 2. Slow Database Operations
173: 
174: **Symptoms:**
175: 
176: - Slow query responses
177: - Transaction timeouts
178: - Operation failures
179: 
180: **Solutions:**
181: 
182: ```typescript
183: // Optimize queries and implement monitoring
184: async function optimizeQuery<T>(
185:   queryFn: () => Promise<T>,
186:   context: string
187: ): Promise<T> {
188:   const start = Date.now();
189:   try {
190:     const result = await queryFn();
191:     const duration = Date.now() - start;
192: 
193:     if (duration > 1000) {
194:       await logWarning("Slow query detected", {
195:         context,
196:         duration,
197:         timestamp: new Date()
198:       });
199:     }
200: 
201:     return result;
202:   } catch (error) {
203:     await logError(error, `${context}:query`);
204:     throw error;
205:   }
206: }
207: ```
208: 
209: ## Authentication Issues
210: 
211: ### 1. Token Expiration
212: 
213: **Symptoms:**
214: 
215: - Authentication failures
216: - 401 errors
217: - Unauthorized access
218: 
219: **Solutions:**
220: 
221: ```typescript
222: // Implement token refresh
223: async function getValidToken(): Promise<string> {
224:   const auth = getAuth();
225:   const user = auth.currentUser;
226:   
227:   if (!user) {
228:     throw new Error("No authenticated user");
229:   }
230: 
231:   try {
232:     return await user.getIdToken(true);  // Force refresh
233:   } catch (error) {
234:     await logError(error, "tokenRefresh");
235:     throw error;
236:   }
237: }
238: ```
239: 
240: ### 2. Permission Issues
241: 
242: **Symptoms:**
243: 
244: - Access denied errors
245: - 403 responses
246: - Failed operations
247: 
248: **Solutions:**
249: 
250: ```typescript
251: // Verify and fix permissions
252: async function verifyPermissions(
253:   userId: string
254: ): Promise<void> {
255:   const user = await admin.auth().getUser(userId);
256:   
257:   if (!user.customClaims?.admin) {
258:     await admin.auth().setCustomUserClaims(userId, {
259:       admin: true
260:     });
261:     
262:     await logInfo("Updated user permissions", {
263:       userId,
264:       claims: { admin: true }
265:     });
266:   }
267: }
268: ```
269: 
270: ## Rate Limiting Issues
271: 
272: ### 1. API Rate Limits
273: 
274: **Symptoms:**
275: 
276: - 429 Too Many Requests
277: - Failed API calls
278: - Throttled operations
279: 
280: **Solutions:**
281: 
282: ```typescript
283: // Implement rate limiting
284: class RateLimiter {
285:   private tokens: number;
286:   private lastRefill: number;
287:   
288:   constructor(
289:     private maxTokens: number,
290:     private refillRate: number,
291:     private refillInterval: number
292:   ) {
293:     this.tokens = maxTokens;
294:     this.lastRefill = Date.now();
295:   }
296: 
297:   async acquire(): Promise<boolean> {
298:     this.refillTokens();
299:     
300:     if (this.tokens > 0) {
301:       this.tokens--;
302:       return true;
303:     }
304:     
305:     return false;
306:   }
307: 
308:   private refillTokens(): void {
309:     const now = Date.now();
310:     const elapsed = now - this.lastRefill;
311:     const tokensToAdd = Math.floor(
312:       (elapsed / this.refillInterval) * this.refillRate
313:     );
314:     
315:     this.tokens = Math.min(this.maxTokens, this.tokens + tokensToAdd);
316:     this.lastRefill = now;
317:   }
318: }
319: ```
320: 
321: ## Recovery Procedures
322: 
323: ### 1. Data Recovery
324: 
325: ```typescript
326: // Implement data recovery
327: async function recoverData(
328:   groupId: string,
329:   timestamp: Date
330: ): Promise<void> {
331:   // Get backup data
332:   const backup = await db.collection("backups")
333:     .where("timestamp", "<=", timestamp)
334:     .orderBy("timestamp", "desc")
335:     .limit(1)
336:     .get();
337: 
338:   if (!backup.empty) {
339:     const backupData = backup.docs[0].data();
340:     await restoreFromBackup(backupData);
341:   }
342: }
343: ```
344: 
345: ### 2. Error Recovery
346: 
347: ```typescript
348: // Implement error recovery
349: async function recoverFromError(
350:   error: Error,
351:   context: string
352: ): Promise<void> {
353:   await logError(error, context);
354:   
355:   // Attempt recovery based on error type
356:   switch (error.name) {
357:     case "NetworkError":
358:       await retryOperation();
359:       break;
360:     case "DatabaseError":
361:       await validateAndRepair();
362:       break;
363:     default:
364:       await generalRecovery();
365:   }
366: }
367: ```
368: 
369: ## Diagnostic Tools
370: 
371: ### 1. System Check
372: 
373: ```typescript
374: async function runSystemCheck(): Promise<void> {
375:   // Check database connection
376:   await db.collection(COLLECTION.CARDS).limit(1).get();
377:   
378:   // Check storage access
379:   await storage.bucket(STORAGE.BUCKETS.CARD_IMAGES)
380:     .file("test.txt")
381:     .exists();
382:   
383:   // Check memory usage
384:   const memoryUsage = process.memoryUsage();
385:   console.log("Memory usage:", memoryUsage);
386:   
387:   // Check cache status
388:   console.log("Cache stats:", imageCache.getStats());
389: }
390: ```
391: 
392: ### 2. Log Analysis
393: 
394: ```typescript
395: async function analyzeErrors(): Promise<void> {
396:   const errors = await db.collection(COLLECTION.LOGS)
397:     .where("level", "==", "ERROR")
398:     .orderBy("timestamp", "desc")
399:     .limit(100)
400:     .get();
401: 
402:   const errorPatterns = errors.docs.reduce((acc, doc) => {
403:     const error = doc.data();
404:     acc[error.message] = (acc[error.message] || 0) + 1;
405:     return acc;
406:   }, {} as Record<string, number>);
407: 
408:   console.log("Error patterns:", errorPatterns);
409: }
410: ```
411: 
412: ## Related Documentation
413: 
414: - [Monitoring Guide](/monitoring/)
415: - [Error Handling](/utils/error-handling)
416: - [Deployment Guide](/deployment/)
417: - [System Architecture](/architecture)
</file>

<file path="docs/usage-guide.md">
  1: # FFTCG Sync Service Usage Guide
  2: 
  3: ## Overview
  4: 
  5: This guide provides comprehensive instructions for using the FFTCG Sync Service, including setup, operations, and best practices.
  6: 
  7: ## Quick Start
  8: 
  9: ### Prerequisites
 10: 
 11: - Node.js 18 or higher
 12: - Firebase CLI installed (`npm install -g firebase-tools`)
 13: - Firebase project created
 14: - Service account key configured
 15: 
 16: ### Initial Setup
 17: 
 18: 1. Clone the repository
 19: 
 20: ```bash
 21: git clone https://github.com/yourusername/fftcg-sync-service.git
 22: cd fftcg-sync-service
 23: ```
 24: 
 25: 1. Install dependencies
 26: 
 27: ```bash
 28: npm install
 29: ```
 30: 
 31: 1. Initialize Firebase
 32: 
 33: ```bash
 34: firebase login
 35: firebase init
 36: ```
 37: 
 38: ## API Reference
 39: 
 40: ### Card Management Endpoints
 41: 
 42: #### Test Card Sync
 43: 
 44: ```http
 45: GET /testCardSync?limit=5&dryRun=true&groupId=23783
 46: ```
 47: 
 48: #### Manual Card Sync
 49: 
 50: ```http
 51: GET /manualCardSync
 52: ```
 53: 
 54: ### Price Management Endpoints
 55: 
 56: #### Test Price Sync
 57: 
 58: ```http
 59: GET /testPriceSync?limit=5&dryRun=true&groupId=23783
 60: ```
 61: 
 62: #### Manual Price Sync
 63: 
 64: ```http
 65: GET /manualPriceSync
 66: ```
 67: 
 68: ## Synchronization Features
 69: 
 70: ### Card Data Synchronization
 71: 
 72: ```typescript
 73: // Test sync with limited cards
 74: const options = {
 75:   dryRun: true,
 76:   limit: 5,
 77:   groupId: "23783" // Optional: specific group
 78: };
 79: 
 80: await syncCards(options);
 81: ```
 82: 
 83: ### Price Data Synchronization
 84: 
 85: ```typescript
 86: // Test price sync for specific cards
 87: const options = {
 88:   dryRun: true,
 89:   limit: 10,
 90:   groupId: "23783",
 91:   productId: 477236 // Optional: specific card
 92: };
 93: 
 94: await syncPrices(options);
 95: ```
 96: 
 97: ## Image Management
 98: 
 99: ### Basic Image Processing
100: 
101: ```typescript
102: const imageHandler = new ImageHandler();
103: 
104: const result = await imageHandler.processImage(
105:   imageUrl,
106:   groupId,
107:   productId
108: );
109: ```
110: 
111: ### Image Processing Options
112: 
113: ```typescript
114: const options = {
115:   skipImages: false,    // Skip image processing
116:   retryFailedImages: true,    // Retry failed images
117:   batchSize: 25        // Batch size for processing
118: };
119: ```
120: 
121: ## Batch Operations
122: 
123: ### Standard Batch Processing
124: 
125: ```typescript
126: const batchOptions = {
127:   batchSize: 100,
128:   delayBetweenBatches: 1000,
129:   onBatchComplete: async (stats) => {
130:     console.log(`Processed: ${stats.processed}/${stats.total}`);
131:   }
132: };
133: 
134: await processBatch(items, processor, batchOptions);
135: ```
136: 
137: ## Logging System
138: 
139: ### Core Logging Operations
140: 
141: ```typescript
142: // Info logging
143: await logInfo("Operation started", {
144:   context: "syncOperation",
145:   timestamp: new Date()
146: });
147: 
148: // Warning logging
149: await logWarning("Retry required", {
150:   attempt: 2,
151:   maxRetries: 3
152: });
153: 
154: // Error logging
155: await logError(error, "operationName");
156: ```
157: 
158: ### Sync Status Logging
159: 
160: ```typescript
161: const logger = new SyncLogger({
162:   type: "manual",
163:   limit: 10,
164:   dryRun: true
165: });
166: 
167: await logger.start();
168: await logger.logGroupDetails(groupId, products.length, prices.length);
169: await logger.finish();
170: ```
171: 
172: ## Testing Infrastructure
173: 
174: ### Image System Testing
175: 
176: ```typescript
177: // Run the image processing test suite
178: npm run test:images
179: 
180: // Test specific image handling
181: const testCase = {
182:   imageUrl: "https://example.com/card.jpg",
183:   groupId: "23783",
184:   productId: 477236
185: };
186: 
187: await testImageProcessing(testCase);
188: ```
189: 
190: ### Sync System Testing
191: 
192: ```bash
193: # Basic validation
194: npm run validate-sync
195: 
196: # Advanced validation with options
197: npm run validate-sync -- --limit 10 --verbose --groupId 23783
198: ```
199: 
200: ## System Observation
201: 
202: ### Health Monitoring
203: 
204: ```typescript
205: // Endpoint: GET /healthCheck
206: const healthResponse = {
207:   status: "healthy",
208:   timestamp: "2024-11-22T01:47:16.617Z",
209:   version: "1.0.0"
210: };
211: ```
212: 
213: ### Runtime Monitoring
214: 
215: ```typescript
216: // Monitor sync operations
217: const syncStats = {
218:   processedItems: 0,
219:   totalItems: 100,
220:   startTime: Date.now(),
221:   errors: []
222: };
223: 
224: // Update monitoring stats
225: function updateStats(processed: number): void {
226:   syncStats.processedItems = processed;
227:   const elapsed = Date.now() - syncStats.startTime;
228:   const rate = processed / (elapsed / 1000);
229:   console.log(`Processing rate: ${rate.toFixed(2)} items/second`);
230: }
231: ```
232: 
233: ## Operational Procedures
234: 
235: ### Sync Process Workflow
236: 
237: 1. Initialize sync operation
238: 
239: ```typescript
240: const syncOptions = {
241:   dryRun: false,
242:   limit: undefined,
243:   groupId: undefined
244: };
245: ```
246: 
247: 1. Fetch and validate data
248: 
249: ```typescript
250: const rawData = await fetchData();
251: const validatedData = await validateData(rawData);
252: ```
253: 
254: 1. Process updates
255: 
256: ```typescript
257: await processBatch(validatedData, async (batch) => {
258:   await updateDatabase(batch);
259: });
260: ```
261: 
262: 1. Handle image processing
263: 
264: ```typescript
265: await processImages(validatedData, {
266:   compression: true,
267:   validateMetadata: true
268: });
269: ```
270: 
271: 1. Update cache system
272: 
273: ```typescript
274: await updateCacheEntries(processedData);
275: ```
276: 
277: ### Image Pipeline Workflow
278: 
279: #### Image Acquisition and Validation
280: 
281: ```typescript
282: const imageHandler = new ImageHandler();
283: const validator = new ImageValidator();
284: 
285: const buffer = await imageHandler.downloadImage(url);
286: const validationResult = await validator.validateImage(buffer);
287: ```
288: 
289: #### Image Processing and Storage
290: 
291: ```typescript
292: const compressor = new ImageCompressor();
293: const result = await compressor.compress(buffer, {
294:   quality: 85,
295:   maxWidth: 800
296: });
297: 
298: await storageService.uploadImage(result.buffer, {
299:   metadata: result.info
300: });
301: ```
302: 
303: ## System Optimization
304: 
305: ### Database Performance
306: 
307: ```typescript
308: // Use batch operations for multiple updates
309: const batch = db.batch();
310: updates.forEach(update => {
311:   const ref = db.collection('cards').doc(update.id);
312:   batch.update(ref, update.data);
313: });
314: await batch.commit();
315: ```
316: 
317: ### Resource Management
318: 
319: ```typescript
320: // Implement cleanup for large operations
321: async function cleanupResources(): Promise<void> {
322:   await imageCache.clear();
323:   global.gc && global.gc();
324: }
325: ```
326: 
327: ### Request Rate Management
328: 
329: ```typescript
330: const rateLimiter = {
331:   tokens: 100,
332:   refillRate: 10,
333:   interval: 1000,
334: 
335:   async acquire(): Promise<boolean> {
336:     if (this.tokens > 0) {
337:       this.tokens--;
338:       return true;
339:     }
340:     return false;
341:   }
342: };
343: ```
344: 
345: ## Security Controls
346: 
347: ### Input Validation
348: 
349: ```typescript
350: // Implement strict type checking
351: function validateSyncOptions(options: unknown): asserts options is SyncOptions {
352:   if (!options || typeof options !== "object") {
353:     throw new Error("Invalid options object");
354:   }
355: 
356:   const opts = options as Record<string, unknown>;
357:  
358:   if (opts.limit && typeof opts.limit !== "number") {
359:     throw new Error("Limit must be a number");
360:   }
361: 
362:   if (opts.groupId && typeof opts.groupId !== "string") {
363:     throw new Error("GroupId must be a string");
364:   }
365: }
366: ```
367: 
368: ### Authentication
369: 
370: ```typescript
371: // Verify Firebase authentication
372: async function verifyAuth(req: Request): Promise<void> {
373:   const token = req.headers.authorization?.split("Bearer ")[1];
374:   if (!token) {
375:     throw new Error("No authentication token provided");
376:   }
377: 
378:   try {
379:     await admin.auth().verifyIdToken(token);
380:   } catch (error) {
381:     throw new Error("Invalid authentication token");
382:   }
383: }
384: ```
385: 
386: ## Advanced Patterns
387: 
388: ### Custom Synchronization
389: 
390: ```typescript
391: // Implement custom sync logic
392: async function customSync<T extends BaseEntity>(
393:   fetcher: DataFetcher<T>,
394:   processor: DataProcessor<T>,
395:   options: SyncOptions
396: ): Promise<SyncMetadata> {
397:   const logger = new SyncLogger({
398:     type: "custom",
399:     ...options
400:   });
401: 
402:   await logger.start();
403:  
404:   try {
405:     const data = await fetcher.fetch();
406:     const processed = await processor.process(data);
407:     return {
408:       status: "success",
409:       processed: processed.length,
410:       timestamp: new Date()
411:     };
412:   } catch (error) {
413:     await logger.logError(error);
414:     throw error;
415:   } finally {
416:     await logger.finish();
417:   }
418: }
419: ```
420: 
421: ### Advanced Caching
422: 
423: ```typescript
424: // Implement hierarchical caching
425: class HierarchicalCache<T> {
426:   private l1Cache = new Map<string, T>();
427:   private l2Cache: LRUCache<string, T>;
428: 
429:   constructor(options: CacheOptions) {
430:     this.l2Cache = new LRUCache<string, T>({
431:       max: options.maxSize,
432:       ttl: options.ttl
433:     });
434:   }
435: 
436:   async get(key: string): Promise<T | undefined> {
437:     // Check L1 cache first
438:     const l1Result = this.l1Cache.get(key);
439:     if (l1Result) return l1Result;
440: 
441:     // Check L2 cache
442:     const l2Result = this.l2Cache.get(key);
443:     if (l2Result) {
444:       this.l1Cache.set(key, l2Result);
445:       return l2Result;
446:     }
447: 
448:     return undefined;
449:   }
450: }
451: ```
452: 
453: ### Advanced Batch Processing
454: 
455: ```typescript
456: // Implement adaptive batch sizing
457: class AdaptiveBatchProcessor {
458:   private optimalBatchSize: number = 100;
459:   private processingTimes: number[] = [];
460: 
461:   async processBatch<T>(
462:     items: T[],
463:     processor: (batch: T[]) => Promise<void>
464:   ): Promise<void> {
465:     for (let i = 0; i < items.length; i += this.optimalBatchSize) {
466:       const start = Date.now();
467:       const batch = items.slice(i, i + this.optimalBatchSize);
468:      
469:       await processor(batch);
470:      
471:       const duration = Date.now() - start;
472:       this.adjustBatchSize(duration);
473:     }
474:   }
475: 
476:   private adjustBatchSize(lastProcessingTime: number): void {
477:     this.processingTimes.push(lastProcessingTime);
478:     if (this.processingTimes.length >= 5) {
479:       const avgTime = this.calculateAverage(this.processingTimes);
480:       if (avgTime > 1000) {
481:         this.optimalBatchSize = Math.max(10, this.optimalBatchSize * 0.8);
482:       } else if (avgTime < 500) {
483:         this.optimalBatchSize = Math.min(1000, this.optimalBatchSize * 1.2);
484:       }
485:       this.processingTimes = [];
486:     }
487:   }
488: }
489: ```
490: 
491: ### Recovery Strategies
492: 
493: ```typescript
494: // Implement progressive retry with backoff
495: class RetryStrategy {
496:   private static readonly MAX_RETRIES = 3;
497:   private static readonly BASE_DELAY = 1000;
498: 
499:   async executeWithRetry<T>(
500:     operation: () => Promise<T>,
501:     context: string
502:   ): Promise<T> {
503:     let lastError: Error;
504:    
505:     for (let attempt = 0; attempt < RetryStrategy.MAX_RETRIES; attempt++) {
506:       try {
507:         return await operation();
508:       } catch (error) {
509:         lastError = error instanceof Error ? error : new Error(String(error));
510:         const delay = Math.pow(2, attempt) * RetryStrategy.BASE_DELAY;
511:        
512:         await logWarning(
513:           `Operation failed, attempting retry ${attempt + 1}/${RetryStrategy.MAX_RETRIES}`,
514:           { context, error: lastError.message }
515:         );
516:        
517:         await new Promise(resolve => setTimeout(resolve, delay));
518:       }
519:     }
520:    
521:     throw lastError!;
522:   }
523: }
524: ```
525: 
526: ## Reference Materials
527: 
528: ### CLI Commands
529: 
530: ```bash
531: # Build the project
532: npm run build
533: 
534: # Run linting
535: npm run lint
536: 
537: # Fix linting issues
538: npm run lint:fix
539: 
540: # Run tests
541: npm run test:images
542: 
543: # Deploy functions
544: npm run deploy
545: ```
546: 
547: ### Documentation Links
548: 
549: - [Architecture Overview](./architecture.md)
550: - [API Documentation](./api/index.md)
551: - [Troubleshooting Guide](./troubleshooting.md)
552: - [Security Guidelines](./security.md)
553: - [Performance Guide](./performance.md)
</file>

<file path="docs/utils/batch.md">
  1: # Batch Processing Utility
  2: 
  3: ## Overview
  4: 
  5: The Batch Processor (`batch.ts`) manages efficient processing of large data sets through controlled batching. It provides configurable batch sizes, concurrent processing, and progress tracking for synchronization operations.
  6: 
  7: ## Core Features
  8: 
  9: - Configurable batch sizes
 10: - Concurrent processing
 11: - Progress tracking
 12: - Error handling
 13: - Memory management
 14: - Rate limiting
 15: 
 16: ## Main Interfaces
 17: 
 18: ### Batch Options
 19: 
 20: ```typescript
 21: interface BatchOptions {
 22:   batchSize?: number;
 23:   concurrency?: number;
 24:   retries?: number;
 25:   backoff?: number;
 26:   onProgress?: (progress: BatchProgress) => void;
 27:   abortSignal?: AbortSignal;
 28: }
 29: ```
 30: 
 31: ### Progress Interface
 32: 
 33: ```typescript
 34: interface BatchProgress {
 35:   total: number;
 36:   processed: number;
 37:   failed: number;
 38:   currentBatch: number;
 39:   totalBatches: number;
 40:   percentage: number;
 41:   estimatedTimeRemaining?: number;
 42: }
 43: ```
 44: 
 45: ## Core Methods
 46: 
 47: ### Batch Processing
 48: 
 49: ```typescript
 50: export async function processBatch<T>(
 51:   items: T[],
 52:   processor: (batch: T[]) => Promise<void>,
 53:   options: BatchOptions = {}
 54: ): Promise<BatchResult> {
 55:   const {
 56:     batchSize = 100,
 57:     concurrency = 1,
 58:     retries = 3,
 59:     onProgress
 60:   } = options;
 61: 
 62:   const batches = chunk(items, batchSize);
 63:   let processed = 0;
 64:   let failed = 0;
 65: 
 66:   for (let i = 0; i < batches.length; i++) {
 67:     try {
 68:       await processor(batches[i]);
 69:       processed += batches[i].length;
 70:     } catch (error) {
 71:       failed += batches[i].length;
 72:       await handleBatchError(error, retries);
 73:     }
 74: 
 75:     if (onProgress) {
 76:       onProgress({
 77:         total: items.length,
 78:         processed,
 79:         failed,
 80:         currentBatch: i + 1,
 81:         totalBatches: batches.length,
 82:         percentage: (processed + failed) / items.length * 100
 83:       });
 84:     }
 85:   }
 86: 
 87:   return { processed, failed };
 88: }
 89: ```
 90: 
 91: ## Implementation Examples
 92: 
 93: ### Basic Usage
 94: 
 95: ```typescript
 96: const items = await fetchItems();
 97: const result = await processBatch(
 98:   items,
 99:   async (batch) => {
100:     await processItems(batch);
101:   },
102:   {
103:     batchSize: 50,
104:     onProgress: (progress) => {
105:       console.log(
106:         `Processed ${progress.processed}/${progress.total} items`
107:       );
108:     }
109:   }
110: );
111: ```
112: 
113: ### With Concurrency
114: 
115: ```typescript
116: const processConcurrentBatches = async <T>(
117:   items: T[],
118:   processor: (item: T) => Promise<void>
119: ): Promise<void> => {
120:   await processBatch(items, async (batch) => {
121:     await Promise.all(
122:       batch.map(item => processor(item))
123:     );
124:   }, {
125:     batchSize: 25,
126:     concurrency: 3
127:   });
128: };
129: ```
130: 
131: ## Error Management
132: 
133: ### Retry Logic
134: 
135: ```typescript
136: async function handleBatchError(
137:   error: unknown,
138:   retriesLeft: number,
139:   backoff: number = 1000
140: ): Promise<void> {
141:   if (retriesLeft <= 0) {
142:     throw error;
143:   }
144: 
145:   await new Promise(resolve => 
146:     setTimeout(resolve, backoff * (4 - retriesLeft))
147:   );
148:  
149:   return handleBatchError(
150:     error,
151:     retriesLeft - 1,
152:     backoff
153:   );
154: }
155: ```
156: 
157: ### Error Collection
158: 
159: ```typescript
160: interface BatchError {
161:   batchIndex: number;
162:   items: unknown[];
163:   error: Error;
164: }
165: 
166: const collectErrors = async <T>(
167:   items: T[],
168:   processor: (batch: T[]) => Promise<void>
169: ): Promise<BatchError[]> => {
170:   const errors: BatchError[] = [];
171:  
172:   await processBatch(items, async (batch, index) => {
173:     try {
174:       await processor(batch);
175:     } catch (error) {
176:       errors.push({
177:         batchIndex: index,
178:         items: batch,
179:         error: error instanceof Error ? error : new Error(String(error))
180:       });
181:     }
182:   });
183: 
184:   return errors;
185: };
186: ```
187: 
188: ## Memory Management
189: 
190: ### Chunking Function
191: 
192: ```typescript
193: function chunk<T>(
194:   items: T[], 
195:   size: number
196: ): T[][] {
197:   const chunks: T[][] = [];
198:  
199:   for (let i = 0; i < items.length; i += size) {
200:     chunks.push(items.slice(i, i + size));
201:   }
202:  
203:   return chunks;
204: }
205: ```
206: 
207: ### Resource Cleanup
208: 
209: ```typescript
210: async function processWithCleanup<T>(
211:   items: T[],
212:   processor: (batch: T[]) => Promise<void>
213: ): Promise<void> {
214:   let currentBatch: T[] = [];
215:  
216:   try {
217:     await processBatch(items, async (batch) => {
218:       currentBatch = batch;
219:       await processor(batch);
220:       currentBatch = [];
221:     });
222:   } finally {
223:     currentBatch = [];
224:   }
225: }
226: ```
227: 
228: ## Progress Tracking
229: 
230: ### Progress Calculator
231: 
232: ```typescript
233: function calculateProgress(
234:   processed: number,
235:   total: number,
236:   startTime: number
237: ): BatchProgress {
238:   const elapsed = Date.now() - startTime;
239:   const rate = processed / (elapsed / 1000);
240:   const remaining = total - processed;
241:  
242:   return {
243:     processed,
244:     total,
245:     percentage: (processed / total) * 100,
246:     estimatedTimeRemaining: remaining / rate
247:   };
248: }
249: ```
250: 
251: ## Best Practices
252: 
253: ### Batch Size Selection
254: 
255: - Consider memory constraints
256: - Balance throughput and overhead
257: - Monitor processing times
258: 
259: ### Error Handling
260: 
261: - Implement proper retries
262: - Log batch failures
263: - Maintain item context
264: 
265: ### Resource Management
266: 
267: - Clean up after processing
268: - Monitor memory usage
269: - Handle aborted operations
270: 
271: ## Related Components
272: 
273: - [Progress Tracker](./progress)
274: - [Error Handler](./error-handling)
275: - [Logger](./logging)
276: 
277: ## Troubleshooting
278: 
279: ### Common Issues
280: 
281: 1. Memory Problems:
282:    - Reduce batch size
283:    - Implement cleanup
284:    - Monitor heap usage
285: 
286: 2. Performance Issues:
287:    - Adjust concurrency
288:    - Optimize batch size
289:    - Monitor processing rates
290: 
291: 3. Error Handling:
292:    - Check retry logic
293:    - Verify error collection
294:    - Monitor failure patterns
</file>

<file path="docs/utils/cache.md">
  1: # Cache System
  2: 
  3: ## Overview
  4: 
  5: The Cache System provides efficient memory caching for card data, prices, and images. It implements an LRU (Least Recently Used) caching strategy and includes specialized caching for different data types.
  6: 
  7: ## Components
  8: 
  9: The system consists of two main cache implementations:
 10: 
 11: 1. Basic LRU Cache (`cache.ts`)
 12: 2. Specialized Image Cache (`imageCache.ts`)
 13: 
 14: ## Basic Cache Implementation
 15: 
 16: ### Configuration
 17: 
 18: ```typescript
 19: const options = {
 20:   max: 500,                // Maximum number of items
 21:   ttl: 1000 * 60 * 60,    // Time to live: 1 hour
 22: };
 23: 
 24: export const cardCache = new LRUCache<string, CardProduct>(options);
 25: ```
 26: 
 27: ### Basic Key Generation
 28: 
 29: ```typescript
 30: export type CacheType = "card" | "price" | "image";
 31: 
 32: export const getCacheKey = (type: CacheType, id: number): string => {
 33:   return `${type}:${id}`;
 34: };
 35: ```
 36: 
 37: ## Image Cache Implementation
 38: 
 39: ### Class Structure
 40: 
 41: ```typescript
 42: export class ImageCache {
 43:   private metadataCache: LRUCache<string, ImageMetadata>;
 44:   private bufferCache: LRUCache<string, Buffer>;
 45:   private existsCache: LRUCache<string, boolean>;
 46:   private stats: CacheStats;
 47: }
 48: ```
 49: 
 50: ### Cache Configuration
 51: 
 52: ```typescript
 53: constructor() {
 54:   this.metadataCache = new LRUCache<string, ImageMetadata>({
 55:     max: 1000,
 56:     ttl: 1000 * 60 * 60,  // 1 hour
 57:     updateAgeOnGet: true,
 58:   });
 59: 
 60:   this.bufferCache = new LRUCache<string, Buffer>({
 61:     max: 100,
 62:     ttl: 1000 * 60 * 5,   // 5 minutes
 63:     updateAgeOnGet: true,
 64:     maxSize: 50 * 1024 * 1024,  // 50MB max cache size
 65:     sizeCalculation: (buffer) => buffer.length,
 66:   });
 67: 
 68:   this.existsCache = new LRUCache<string, boolean>({
 69:     max: 1000,
 70:     ttl: 1000 * 60 * 60,  // 1 hour
 71:     updateAgeOnGet: true,
 72:   });
 73: }
 74: ```
 75: 
 76: ## Usage Examples
 77: 
 78: ### Basic Cache Usage
 79: 
 80: ```typescript
 81: // Store card data
 82: const cardId = 477236;
 83: const cacheKey = getCacheKey("card", cardId);
 84: cardCache.set(cacheKey, cardData);
 85: 
 86: // Retrieve card data
 87: const cachedCard = cardCache.get(cacheKey);
 88: if (cachedCard) {
 89:   return cachedCard;
 90: }
 91: ```
 92: 
 93: ### Image Cache Usage
 94: 
 95: ```typescript
 96: const imageCache = new ImageCache();
 97: 
 98: // Get metadata
 99: const metadataKey = imageCache.getMetadataCacheKey(groupId, productId, false);
100: const metadata = await imageCache.getMetadata(metadataKey);
101: 
102: // Get image buffer
103: const bufferKey = imageCache.getBufferCacheKey(imageUrl);
104: const buffer = await imageCache.getBuffer(bufferKey);
105: 
106: // Check existence
107: const existsKey = imageCache.getExistsCacheKey(groupId, productId, false);
108: const exists = imageCache.getExists(existsKey);
109: ```
110: 
111: ## Image Cache Key Types
112: 
113: ### Metadata Keys
114: 
115: ```typescript
116: getMetadataCacheKey(
117:   groupId: string,
118:   productId: number,
119:   isHighRes: boolean
120: ): string {
121:   return `metadata:${groupId}:${productId}:${isHighRes ? "high" : "original"}`;
122: }
123: ```
124: 
125: ### Buffer Keys
126: 
127: ```typescript
128: getBufferCacheKey(url: string): string {
129:   return `buffer:${url}`;
130: }
131: ```
132: 
133: ### Existence Check Keys
134: 
135: ```typescript
136: getExistsCacheKey(
137:   groupId: string,
138:   productId: number,
139:   isHighRes: boolean
140: ): string {
141:   return `exists:${groupId}:${productId}:${isHighRes ? "high" : "original"}`;
142: }
143: ```
144: 
145: ## Statistics Tracking
146: 
147: ```typescript
148: interface CacheStats {
149:   hits: number;
150:   misses: number;
151:   totalRequests: number;
152: }
153: 
154: getStats(): CacheStats {
155:   return {...this.stats};
156: }
157: ```
158: 
159: ## Cache Management
160: 
161: ### Clearing Cache
162: 
163: ```typescript
164: clear(): void {
165:   this.metadataCache.clear();
166:   this.bufferCache.clear();
167:   this.existsCache.clear();
168:   this.stats = {
169:     hits: 0,
170:     misses: 0,
171:     totalRequests: 0,
172:   };
173: }
174: ```
175: 
176: ### Performance Monitoring
177: 
178: ```typescript
179: async getMetadata(key: string): Promise<ImageMetadata | undefined> {
180:   this.stats.totalRequests++;
181:   const value = this.metadataCache.get(key);
182:   if (value) {
183:     this.stats.hits++;
184:     await logInfo("Cache hit: metadata", {
185:       key,
186:       timestamp: new Date().toISOString(),
187:     });
188:   } else {
189:     this.stats.misses++;
190:   }
191:   return value;
192: }
193: ```
194: 
195: ## Best Practices
196: 
197: 1. **Memory Management**:
198:    - Set appropriate cache sizes
199:    - Monitor memory usage
200:    - Implement TTL for all cached items
201: 
202: 2. **Performance Optimization**:
203:    - Use buffer cache for frequently accessed images
204:    - Implement size limits for buffer cache
205:    - Track cache statistics
206: 
207: 3. **Error Handling**:
208:    - Graceful degradation on cache misses
209:    - Monitor cache hit rates
210:    - Log cache operations
211: 
212: ## Troubleshooting
213: 
214: ### Common Issues
215: 
216: 1. Memory Usage:
217:    - Monitor cache size
218:    - Adjust max entries
219:    - Check TTL settings
220: 
221: 2. Cache Misses:
222:    - Verify key generation
223:    - Check TTL values
224:    - Monitor hit rates
225: 
226: 3. Performance:
227:    - Analyze cache stats
228:    - Adjust cache sizes
229:    - Optimize key generation
230: 
231: ## Related Components
232: 
233: - [Image Handler](./image-handler)
234: - [Logger](./logging)
235: - [Error Handling](./error-handling)
</file>

<file path="docs/utils/error-handling.md">
  1: # Error Handling System
  2: 
  3: ## Overview
  4: 
  5: The Error Handling system (`error.ts`) provides a standardized approach to error management across the application. It includes error classification, detailed logging, and integration with the logging system for comprehensive error tracking.
  6: 
  7: ## Features
  8: 
  9: - Custom error types
 10: - Detailed error reporting
 11: - Error severity levels
 12: - Metadata support
 13: - Firestore integration
 14: - Stack trace preservation
 15: 
 16: ## Core Components
 17: 
 18: ### Error Types
 19: 
 20: ```typescript
 21: export interface ErrorReport {
 22:   timestamp: Date;
 23:   context: string;
 24:   error: string;
 25:   stackTrace?: string;
 26:   metadata?: Record<string, unknown>;
 27:   severity: "ERROR" | "WARNING" | "CRITICAL";
 28: }
 29: 
 30: export class DetailedError extends Error {
 31:   constructor(
 32:     message: string,
 33:     public context: string,
 34:     public metadata?: Record<string, unknown>,
 35:     public severity: "ERROR" | "WARNING" | "CRITICAL" = "ERROR"
 36:   ) {
 37:     super(message);
 38:     this.name = "DetailedError";
 39:   }
 40: }
 41: ```
 42: 
 43: ## Error Logging
 44: 
 45: ### Basic Error Logging
 46: 
 47: ```typescript
 48: export async function logDetailedError(
 49:   error: Error,
 50:   context: string,
 51:   metadata?: Record<string, unknown>,
 52:   severity: "ERROR" | "WARNING" | "CRITICAL" = "ERROR"
 53: ): Promise<void> {
 54:   const report: ErrorReport = {
 55:     timestamp: new Date(),
 56:     context,
 57:     error: error.message,
 58:     stackTrace: error.stack,
 59:     metadata,
 60:     severity,
 61:   };
 62: 
 63:   await db.collection(COLLECTION.LOGS).add(report);
 64:   await logError(error, context);
 65: }
 66: ```
 67: 
 68: ## Usage Examples
 69: 
 70: ### Basic Error Handling
 71: 
 72: ```typescript
 73: try {
 74:   await processImage(imageUrl);
 75: } catch (error) {
 76:   await logDetailedError(
 77:     error as Error,
 78:     "imageProcessing",
 79:     { imageUrl, timestamp: new Date() },
 80:     "ERROR"
 81:   );
 82: }
 83: ```
 84: 
 85: ### Custom Error Creation
 86: 
 87: ```typescript
 88: const handleImageError = async (error: unknown, imageUrl: string) => {
 89:   const detailedError = new DetailedError(
 90:     "Image processing failed",
 91:     "imageHandler:process",
 92:     {
 93:       imageUrl,
 94:       originalError: error instanceof Error ? error.message : "Unknown error",
 95:       timestamp: new Date().toISOString()
 96:     },
 97:     "ERROR"
 98:   );
 99: 
100:   await logDetailedError(detailedError, detailedError.context);
101: };
102: ```
103: 
104: ## Error Classification
105: 
106: ### Severity Levels
107: 
108: ```typescript
109: type ErrorSeverity = "ERROR" | "WARNING" | "CRITICAL";
110: 
111: const determineSeverity = (error: Error): ErrorSeverity => {
112:   if (error instanceof NetworkError) return "WARNING";
113:   if (error instanceof DataCorruptionError) return "CRITICAL";
114:   return "ERROR";
115: };
116: ```
117: 
118: ### Context Management
119: 
120: ```typescript
121: interface ErrorContext {
122:   component: string;
123:   operation: string;
124:   metadata?: Record<string, unknown>;
125: }
126: 
127: const createErrorContext = (
128:   component: string,
129:   operation: string,
130:   metadata?: Record<string, unknown>
131: ): ErrorContext => ({
132:   component,
133:   operation,
134:   metadata
135: });
136: ```
137: 
138: ## Best Practices
139: 
140: ### 1. Error Wrapping
141: 
142: ```typescript
143: try {
144:   await externalOperation();
145: } catch (error) {
146:   const wrappedError = new DetailedError(
147:     "External operation failed",
148:     "externalService:operation",
149:     {
150:       originalError: error instanceof Error ? error.message : "Unknown error",
151:       timestamp: new Date().toISOString()
152:     }
153:   );
154:   throw wrappedError;
155: }
156: ```
157: 
158: ### 2. Error Recovery
159: 
160: ```typescript
161: async function withErrorRecovery<T>(
162:   operation: () => Promise<T>,
163:   fallback: T,
164:   context: string
165: ): Promise<T> {
166:   try {
167:     return await operation();
168:   } catch (error) {
169:     await logDetailedError(
170:       error as Error,
171:       context,
172:       { recoveryAction: "using fallback" }
173:     );
174:     return fallback;
175:   }
176: }
177: ```
178: 
179: ### 3. Batch Error Handling
180: 
181: ```typescript
182: interface BatchError {
183:   index: number;
184:   error: Error;
185:   item: unknown;
186: }
187: 
188: async function processBatchWithErrors<T>(
189:   items: T[],
190:   processor: (item: T) => Promise<void>
191: ): Promise<BatchError[]> {
192:   const errors: BatchError[] = [];
193: 
194:   for (let i = 0; i < items.length; i++) {
195:     try {
196:       await processor(items[i]);
197:     } catch (error) {
198:       errors.push({
199:         index: i,
200:         error: error as Error,
201:         item: items[i]
202:       });
203:     }
204:   }
205: 
206:   return errors;
207: }
208: ```
209: 
210: ## Error Monitoring
211: 
212: ### Error Aggregation
213: 
214: ```typescript
215: interface ErrorAggregate {
216:   count: number;
217:   lastOccurrence: Date;
218:   contexts: string[];
219: }
220: 
221: const aggregateErrors = async (
222:   timeWindow: number
223: ): Promise<Map<string, ErrorAggregate>> => {
224:   const now = new Date();
225:   const windowStart = new Date(now.getTime() - timeWindow);
226: 
227:   const errors = await db
228:     .collection(COLLECTION.LOGS)
229:     .where("timestamp", ">=", windowStart)
230:     .where("level", "==", "ERROR")
231:     .get();
232: 
233:   return errors.docs.reduce((acc, doc) => {
234:     const data = doc.data();
235:     const key = data.error;
236:     const existing = acc.get(key) || {
237:       count: 0,
238:       lastOccurrence: windowStart,
239:       contexts: []
240:     };
241: 
242:     existing.count++;
243:     existing.lastOccurrence = data.timestamp.toDate();
244:     if (!existing.contexts.includes(data.context)) {
245:       existing.contexts.push(data.context);
246:     }
247: 
248:     acc.set(key, existing);
249:     return acc;
250:   }, new Map<string, ErrorAggregate>());
251: };
252: ```
253: 
254: ## Error Resolution
255: 
256: ### Automatic Recovery
257: 
258: ```typescript
259: async function attemptRecovery(
260:   error: DetailedError,
261:   maxAttempts: number = 3
262: ): Promise<boolean> {
263:   let attempts = 0;
264:   let recovered = false;
265: 
266:   while (attempts < maxAttempts && !recovered) {
267:     try {
268:       await recoveryStrategies[error.name]?.(error);
269:       recovered = true;
270:     } catch (recoveryError) {
271:       attempts++;
272:       await logWarning(
273:         `Recovery attempt ${attempts} failed`,
274:         { error: recoveryError }
275:       );
276:     }
277:   }
278: 
279:   return recovered;
280: }
281: ```
282: 
283: ## Related Components
284: 
285: - [Logger](./logging)
286: - [Sync Logger](./sync-logger)
287: - [Image Handler](./image-handler)
288: 
289: ## Troubleshooting
290: 
291: ### Common Issues
292: 
293: 1. Missing Error Context:
294:    - Ensure proper error wrapping
295:    - Include relevant metadata
296:    - Use appropriate error types
297: 
298: 2. Error Recovery:
299:    - Implement fallback mechanisms
300:    - Use appropriate retry strategies
301:    - Monitor recovery success rates
302: 
303: 3. Performance Impact:
304:    - Balance logging detail with performance
305:    - Implement error aggregation
306:    - Use appropriate severity levels
</file>

<file path="docs/utils/image-compressor.md">
  1: # Image Compressor Utility
  2: 
  3: ## Overview
  4: 
  5: The Image Compressor (`imageCompressor.ts`) handles image optimization and compression for card images. It provides configurable compression settings for both standard and high-resolution images while maintaining image quality.
  6: 
  7: ## Core Features
  8: 
  9: - Dual resolution support (200w/400w)
 10: - Quality-preserving compression
 11: - Dimension optimization
 12: - Progressive JPEG support
 13: - Metadata preservation
 14: - Compression statistics
 15: 
 16: ## Configuration
 17: 
 18: ### Quality Settings
 19: 
 20: ```typescript
 21: private static readonly QUALITY = {
 22:   HIGH_RES: 90,
 23:   LOW_RES: 85,
 24: };
 25: ```
 26: 
 27: ### Dimension Settings
 28: 
 29: ```typescript
 30: private static readonly DIMENSIONS = {
 31:   HIGH_RES: 400,
 32:   LOW_RES: 200,
 33: };
 34: ```
 35: 
 36: ## Main Interfaces
 37: 
 38: ### Compression Result
 39: 
 40: ```typescript
 41: export interface CompressionResult {
 42:   buffer: Buffer;
 43:   info: {
 44:     width: number;
 45:     height: number;
 46:     size: number;
 47:     format: string;
 48:     quality: number;
 49:   };
 50: }
 51: ```
 52: 
 53: ## Primary Methods
 54: 
 55: ### Compression Method
 56: 
 57: ```typescript
 58: static async compress(
 59:   buffer: Buffer,
 60:   isHighRes: boolean = false
 61: ): Promise<CompressionResult>
 62: ```
 63: 
 64: ### Format Validation
 65: 
 66: ```typescript
 67: static async isCompressible(buffer: Buffer): Promise<boolean>
 68: ```
 69: 
 70: ## Implementation Examples
 71: 
 72: ### Basic Compression
 73: 
 74: ```typescript
 75: const imageBuffer = await fetchImage(url);
 76: const result = await ImageCompressor.compress(imageBuffer, false);
 77: 
 78: console.log("Compression stats:", {
 79:   originalSize: imageBuffer.length,
 80:   compressedSize: result.buffer.length,
 81:   dimensions: `${result.info.width}x${result.info.height}`,
 82:   quality: result.info.quality
 83: });
 84: ```
 85: 
 86: ### High-Resolution Processing
 87: 
 88: ```typescript
 89: const highResResult = await ImageCompressor.compress(buffer, true);
 90: await logInfo("High-res compression complete", {
 91:   originalSize: buffer.length,
 92:   compressedSize: highResResult.buffer.length,
 93:   dimensions: `${highResResult.info.width}x${highResResult.info.height}`,
 94:   quality: highResResult.info.quality
 95: });
 96: ```
 97: 
 98: ## Compression Pipeline
 99: 
100: ### Image Analysis
101: 
102: ```typescript
103: const originalInfo = await sharp(buffer).metadata();
104: const originalSize = buffer.length;
105: ```
106: 
107: ### Optimization Process
108: 
109: ```typescript
110: const image = sharp(buffer).jpeg({
111:   quality,
112:   progressive: true,
113:   mozjpeg: true,
114: });
115: 
116: if (originalInfo.width && originalInfo.width > targetWidth) {
117:   image.resize(targetWidth, null, {
118:     fit: "inside",
119:     withoutEnlargement: true,
120:   });
121: }
122: ```
123: 
124: ## Performance Monitoring
125: 
126: ### Size Reduction Tracking
127: 
128: ```typescript
129: const compressionStats = {
130:   originalSize: buffer.length,
131:   compressedSize: compressedBuffer.length,
132:   reductionPercent: (
133:     (buffer.length - compressedBuffer.length) / 
134:     buffer.length * 100
135:   ).toFixed(2)
136: };
137: ```
138: 
139: ### Quality Metrics
140: 
141: ```typescript
142: const qualityMetrics = {
143:   dimensions: `${compressedInfo.width}x${compressedInfo.height}`,
144:   format: compressedInfo.format,
145:   quality: isHighRes ? QUALITY.HIGH_RES : QUALITY.LOW_RES
146: };
147: ```
148: 
149: ## Best Practices
150: 
151: ### Memory Management
152: 
153: - Process one image at a time
154: - Release buffers after processing
155: - Monitor memory usage
156: 
157: ### Quality Control
158: 
159: - Use appropriate quality settings
160: - Validate output dimensions
161: - Check compression ratios
162: 
163: ### Error Prevention
164: 
165: - Validate input formats
166: - Check buffer integrity
167: - Monitor compression results
168: 
169: ## Usage Guidelines
170: 
171: ### Standard Resolution
172: 
173: ```typescript
174: const standardResult = await ImageCompressor.compress(buffer);
175: if (standardResult.buffer.length > buffer.length) {
176:   // Use original if compression didn't help
177:   return buffer;
178: }
179: ```
180: 
181: ### High Resolution
182: 
183: ```typescript
184: const highResResult = await ImageCompressor.compress(buffer, true);
185: if (!highResResult.info.width || highResResult.info.width < 400) {
186:   throw new Error("High-res compression failed to meet size requirements");
187: }
188: ```
189: 
190: ## Error Handling
191: 
192: ### Input Validation
193: 
194: ```typescript
195: if (!buffer || buffer.length === 0) {
196:   throw new Error("Invalid input buffer");
197: }
198: 
199: if (!await ImageCompressor.isCompressible(buffer)) {
200:   throw new Error("Unsupported image format");
201: }
202: ```
203: 
204: ### Processing Errors
205: 
206: ```typescript
207: try {
208:   return await ImageCompressor.compress(buffer);
209: } catch (error) {
210:   throw new Error(
211:     `Image compression failed: ${
212:       error instanceof Error ? error.message : "Unknown error"
213:     }`
214:   );
215: }
216: ```
217: 
218: ## Related Components
219: 
220: - [Image Handler](./image-handler)
221: - [Image Validator](./image-validator)
222: - [Logger](./logging)
223: 
224: ## Troubleshooting
225: 
226: ### Common Issues
227: 
228: 1. Memory Constraints:
229:    - Monitor buffer sizes
230:    - Process images sequentially
231:    - Implement garbage collection
232: 
233: 2. Quality Problems:
234:    - Verify quality settings
235:    - Check dimension constraints
236:    - Validate output formats
237: 
238: 3. Performance Issues:
239:    - Monitor processing times
240:    - Track compression ratios
241:    - Optimize batch processing
</file>

<file path="docs/utils/image-handler.md">
  1: # Image Handler Utility
  2: 
  3: ## Overview
  4: 
  5: The Image Handler (`imageHandler.ts`) is a comprehensive utility for managing card images. It handles downloading, processing, compression, caching, and storage of both standard and high-resolution card images in Firebase Storage.
  6: 
  7: ## Features
  8: 
  9: - Dual resolution support (200w and 400w)
 10: - Image compression and optimization
 11: - Caching system
 12: - Hash-based change detection
 13: - Error handling and retry logic
 14: - Storage path management
 15: - Metadata tracking
 16: 
 17: ## Class Structure
 18: 
 19: ```typescript
 20: export class ImageHandler {
 21:   private bucket = storage.bucket(STORAGE.BUCKETS.CARD_IMAGES);
 22:  
 23:   // Main method
 24:   async processImage(
 25:     imageUrl: string,
 26:     groupId: string,
 27:     productId: number
 28:   ): Promise<ImageProcessingResult>
 29: }
 30: ```
 31: 
 32: ## Core Methods
 33: 
 34: ### Process Image
 35: 
 36: ```typescript
 37: async processImage(
 38:   imageUrl: string,
 39:   groupId: string,
 40:   productId: number
 41: ): Promise<ImageProcessingResult>
 42: ```
 43: 
 44: #### Parameters
 45: 
 46: - `imageUrl`: Source URL of the card image
 47: - `groupId`: Card group identifier
 48: - `productId`: Unique card identifier
 49: 
 50: #### Returns
 51: 
 52: ```typescript
 53: interface ImageProcessingResult {
 54:   originalUrl: string;      // URL of standard resolution image
 55:   highResUrl: string;       // URL of high resolution image
 56:   metadata: ImageMetadata;  // Image processing metadata
 57:   updated: boolean;         // Whether image was updated
 58: }
 59: ```
 60: 
 61: ### Image Processing Pipeline
 62: 
 63: 1. **URL Processing**:
 64: 
 65: ```typescript
 66: private getHighResUrl(imageUrl: string): string {
 67:   return imageUrl.replace(/_200w\.jpg$/, "_400w.jpg");
 68: }
 69: ```
 70: 
 71: 1. **Storage Path Management**:
 72: 
 73: ```typescript
 74: private getStoragePath(
 75:   groupId: string,
 76:   productId: number,
 77:   isHighRes: boolean = false
 78: ): string {
 79:   const suffix = isHighRes ? "_400w" : "_200w";
 80:   return `${STORAGE.PATHS.IMAGES}/${groupId}/${productId}${suffix}.jpg`;
 81: }
 82: ```
 83: 
 84: 1. **Image Download**:
 85: 
 86: ```typescript
 87: private async downloadImage(url: string): Promise<Buffer>
 88: ```
 89: 
 90: 1. **Image Compression**:
 91: 
 92: ```typescript
 93: private async compressImage(
 94:   buffer: Buffer,
 95:   isHighRes: boolean
 96: ): Promise<Buffer>
 97: ```
 98: 
 99: ## Configuration
100: 
101: ### Storage Settings
102: 
103: ```typescript
104: export const STORAGE = {
105:   BUCKETS: {
106:     CARD_IMAGES: "fftcg-sync-service.firebasestorage.app",
107:   },
108:   PATHS: {
109:     IMAGES: "card-images",
110:   },
111: };
112: ```
113: 
114: ### Compression Settings
115: 
116: ```typescript
117: private static readonly QUALITY = {
118:   HIGH_RES: 90,
119:   LOW_RES: 85,
120: };
121: 
122: private static readonly DIMENSIONS = {
123:   HIGH_RES: 400,
124:   LOW_RES: 200,
125: };
126: ```
127: 
128: ## Usage Examples
129: 
130: ### Basic Image Processing
131: 
132: ```typescript
133: const imageHandler = new ImageHandler();
134: 
135: const result = await imageHandler.processImage(
136:   "https://tcgplayer-cdn.tcgplayer.com/product/477236_200w.jpg",
137:   "23783",
138:   477236
139: );
140: 
141: console.log("Image URLs:", {
142:   original: result.originalUrl,
143:   highRes: result.highResUrl
144: });
145: ```
146: 
147: ### With Error Handling
148: 
149: ```typescript
150: try {
151:   const imageHandler = new ImageHandler();
152:   const result = await imageHandler.processImage(imageUrl, groupId, productId);
153:  
154:   if (result.updated) {
155:     console.log("Image updated successfully");
156:     console.log("Metadata:", result.metadata);
157:   }
158: } catch (error) {
159:   console.error("Image processing failed:", error);
160: }
161: ```
162: 
163: ## Metadata Management
164: 
165: ### Metadata Structure
166: 
167: ```typescript
168: interface ImageMetadata {
169:   contentType: string;
170:   size: number;
171:   updated: Date;
172:   hash: string;
173:   originalUrl: string;
174:   highResUrl: string;
175:   originalSize?: number;
176:   highResSize?: number;
177: }
178: ```
179: 
180: ### Saving Metadata
181: 
182: ```typescript
183: private async saveMetadata(
184:   groupId: string,
185:   productId: number,
186:   metadata: ImageMetadata
187: ): Promise<void>
188: ```
189: 
190: ## Cache Integration
191: 
192: The Image Handler integrates with the caching system for improved performance:
193: 
194: ```typescript
195: const cacheKey = imageCache.getBufferCacheKey(url);
196: const cachedBuffer = await imageCache.getBuffer(cacheKey);
197: 
198: if (cachedBuffer) {
199:   return cachedBuffer;
200: }
201: ```
202: 
203: ## Error Handling
204: 
205: ### Error Types
206: 
207: ```typescript
208: interface ImageProcessingError extends GenericError {
209:   productId: number;
210:   groupId: string;
211:   originalUrl: string;
212:   type: "download" | "upload" | "metadata" | "unknown";
213: }
214: ```
215: 
216: ### Error Recovery
217: 
218: ```typescript
219: catch (error) {
220:   return {
221:     originalUrl: imageUrl,
222:     highResUrl: this.getHighResUrl(imageUrl),
223:     metadata: {
224:       contentType: "image/jpeg",
225:       size: 0,
226:       updated: new Date(),
227:       hash: "",
228:       originalUrl: imageUrl,
229:       highResUrl: this.getHighResUrl(imageUrl),
230:     },
231:     updated: false,
232:   };
233: }
234: ```
235: 
236: ## Best Practices
237: 
238: 1. **Memory Management**:
239:    - Process one resolution at a time
240:    - Use streams for large files
241:    - Implement proper cleanup
242: 
243: 2. **Error Handling**:
244:    - Implement retries for transient failures
245:    - Log detailed error information
246:    - Maintain fallback URLs
247: 
248: 3. **Performance**:
249:    - Utilize caching effectively
250:    - Implement batch processing
251:    - Monitor storage quotas
252: 
253: ## Related Components
254: 
255: - [Image Cache](./cache)
256: - [Image Compressor](./image-compressor)
257: - [Image Validator](./image-validator)
258: - [Logger](./logging)
</file>

<file path="docs/utils/image-validator.md">
  1: # Image Validator Utility
  2: 
  3: ## Overview
  4: 
  5: The Image Validator (`imageValidator.ts`) ensures image integrity and conformance to required specifications before processing. It validates format, dimensions, file size, and other critical image attributes.
  6: 
  7: ## Core Features
  8: 
  9: - Format validation
 10: - Dimension verification
 11: - Size limit enforcement
 12: - Metadata validation
 13: - URL structure validation
 14: - MIME type checking
 15: 
 16: ## Configuration
 17: 
 18: ### Size Limits
 19: 
 20: ```typescript
 21: export const IMAGE_LIMITS = {
 22:   MAX_SIZE: 10 * 1024 * 1024,  // 10MB
 23:   MIN_SIZE: 1024,              // 1KB
 24:   MAX_WIDTH: 2048,
 25:   MAX_HEIGHT: 2048,
 26:   MIN_WIDTH: 100,
 27:   MIN_HEIGHT: 100,
 28: };
 29: ```
 30: 
 31: ### Format Settings
 32: 
 33: ```typescript
 34: export const SUPPORTED_FORMATS = [
 35:   "image/jpeg",
 36:   "image/jpg",
 37:   "image/png"
 38: ] as const;
 39: 
 40: export const REQUIRED_DIMENSIONS = {
 41:   STANDARD: {
 42:     width: 200,
 43:     height: 200
 44:   },
 45:   HIGH_RES: {
 46:     width: 400,
 47:     height: 400
 48:   }
 49: };
 50: ```
 51: 
 52: ## Validation Methods
 53: 
 54: ### URL Pattern Check
 55: 
 56: ```typescript
 57: export function isValidImageUrl(url: string): boolean {
 58:   const pattern = /^https:\/\/.*\.(jpg|jpeg|png)(\?.*)?$/i;
 59:   return pattern.test(url);
 60: }
 61: ```
 62: 
 63: ### Format Verification
 64: 
 65: ```typescript
 66: export async function isValidFormat(
 67:   buffer: Buffer
 68: ): Promise<boolean> {
 69:   try {
 70:     const metadata = await sharp(buffer).metadata();
 71:     return SUPPORTED_FORMATS.includes(
 72:       `image/${metadata.format}` as typeof SUPPORTED_FORMATS[number]
 73:     );
 74:   } catch {
 75:     return false;
 76:   }
 77: }
 78: ```
 79: 
 80: ## Implementation Examples
 81: 
 82: ### Basic Validation
 83: 
 84: ```typescript
 85: const validator = new ImageValidator();
 86: 
 87: try {
 88:   await validator.validate(imageBuffer);
 89:   console.log("Image validation successful");
 90: } catch (error) {
 91:   console.error("Validation failed:", error.message);
 92: }
 93: ```
 94: 
 95: ### URL Validation
 96: 
 97: ```typescript
 98: const isValid = validator.validateUrl(imageUrl);
 99: if (!isValid) {
100:   throw new Error(`Invalid image URL: ${imageUrl}`);
101: }
102: ```
103: 
104: ## Validation Pipeline
105: 
106: ### Size Check
107: 
108: ```typescript
109: private async validateSize(buffer: Buffer): Promise<void> {
110:   const size = buffer.length;
111:  
112:   if (size > IMAGE_LIMITS.MAX_SIZE) {
113:     throw new Error(
114:       `Image size ${size} exceeds maximum limit of ${IMAGE_LIMITS.MAX_SIZE}`
115:     );
116:   }
117:  
118:   if (size < IMAGE_LIMITS.MIN_SIZE) {
119:     throw new Error(
120:       `Image size ${size} below minimum requirement of ${IMAGE_LIMITS.MIN_SIZE}`
121:     );
122:   }
123: }
124: ```
125: 
126: ### Dimension Check
127: 
128: ```typescript
129: private async validateDimensions(
130:   metadata: sharp.Metadata
131: ): Promise<void> {
132:   const { width, height } = metadata;
133:  
134:   if (!width || !height) {
135:     throw new Error("Unable to determine image dimensions");
136:   }
137:  
138:   if (width > IMAGE_LIMITS.MAX_WIDTH || height > IMAGE_LIMITS.MAX_HEIGHT) {
139:     throw new Error("Image dimensions exceed maximum limits");
140:   }
141:  
142:   if (width < IMAGE_LIMITS.MIN_WIDTH || height < IMAGE_LIMITS.MIN_HEIGHT) {
143:     throw new Error("Image dimensions below minimum requirements");
144:   }
145: }
146: ```
147: 
148: ## Utility Functions
149: 
150: ### Metadata Extraction
151: 
152: ```typescript
153: async function getImageMetadata(
154:   buffer: Buffer
155: ): Promise<sharp.Metadata> {
156:   try {
157:     return await sharp(buffer).metadata();
158:   } catch (error) {
159:     throw new Error("Failed to extract image metadata");
160:   }
161: }
162: ```
163: 
164: ### Resolution Check
165: 
166: ```typescript
167: function isValidResolution(
168:   width: number,
169:   height: number,
170:   isHighRes: boolean
171: ): boolean {
172:   const requirements = isHighRes ? 
173:     REQUIRED_DIMENSIONS.HIGH_RES : 
174:     REQUIRED_DIMENSIONS.STANDARD;
175:    
176:   return width >= requirements.width && 
177:          height >= requirements.height;
178: }
179: ```
180: 
181: ## Error Messages
182: 
183: ### Custom Validation Errors
184: 
185: ```typescript
186: export class ImageValidationError extends Error {
187:   constructor(
188:     message: string,
189:     public code: string,
190:     public details?: Record<string, unknown>
191:   ) {
192:     super(message);
193:     this.name = "ImageValidationError";
194:   }
195: }
196: ```
197: 
198: ### Error Codes
199: 
200: ```typescript
201: export const VALIDATION_ERRORS = {
202:   INVALID_FORMAT: "INVALID_FORMAT",
203:   INVALID_SIZE: "INVALID_SIZE",
204:   INVALID_DIMENSIONS: "INVALID_DIMENSIONS",
205:   INVALID_URL: "INVALID_URL",
206:   METADATA_ERROR: "METADATA_ERROR"
207: } as const;
208: ```
209: 
210: ## Best Practices
211: 
212: ### Input Validation
213: 
214: - Check buffer integrity
215: - Validate URL structure
216: - Verify MIME types
217: 
218: ### Performance Optimization
219: 
220: - Cache validation results
221: - Implement early returns
222: - Use efficient checks
223: 
224: ### Error Handling
225: 
226: - Provide detailed error messages
227: - Include validation context
228: - Log validation failures
229: 
230: ## Usage Guidelines
231: 
232: ### Standard Validation
233: 
234: ```typescript
235: const validateImage = async (buffer: Buffer): Promise<void> => {
236:   const validator = new ImageValidator();
237:  
238:   try {
239:     await validator.validate(buffer);
240:   } catch (error) {
241:     await logError(error, "imageValidation");
242:     throw error;
243:   }
244: };
245: ```
246: 
247: ### URL Pattern Validation
248: 
249: ```typescript
250: const validateImageUrl = (url: string): void => {
251:   if (!isValidImageUrl(url)) {
252:     throw new ImageValidationError(
253:       `Invalid image URL: ${url}`,
254:       VALIDATION_ERRORS.INVALID_URL,
255:       { url }
256:     );
257:   }
258: };
259: ```
260: 
261: ## Related Components
262: 
263: - [Image Compressor](./image-compressor)
264: - [Image Handler](./image-handler)
265: - [Error Handling](./error-handling)
266: 
267: ## Troubleshooting
268: 
269: ### Common Issues
270: 
271: 1. Format Problems:
272:    - Check file extensions
273:    - Verify MIME types
274:    - Validate image headers
275: 
276: 2. Size Issues:
277:    - Monitor file sizes
278:    - Check compression settings
279:    - Verify buffer integrity
280: 
281: 3. Dimension Errors:
282:    - Validate aspect ratios
283:    - Check resolution requirements
284:    - Monitor scaling issues
</file>

<file path="docs/utils/logging.md">
  1: # Logging System
  2: 
  3: ## Overview
  4: 
  5: The Logging System (`logger.ts`) provides comprehensive logging functionality across the application. It integrates with Firebase Functions logger and Firestore for persistent log storage, supporting multiple log levels and structured logging data.
  6: 
  7: ## Features
  8: 
  9: - Multiple log levels (INFO, WARNING, ERROR)
 10: - Structured logging with metadata
 11: - Firestore integration for log persistence
 12: - Data cleaning and sanitization
 13: - Flexible context tracking
 14: - Type-safe logging interfaces
 15: 
 16: ## Basic Usage
 17: 
 18: ### Importing the Logger
 19: 
 20: ```typescript
 21: import { logInfo, logWarning, logError } from "../utils/logger";
 22: import { logger } from "firebase-functions";
 23: ```
 24: 
 25: ### Log Levels
 26: 
 27: ```typescript
 28: // Info level logging
 29: await logInfo("Processing started", {
 30:   timestamp: new Date().toISOString(),
 31:   operation: "syncCards"
 32: });
 33: 
 34: // Warning level logging
 35: await logWarning("Retry attempt required", {
 36:   attempt: 2,
 37:   maxRetries: 3
 38: });
 39: 
 40: // Error level logging
 41: await logError(error, "syncCards:main");
 42: ```
 43: 
 44: ## Data Structures
 45: 
 46: ### Log Entry Interface
 47: 
 48: ```typescript
 49: interface LogEntry {
 50:   timestamp: Date;
 51:   level: "INFO" | "WARNING" | "ERROR";
 52:   message: string;
 53:   context?: string;
 54:   data?: Record<string, unknown>;
 55: }
 56: ```
 57: 
 58: ### Error Logging Interface
 59: 
 60: ```typescript
 61: interface GenericError {
 62:   message: string;
 63:   name: string;
 64:   code?: string;
 65:   stack?: string;
 66: }
 67: ```
 68: 
 69: ## Core Functions
 70: 
 71: ### Info Logging
 72: 
 73: ```typescript
 74: export const logInfo = async (
 75:   message: string,
 76:   data?: LogData
 77: ) => {
 78:   const cleanedData = data ? cleanLogData({
 79:     ...data,
 80:     timestamp: new Date().toISOString(),
 81:   }) : undefined;
 82: 
 83:   const entry: LogEntry = {
 84:     timestamp: new Date(),
 85:     level: "INFO",
 86:     message,
 87:     ...(cleanedData && {data: cleanedData}),
 88:   };
 89: 
 90:   logger.info(message, cleanedData);
 91:   await saveLogEntry(entry);
 92: };
 93: ```
 94: 
 95: ### Error Logging
 96: 
 97: ```typescript
 98: export const logError = async (
 99:   error: GenericError | GenericObject,
100:   context: string
101: ) => {
102:   const errorData = cleanLogData({
103:     stack: error.stack,
104:     code: error.code,
105:     ...(error as GenericObject),
106:     timestamp: new Date().toISOString(),
107:   });
108: 
109:   const entry: LogEntry = {
110:     timestamp: new Date(),
111:     level: "ERROR",
112:     message: error.message || "Unknown error",
113:     context,
114:     data: errorData,
115:   };
116: 
117:   logger.error(entry.message, errorData);
118:   await saveLogEntry(entry);
119: };
120: ```
121: 
122: ## Data Cleaning
123: 
124: ### Clean Log Data Function
125: 
126: ```typescript
127: function cleanLogData(
128:   data: Record<string, unknown>
129: ): Record<string, unknown> {
130:   return Object.entries(data).reduce((acc, [key, value]) => {
131:     if (value !== undefined && value !== null) {
132:       if (value && typeof value === "object") {
133:         const cleaned = cleanLogData(value as Record<string, unknown>);
134:         if (Object.keys(cleaned).length > 0) {
135:           acc[key] = cleaned;
136:         }
137:       } else {
138:         acc[key] = value instanceof Date ? value.toISOString() : value;
139:       }
140:     }
141:     return acc;
142:   }, {} as Record<string, unknown>);
143: }
144: ```
145: 
146: ## Firestore Integration
147: 
148: ### Save Log Entry
149: 
150: ```typescript
151: async function saveLogEntry(entry: LogEntry): Promise<void> {
152:   const cleanEntry = {
153:     timestamp: entry.timestamp,
154:     level: entry.level,
155:     message: entry.message,
156:     ...(entry.context && {context: entry.context}),
157:     ...(entry.data && {data: cleanLogData(entry.data)}),
158:   };
159: 
160:   await db.collection(COLLECTION.LOGS).add(cleanEntry);
161: }
162: ```
163: 
164: ## Best Practices
165: 
166: 1. **Structured Logging**:
167: 
168:    ```typescript
169:    await logInfo("Card sync completed", {
170:      cardsProcessed: 50,
171:      updatedCount: 10,
172:      duration: "5m30s",
173:      timestamp: new Date().toISOString()
174:    });
175:    ```
176: 
177: 2. **Error Context**:
178: 
179:    ```typescript
180:    await logError(error, "cardSync:processGroup", {
181:      groupId: "23783",
182:      attempt: 2,
183:      operation: "imageProcessing"
184:    });
185:    ```
186: 
187: 3. **Performance Monitoring**:
188: 
189:    ```typescript
190:    await logInfo("Operation timing", {
191:      operation: "imageCompression",
192:      duration: endTime - startTime,
193:      size: {
194:        before: originalSize,
195:        after: compressedSize
196:      }
197:    });
198:    ```
199: 
200: ## Error Handling
201: 
202: ### Common Patterns
203: 
204: ```typescript
205: try {
206:   // Operation code
207: } catch (error) {
208:   await logError(
209:     error instanceof Error ? error : new Error("Unknown error"),
210:     "operationName",
211:     { contextData: "relevant info" }
212:   );
213:   throw error;
214: }
215: ```
216: 
217: ### Error with Context
218: 
219: ```typescript
220: class DetailedError extends Error {
221:   constructor(
222:     message: string,
223:     public context: string,
224:     public metadata?: Record<string, unknown>
225:   ) {
226:     super(message);
227:     this.name = "DetailedError";
228:   }
229: }
230: ```
231: 
232: ## Query Examples
233: 
234: ### Firestore Queries
235: 
236: ```typescript
237: // Get recent errors
238: const recentErrors = await db
239:   .collection(COLLECTION.LOGS)
240:   .where("level", "==", "ERROR")
241:   .orderBy("timestamp", "desc")
242:   .limit(10)
243:   .get();
244: 
245: // Get logs by context
246: const contextLogs = await db
247:   .collection(COLLECTION.LOGS)
248:   .where("context", "==", "cardSync:processGroup")
249:   .get();
250: ```
251: 
252: ## Related Components
253: 
254: - [Error Handling](./error-handling)
255: - [Sync Logger](./sync-logger)
256: - [Progress Tracking](./progress)
257: 
258: ## Troubleshooting
259: 
260: ### Common Issues
261: 
262: 1. Missing Logs:
263:    - Check log level configuration
264:    - Verify Firestore permissions
265:    - Check error handling implementation
266: 
267: 2. Performance Impact:
268:    - Use appropriate log levels
269:    - Implement log batching for high-volume operations
270:    - Monitor Firestore usage
271: 
272: 3. Data Size:
273:    - Implement log rotation
274:    - Clean sensitive data
275:    - Monitor storage usage
</file>

<file path="docs/utils/progress.md">
  1: # Progress Tracking Utility
  2: 
  3: ## Overview
  4: 
  5: The Progress Tracking utility (`progress.ts`) provides real-time monitoring and
  6:  reporting of long-running operations. It offers accurate progress calculations,
  7:   ETA estimations, and detailed statistics for batch operations.
  8: 
  9: ## Core Components
 10: 
 11: ### Progress Statistics Interface
 12: 
 13: ```typescript
 14: export interface ProgressStats {
 15:   current: number;
 16:   total: number;
 17:   percent: number;
 18:   elapsed: number;
 19:   rate: number;
 20:   remaining: number;
 21:   eta: number;
 22: }
 23: ```
 24: 
 25: ### Enhanced Progress Tracker Class
 26: 
 27: ```typescript
 28: export class EnhancedProgressTracker {
 29:   private startTime: number;
 30:   private current: number;
 31:   private estimates: number[] = [];
 32:   private lastUpdate: number;
 33:   private updateInterval: number;
 34: 
 35:   constructor(
 36:     private total: number,
 37:     private description: string,
 38:     options: { updateInterval?: number } = {}
 39:   ) {
 40:     this.startTime = Date.now();
 41:     this.current = 0;
 42:     this.lastUpdate = Date.now();
 43:     this.updateInterval = options.updateInterval || 1000; // Default 1 second
 44:   }
 45: }
 46: ```
 47: 
 48: ## Core Methods
 49: 
 50: ### Statistics Calculation
 51: 
 52: ```typescript
 53: private calculateStats(): ProgressStats {
 54:   const now = Date.now();
 55:   const elapsed = (now - this.startTime) / 1000;
 56:   const percent = (this.current / this.total) * 100;
 57:   const rate = this.current / elapsed;
 58:   const remaining = this.total - this.current;
 59:   const eta = remaining / rate;
 60: 
 61:   return {
 62:     current: this.current,
 63:     total: this.total,
 64:     percent,
 65:     elapsed,
 66:     rate,
 67:     remaining,
 68:     eta,
 69:   };
 70: }
 71: ```
 72: 
 73: ### Progress Update
 74: 
 75: ```typescript
 76: update(amount = 1): void {
 77:   const now = Date.now();
 78:   this.current += amount;
 79: 
 80:   // Only update log if enough time has passed
 81:   if (now - this.lastUpdate >= this.updateInterval) {
 82:     const stats = this.calculateStats();
 83:     this.estimates.push(stats.eta);
 84: 
 85:     // Keep only last 10 estimates for averaging
 86:     if (this.estimates.length > 10) {
 87:       this.estimates.shift();
 88:     }
 89: 
 90:     const avgEta = this.estimates.reduce((a, b) => a + b, 0) / 
 91:       this.estimates.length;
 92: 
 93:     logInfo(
 94:       `${this.description}: ${stats.current}/${stats.total} ` +
 95:       `(${stats.percent.toFixed(1)}%) - ${stats.remaining} remaining - ` +
 96:       `ETA: ${avgEta.toFixed(1)}s - Rate: ${stats.rate.toFixed(1)}/s`
 97:     );
 98: 
 99:     this.lastUpdate = now;
100:   }
101: }
102: ```
103: 
104: ## Usage Examples
105: 
106: ### Basic Progress Tracking
107: 
108: ```typescript
109: const tracker = new EnhancedProgressTracker(100, "Processing Items");
110: 
111: for (let i = 0; i < 100; i++) {
112:   await processItem(i);
113:   tracker.update();
114: }
115: ```
116: 
117: ### Batch Processing Progress
118: 
119: ```typescript
120: const tracker = new EnhancedProgressTracker(
121:   totalItems,
122:   "Processing Batches",
123:   { updateInterval: 2000 } // Update every 2 seconds
124: );
125: 
126: for (const batch of batches) {
127:   await processBatch(batch);
128:   tracker.update(batch.length);
129: }
130: ```
131: 
132: ### Custom Progress Monitoring
133: 
134: ```typescript
135: const tracker = new EnhancedProgressTracker(totalCards, "Syncing Cards");
136: 
137: // Get current progress
138: const progress = tracker.getProgress();
139: console.log(`Current progress: ${progress.percent.toFixed(1)}%`);
140: console.log(`ETA: ${progress.eta.toFixed(1)} seconds`);
141: ```
142: 
143: ## Progress Output Examples
144: 
145: ### Standard Progress Output
146: 
147: ```text
148: Processing Items: 45/100 (45.0%) - 55 remaining - ETA: 62.3s - Rate: 0.9/s
149: ```
150: 
151: ### Batch Progress Output
152: 
153: ```text
154: Processing Batches: 250/1000 (25.0%) - 750 remaining - ETA: 300.5s - Rate: 2.5/s
155: ```
156: 
157: ## Advanced Features
158: 
159: ### ETA Calculation
160: 
161: - Rolling average of last 10 estimates
162: - Adaptive rate calculation
163: - Dynamic update intervals
164: - Accurate remaining time prediction
165: 
166: ### Performance Monitoring
167: 
168: - Processing rate tracking
169: - Resource usage monitoring
170: - Time elapsed tracking
171: - Completion percentage
172: 
173: ### Progress Formatting
174: 
175: - Percentage calculation
176: - Rate calculation
177: - Time formatting
178: - Progress bar rendering
179: 
180: ## Best Practices
181: 
182: ### Update Frequency
183: 
184: ```typescript
185: // Recommended update interval based on total items
186: const getOptimalInterval = (total: number): number => {
187:   if (total < 100) return 500;    // 0.5s for small operations
188:   if (total < 1000) return 1000;  // 1s for medium operations
189:   return 2000;                    // 2s for large operations
190: };
191: 
192: const tracker = new EnhancedProgressTracker(items.length, "Processing", {
193:   updateInterval: getOptimalInterval(items.length)
194: });
195: ```
196: 
197: ### Memory Management
198: 
199: ```typescript
200: // Clear old estimates periodically
201: if (this.estimates.length > 10) {
202:   this.estimates = this.estimates.slice(-10);
203: }
204: ```
205: 
206: ### Error Handling
207: 
208: ```typescript
209: update(amount = 1): void {
210:   try {
211:     this.current += amount;
212:     if (this.current > this.total) {
213:       this.current = this.total;
214:     }
215:     // Update logic...
216:   } catch (error) {
217:     logError(error, "progressUpdate");
218:   }
219: }
220: ```
221: 
222: ## Integration Examples
223: 
224: ### With Batch Processing
225: 
226: ```typescript
227: const batchProcessor = async (items: any[]) => {
228:   const tracker = new EnhancedProgressTracker(items.length, "Batch Processing");
229:   
230:   for (const batch of chunks(items, 100)) {
231:     await processBatch(batch);
232:     tracker.update(batch.length);
233:   }
234: };
235: ```
236: 
237: ### With Sync Operations
238: 
239: ```typescript
240: const syncWithProgress = async (options: SyncOptions) => {
241:   const tracker = new EnhancedProgressTracker(
242:     totalItems,
243:     "Syncing Data",
244:     { updateInterval: 1000 }
245:   );
246: 
247:   // Register callback
248:   options.onProgress = (processed: number) => {
249:     tracker.update(processed);
250:   };
251: 
252:   await syncOperation(options);
253: };
254: ```
255: 
256: ## Related Documentation
257: 
258: - [Batch Processing](/utils/batch)
259: - [Sync Logger](/utils/sync-logger)
260: - [Error Handling](/utils/error-handling)
261: - [Logging System](/utils/logging)
</file>

<file path="docs/utils/request.md">
  1: # Request Handler Utility
  2: 
  3: ## Overview
  4: 
  5: The Request Handler (`request.ts`) provides a robust HTTP request implementation
  6:  with built-in retry logic, error handling, and rate limiting capabilities.
  7:   It's primarily used for communicating with external APIs, particularly the
  8:    TCGPlayer API.
  9: 
 10: ## Core Configuration
 11: 
 12: ### Constants
 13: 
 14: ```typescript
 15: export const MAX_RETRIES = 3;
 16: export const BASE_DELAY = 1000; // 1 second base delay
 17: 
 18: export interface RequestOptions {
 19:   retryCount?: number;
 20:   customDelay?: number;
 21:   metadata?: Record<string, unknown>;
 22: }
 23: ```
 24: 
 25: ### Error Class
 26: 
 27: ```typescript
 28: export class RequestError extends Error {
 29:   constructor(
 30:     message: string,
 31:     public originalError: Error,
 32:     public context: string,
 33:     public metadata?: Record<string, unknown>
 34:   ) {
 35:     super(message);
 36:     this.name = "RequestError";
 37:   }
 38: }
 39: ```
 40: 
 41: ## Core Functionality
 42: 
 43: ### Main Request Function
 44: 
 45: ```typescript
 46: export async function makeRequest<T>(
 47:   endpoint: string,
 48:   baseUrl: string,
 49:   options: RequestOptions = {}
 50: ): Promise<T> {
 51:   const {retryCount = 0, customDelay = BASE_DELAY} = options;
 52: 
 53:   try {
 54:     await new Promise((resolve) => setTimeout(resolve, customDelay));
 55:     const url = `${baseUrl}/${endpoint}`;
 56:     const response = await axios.get<T>(url, {
 57:       timeout: 30000, // 30 seconds timeout
 58:       headers: {
 59:         "Accept": "application/json",
 60:         "User-Agent": "FFTCG-Sync-Service/1.0",
 61:       },
 62:     });
 63: 
 64:     return response.data;
 65:   } catch (error) {
 66:     if (retryCount < MAX_RETRIES - 1 && error instanceof AxiosError) {
 67:       const delay = Math.pow(2, retryCount) * BASE_DELAY;
 68:       await logWarning(`Request failed, retrying in ${delay}ms...`, {
 69:         url: `${baseUrl}/${endpoint}`,
 70:         attempt: retryCount + 1,
 71:         maxRetries: MAX_RETRIES,
 72:         error: error.message,
 73:         ...options.metadata,
 74:       });
 75: 
 76:       return makeRequest<T>(endpoint, baseUrl, {
 77:         ...options,
 78:         retryCount: retryCount + 1,
 79:         customDelay: delay,
 80:       });
 81:     }
 82: 
 83:     throw new RequestError(
 84:       `Request failed after ${retryCount + 1} attempts`,
 85:       error as Error,
 86:       endpoint,
 87:       options.metadata
 88:     );
 89:   }
 90: }
 91: ```
 92: 
 93: ## Usage Examples
 94: 
 95: ### Basic Request
 96: 
 97: ```typescript
 98: const cardData = await makeRequest<CardProduct>(
 99:   `${FFTCG_CATEGORY_ID}/${groupId}/products`,
100:   BASE_URL,
101:   { metadata: { groupId, operation: "fetchCard" } }
102: );
103: ```
104: 
105: ### With Retry Logic
106: 
107: ```typescript
108: try {
109:   const data = await makeRequest<ApiResponse>(
110:     endpoint,
111:     baseUrl,
112:     {
113:       retryCount: 0,
114:       customDelay: 2000,
115:       metadata: { context: "sync" }
116:     }
117:   );
118: } catch (error) {
119:   if (error instanceof RequestError) {
120:     console.error(`Request failed: ${error.message}`);
121:     console.error(`Context: ${error.context}`);
122:   }
123: }
124: ```
125: 
126: ## Error Handling
127: 
128: ### Error Types
129: 
130: ```typescript
131: type RequestErrorType = 
132:   | "NETWORK_ERROR"
133:   | "TIMEOUT_ERROR"
134:   | "API_ERROR"
135:   | "VALIDATION_ERROR";
136: 
137: interface EnhancedRequestError extends RequestError {
138:   type: RequestErrorType;
139:   statusCode?: number;
140:   responseData?: unknown;
141: }
142: ```
143: 
144: ### Error Processing
145: 
146: ```typescript
147: function processRequestError(error: unknown): EnhancedRequestError {
148:   if (error instanceof AxiosError) {
149:     return {
150:       message: error.message,
151:       type: error.code === "ECONNABORTED" ? "TIMEOUT_ERROR" : "NETWORK_ERROR",
152:       statusCode: error.response?.status,
153:       responseData: error.response?.data,
154:       context: "request",
155:     };
156:   }
157:   return {
158:     message: "Unknown request error",
159:     type: "API_ERROR",
160:     context: "request",
161:   };
162: }
163: ```
164: 
165: ## Retry Strategy
166: 
167: ### Exponential Backoff
168: 
169: ```typescript
170: function calculateDelay(attempt: number): number {
171:   return Math.min(
172:     Math.pow(2, attempt) * BASE_DELAY,
173:     30000 // Max 30 seconds
174:   );
175: }
176: ```
177: 
178: ### Retry Conditions
179: 
180: ```typescript
181: function shouldRetry(error: Error, attempt: number): boolean {
182:   if (attempt >= MAX_RETRIES) return false;
183:   
184:   if (error instanceof AxiosError) {
185:     // Retry on network errors or 5xx responses
186:     return (
187:       !error.response || 
188:       (error.response.status >= 500 && error.response.status < 600)
189:     );
190:   }
191:   
192:   return false;
193: }
194: ```
195: 
196: ## Rate Limiting
197: 
198: ### Token Bucket Implementation
199: 
200: ```typescript
201: class RateLimiter {
202:   private tokens: number;
203:   private lastRefill: number;
204:   
205:   constructor(
206:     private maxTokens: number,
207:     private refillRate: number,
208:     private refillInterval: number
209:   ) {
210:     this.tokens = maxTokens;
211:     this.lastRefill = Date.now();
212:   }
213: 
214:   async acquire(): Promise<boolean> {
215:     this.refillTokens();
216:     
217:     if (this.tokens > 0) {
218:       this.tokens--;
219:       return true;
220:     }
221:     
222:     return false;
223:   }
224: 
225:   private refillTokens(): void {
226:     const now = Date.now();
227:     const timePassed = now - this.lastRefill;
228:     const tokensToAdd = Math.floor(
229:       (timePassed / this.refillInterval) * this.refillRate
230:     );
231:     
232:     this.tokens = Math.min(this.maxTokens, this.tokens + tokensToAdd);
233:     this.lastRefill = now;
234:   }
235: }
236: ```
237: 
238: ## Monitoring and Logging
239: 
240: ### Request Logging
241: 
242: ```typescript
243: async function logRequest(
244:   endpoint: string,
245:   options: RequestOptions,
246:   startTime: number
247: ): Promise<void> {
248:   const duration = Date.now() - startTime;
249:   
250:   await logInfo("API Request", {
251:     endpoint,
252:     duration,
253:     attempt: options.retryCount || 0,
254:     ...options.metadata
255:   });
256: }
257: ```
258: 
259: ### Performance Tracking
260: 
261: ```typescript
262: interface RequestMetrics {
263:   totalRequests: number;
264:   successfulRequests: number;
265:   failedRequests: number;
266:   averageResponseTime: number;
267:   retryCount: number;
268: }
269: 
270: class RequestMetricsTracker {
271:   private metrics: RequestMetrics = {
272:     totalRequests: 0,
273:     successfulRequests: 0,
274:     failedRequests: 0,
275:     averageResponseTime: 0,
276:     retryCount: 0
277:   };
278: 
279:   trackRequest(duration: number, successful: boolean, retries: number): void {
280:     this.metrics.totalRequests++;
281:     if (successful) {
282:       this.metrics.successfulRequests++;
283:     } else {
284:       this.metrics.failedRequests++;
285:     }
286:     this.metrics.retryCount += retries;
287:     this.metrics.averageResponseTime = 
288:       (this.metrics.averageResponseTime * (this.metrics.totalRequests - 1)
289:        + duration) / 
290:       this.metrics.totalRequests;
291:   }
292: }
293: ```
294: 
295: ## Best Practices
296: 
297: ### Request Configuration
298: 
299: - Set appropriate timeouts
300: - Use proper headers
301: - Implement retry logic
302: - Handle rate limits
303: 
304: ### Error Management
305: 
306: - Implement proper error types
307: - Use detailed error messages
308: - Track error patterns
309: - Log all failures
310: 
311: ### Performance
312: 
313: - Monitor response times
314: - Track retry counts
315: - Implement caching
316: - Use rate limiting
317: 
318: ## Related Documentation
319: 
320: - [Error Handling](/utils/error-handling)
321: - [Logging System](/utils/logging)
322: - [Cache System](/utils/cache)
323: - [TCGPlayer Integration](/integrations/tcgplayer)
</file>

<file path="docs/utils/sync-logger.md">
  1: # Sync Logger Utility
  2: 
  3: ## Overview
  4: 
  5: The Sync Logger (`syncLogger.ts`) provides specialized logging functionality for
  6:  synchronization operations. It handles detailed logging of card and price
  7:  synchronization processes, including group details, card information, and sync results.
  8: 
  9: ## Core Interfaces
 10: 
 11: ### Logger Options
 12: 
 13: ```typescript
 14: interface SyncLoggerOptions {
 15:   type: "manual" | "scheduled" | "both";
 16:   limit?: number;
 17:   dryRun?: boolean;
 18:   groupId?: string;
 19:   batchSize?: number;
 20: }
 21: ```
 22: 
 23: ### Card Details
 24: 
 25: ```typescript
 26: interface CardDetails {
 27:   id: number;
 28:   name: string;
 29:   groupId: string;
 30:   normalPrice?: number;
 31:   foilPrice?: number;
 32:   rawPrices: Array<{
 33:     type: "Normal" | "Foil";
 34:     price: number;
 35:     groupId: string;
 36:   }>;
 37:   imageUrl?: string;
 38:   storageImageUrl?: string;
 39: }
 40: ```
 41: 
 42: ### Sync Results
 43: 
 44: ```typescript
 45: interface SyncResults {
 46:   success: number;
 47:   failures: number;
 48:   groupId?: string;
 49:   type: "Manual" | "Scheduled";
 50:   imagesProcessed?: number;
 51:   imagesUpdated?: number;
 52: }
 53: ```
 54: 
 55: ## Core Implementation
 56: 
 57: ### SyncLogger Class
 58: 
 59: ```typescript
 60: export class SyncLogger {
 61:   private startTime: number;
 62:   private cards: CardDetails[] = [];
 63:   private groups: Map<string, { 
 64:     products: number; 
 65:     prices: number 
 66:   }> = new Map();
 67: 
 68:   constructor(private options: SyncLoggerOptions) {
 69:     this.startTime = Date.now();
 70:   }
 71: }
 72: ```
 73: 
 74: ## Logging Methods
 75: 
 76: ### Initialization
 77: 
 78: ```typescript
 79: async start(): Promise<void> {
 80:   console.log("\nStarting sync test...");
 81:   console.log(`Type: ${this.options.type}`);
 82:   if (this.options.limit) {
 83:     console.log(`Limit: ${this.options.limit} cards`);
 84:   }
 85:   console.log(`Dry Run: ${this.options.dryRun ? "true" : "false"}`);
 86:   console.log("\n=== Fetching Raw Data ===");
 87: }
 88: ```
 89: 
 90: ### Group Logging
 91: 
 92: ```typescript
 93: async logGroupDetails(
 94:   groupId: string,
 95:   products: number,
 96:   prices: number
 97: ): Promise<void> {
 98:   this.groups.set(groupId, {products, prices});
 99:   console.log(
100:     `Group ${groupId} has ${products} products and ${prices} prices`
101:   );
102: }
103: ```
104: 
105: ### Card Details Logging
106: 
107: ```typescript
108: async logCardDetails(details: CardDetails): Promise<void> {
109:   this.cards.push(details);
110:   if (this.cards.length === 1) {
111:     console.log("\n=== Card Details ===");
112:   }
113: 
114:   console.log(`Card: ${details.name} (${details.groupId || "UNKNOWN"})`);
115:   console.log(`- ID: ${details.id}`);
116:   console.log(`- Group ID: ${details.groupId || "UNKNOWN"}`);
117: 
118:   if (details.rawPrices.length > 0) {
119:     console.log("- Raw Prices:");
120:     details.rawPrices.forEach((price) => {
121:       console.log(
122:         `  > ${price.type}: $${price.price.toFixed(2)} ` +
123:         `(Group: ${price.groupId})`
124:       );
125:     });
126:   }
127: 
128:   if (details.imageUrl) {
129:     console.log(`- Image URL: ${details.imageUrl}`);
130:     if (details.storageImageUrl) {
131:       console.log(`- Storage URL: ${details.storageImageUrl}`);
132:     }
133:   }
134: }
135: ```
136: 
137: ### Sync Results Logging
138: 
139: ```typescript
140: async logSyncResults(results: SyncResults): Promise<void> {
141:   const duration = (Date.now() - this.startTime) / 1000;
142: 
143:   console.log(`\n${results.type} Sync Results:`);
144:   console.log(`- Success: ${results.success}`);
145:   console.log(`- Failures: ${results.failures}`);
146:   console.log(`- Duration: ${duration.toFixed(1)} seconds`);
147:   
148:   if (results.groupId) {
149:     console.log(`- Group ID: ${results.groupId}`);
150:   }
151:   if (results.imagesProcessed) {
152:     console.log(`- Images Processed: ${results.imagesProcessed}`);
153:   }
154:   if (results.imagesUpdated) {
155:     console.log(`- Images Updated: ${results.imagesUpdated}`);
156:   }
157: }
158: ```
159: 
160: ## Usage Examples
161: 
162: ### Manual Sync Logging
163: 
164: ```typescript
165: const logger = new SyncLogger({
166:   type: "manual",
167:   dryRun: true,
168:   limit: 5,
169:   batchSize: 25
170: });
171: 
172: await logger.start();
173: await logger.logGroupFound(totalGroups);
174: await logger.logCardDetails(cardDetails);
175: await logger.logSyncResults({
176:   success: 5,
177:   failures: 0,
178:   type: "Manual",
179:   imagesProcessed: 5,
180:   imagesUpdated: 2
181: });
182: await logger.finish();
183: ```
184: 
185: ### Scheduled Sync Logging
186: 
187: ```typescript
188: const logger = new SyncLogger({
189:   type: "scheduled",
190:   dryRun: false
191: });
192: 
193: await logger.start();
194: await logger.logScheduledSyncStart();
195: // Sync operations...
196: await logger.finish();
197: ```
198: 
199: ## Output Examples
200: 
201: ### Group Information
202: 
203: ```text
204: === Fetching Raw Data ===
205: Found 15 groups
206: Group 23783 has 100 products and 200 prices
207: ```
208: 
209: ### Card Details Output
210: 
211: ```text
212: === Card Details ===
213: Card: Cloud (23783)
214: - ID: 477236
215: - Group ID: 23783
216: - Raw Prices:
217:   > Normal: $1.99 (Group: 23783)
218:   > Foil: $5.99 (Group: 23783)
219: - Image URL: https://example.com/image.jpg
220: - Storage URL: gs://bucket/image.jpg
221: ```
222: 
223: ### Sync Results Output
224: 
225: ```text
226: Manual Sync Results:
227: - Success: 95
228: - Failures: 5
229: - Duration: 120.5 seconds
230: - Group ID: 23783
231: - Images Processed: 100
232: - Images Updated: 25
233: ```
234: 
235: ## Error Handling
236: 
237: ### Error Logging
238: 
239: ```typescript
240: async logError(
241:   error: Error,
242:   context: string
243: ): Promise<void> {
244:   console.error(`Error in ${context}:`, error.message);
245:   if (this.options.verbose) {
246:     console.error("Stack trace:", error.stack);
247:   }
248: }
249: ```
250: 
251: ### Progress Errors
252: 
253: ```typescript
254: async logProgressError(
255:   current: number,
256:   total: number,
257:   error: Error
258: ): Promise<void> {
259:   console.error(
260:     `Error at ${current}/${total} (${((current/total)*100).toFixed(1)}%):`,
261:     error.message
262:   );
263: }
264: ```
265: 
266: ## Best Practices
267: 
268: ### Log Organization
269: 
270: - Group related logs
271: - Use consistent formatting
272: - Include timestamps
273: - Maintain context
274: 
275: ### Performance
276: 
277: - Buffer large outputs
278: - Limit verbose logging
279: - Use appropriate log levels
280: - Implement log rotation
281: 
282: ### Error Handling Guidelines
283: 
284: - Log all errors
285: - Include context
286: - Track error patterns
287: - Maintain error history
288: 
289: ## Related Documentation
290: 
291: - [Logging System](/utils/logging)
292: - [Error Handling](/utils/error-handling)
293: - [Progress Tracking](/utils/progress)
294: - [Card Sync Service](/services/card-sync)
</file>

<file path="file_structure.ps1">
 1: # Set working directory
 2: Set-Location -Path "C:\VSCode\fftcg-sync-service"
 3: 
 4: # Create exclusion filters
 5: $excludedDirs = @('node_modules', 'functions-backup', 'functions\lib', 'functions\node_modules')
 6: $excludedExtensions = @('.tmp', '.temp', '.log')
 7: $excludedRootFiles = @(
 8:     '.gitignore',
 9:     'codebase.xml',
10:     'file_structure.ps1',
11:     'file_structure.xml',
12:     'service_account_key.json'
13: )
14: 
15: # Initialize XML content
16: $xmlContent = @"
17: <?xml version="1.0" encoding="UTF-8"?>
18: <file_structure>
19:     <metadata>
20:         <root_directory>C:\VSCode\fftcg-sync-service</root_directory>
21:         <generated_date>$((Get-Date -Format "yyyy-MM-dd HH:mm:ss"))</generated_date>
22:     </metadata>
23:     <directories>
24:         <functions>
25:             <directories>
26: "@
27: 
28: # Get functions directory and its subdirectories
29: $functionsDirs = Get-ChildItem -Path ".\functions\src" -Directory -Recurse | 
30:     Where-Object { 
31:         $dir = $_.FullName.Replace("$PWD\", "")
32:         -not ($excludedDirs | Where-Object { $dir -like "$_*" })
33:     }
34: 
35: foreach ($dir in $functionsDirs) {
36:     $relativePath = $dir.FullName.Replace("$PWD\", "")
37:     $xmlContent += "                <directory>$([System.Security.SecurityElement]::Escape($relativePath))</directory>`n"
38: }
39: 
40: $xmlContent += @"
41:             </directories>
42:             <files>
43: "@
44: 
45: # Get files in functions directory
46: $functionsFiles = Get-ChildItem -Path ".\functions\src" -File -Recurse | 
47:     Where-Object { 
48:         $file = $_
49:         $relativePath = $file.FullName.Replace("$PWD\", "")
50:         -not ($excludedDirs | Where-Object { $relativePath -like "$_*" }) -and
51:         -not ($excludedExtensions | Where-Object { $file.Extension -eq $_ })
52:     }
53: 
54: foreach ($file in $functionsFiles) {
55:     $path = [System.Security.SecurityElement]::Escape($file.FullName.Replace("$PWD\", ""))
56:     $xmlContent += "                <file>$path</file>`n"
57: }
58: 
59: $xmlContent += @"
60:             </files>
61:         </functions>
62:     </directories>
63:     <root_files>
64: "@
65: 
66: # Get root files
67: $rootFiles = Get-ChildItem -Path "." -File | 
68:     Where-Object { 
69:         -not ($excludedRootFiles -contains $_.Name) -and
70:         -not ($excludedExtensions | Where-Object { $_.Extension -eq $_ })
71:     }
72: 
73: foreach ($file in $rootFiles) {
74:     $path = [System.Security.SecurityElement]::Escape($file.FullName.Replace("$PWD\", ""))
75:     $xmlContent += "        <file>$path</file>`n"
76: }
77: 
78: $xmlContent += @"
79:     </root_files>
80: </file_structure>
81: "@
82: 
83: # Save the XML file
84: $xmlContent | Out-File -FilePath "file_structure.xml" -Encoding UTF8
85: 
86: Write-Host "file_structure.xml has been created successfully!"
</file>

<file path="firebase.json">
 1: {
 2:   "firestore": {
 3:     "rules": "firestore.rules",
 4:     "indexes": "firestore.indexes.json"
 5:   },
 6:   "functions": [
 7:     {
 8:       "source": "functions",
 9:       "codebase": "default",
10:       "ignore": [
11:         "node_modules",
12:         ".git",
13:         "firebase-debug.log",
14:         "firebase-debug.*.log",
15:         "*.local"
16:       ],
17:       "predeploy": [
18:         "npm --prefix \"$RESOURCE_DIR\" run lint",
19:         "npm --prefix \"$RESOURCE_DIR\" run build"
20:       ]
21:     }
22:   ],
23:   "hosting": [
24:     {
25:       "target": "main",
26:       "public": "public",
27:       "ignore": [
28:         "firebase.json",
29:         "**/.*",
30:         "**/node_modules/**"
31:       ],
32:       "rewrites": [
33:         {
34:           "source": "**",
35:           "function": "app"
36:         }
37:       ]
38:     },
39:     {
40:       "target": "docs",
41:       "public": "docs/.vitepress/dist",
42:       "ignore": [
43:         "firebase.json",
44:         "**/.*",
45:         "**/node_modules/**"
46:       ],
47:       "rewrites": [
48:         {
49:           "source": "**",
50:           "destination": "/index.html"
51:         }
52:       ],
53:       "headers": [
54:         {
55:           "source": "**",
56:           "headers": [
57:             {
58:               "key": "Cache-Control",
59:               "value": "max-age=3600"
60:             }
61:           ]
62:         }
63:       ]
64:     }
65:   ],
66:   "storage": {
67:     "rules": "storage.rules"
68:   },
69:   "emulators": {
70:     "functions": {
71:       "port": 5001,
72:       "host": "127.0.0.1"
73:     },
74:     "firestore": {
75:       "port": 8081,
76:       "host": "127.0.0.1"
77:     },
78:     "storage": {
79:       "port": 9199,
80:       "host": "127.0.0.1"
81:     },
82:     "hosting": {
83:       "port": 5000,
84:       "host": "127.0.0.1"
85:     },
86:     "ui": {
87:       "enabled": true,
88:       "port": 4001,
89:       "host": "127.0.0.1"
90:     },
91:     "singleProjectMode": true
92:   }
93: }
</file>

<file path="firestore.indexes.json">
1: {
2:   "indexes": [],
3:   "fieldOverrides": []
4: }
</file>

<file path="firestore.rules">
 1: rules_version = '2';
 2: service cloud.firestore {
 3:   match /databases/{database}/documents {
 4:     // Helper function to check if user is authorized
 5:     function isAuthorizedUser() {
 6:       return request.auth != null && 
 7:              (request.auth.token.email == 'mrw1986@gmail.com' ||
 8:               request.auth.token.email == 'preliatorzero@gmail.com' ||
 9:               request.auth.token.email == 'fftcgcompanion@gmail.com');
10:     }
11: 
12:     // Helper function to check if request is from Cloud Functions
13:     function isCloudFunction() {
14:       return request.auth != null &&
15:              request.auth.token.firebase.sign_in_provider == 'google.com' &&
16:              request.auth.token.email.matches('.*@firebase.google.com$');
17:     }
18: 
19:     match /{document=**} {
20:       // Allow read access to all data
21:       allow read: if true;
22:       // Allow write access from Cloud Functions or authorized users
23:       allow write: if isCloudFunction() || isAuthorizedUser();
24:     }
25:   }
26: }
</file>

<file path="functions/.eslintignore">
1: node_modules/
2: lib/
3: coverage/
4: *.d.ts
5: *.cjs
</file>

<file path="functions/.eslintrc.base.cjs">
1: module.exports = {
2:     rules: {
3:       "valid-jsdoc": "off",
4:       "require-jsdoc": "off"
5:     }
6:   };
</file>

<file path="functions/.eslintrc.fix.js">
 1: module.exports = {
 2:   extends: "./.eslintrc.js",
 3:   rules: {
 4:     "max-len": ["error", {"code": 120}],
 5:     "valid-jsdoc": 0,
 6:     "require-jsdoc": 0,
 7:     "@typescript-eslint/no-explicit-any": 0,
 8:     "@typescript-eslint/explicit-function-return-type": 0,
 9:     "@typescript-eslint/explicit-module-boundary-types": 0,
10:     "@typescript-eslint/no-unused-vars": ["error", {
11:       "argsIgnorePattern": "^_",
12:       "varsIgnorePattern": "^_",
13:     }],
14:     // Add these additional rules to be extra sure
15:     "jsdoc/require-jsdoc": 0,
16:     "jsdoc/valid-jsdoc": 0,
17:     "jsdoc/require-param-type": 0,
18:     "jsdoc/require-returns": 0,
19:   },
20: };
</file>

<file path="functions/.eslintrc.js">
 1: module.exports = {
 2:   root: true,
 3:   env: {
 4:     es6: true,
 5:     node: true,
 6:   },
 7:   extends: [
 8:     "eslint:recommended",
 9:     "plugin:import/errors",
10:     "plugin:import/warnings",
11:     "plugin:import/typescript",
12:     "google",
13:     "plugin:@typescript-eslint/recommended",
14:   ],
15:   parser: "@typescript-eslint/parser",
16:   parserOptions: {
17:     project: ["tsconfig.json", "tsconfig.dev.json"],
18:     sourceType: "module",
19:   },
20:   ignorePatterns: [
21:     "/lib/**/*",
22:     "/generated/**/*",
23:     "*.js", // Add this line to ignore JS files
24:   ],
25:   plugins: ["@typescript-eslint", "import"],
26:   rules: {
27:     quotes: ["error", "double"],
28:     "import/no-unresolved": 0,
29:     indent: ["error", 2],
30:     "linebreak-style": 0, // Disable linebreak-style checks
31:     "object-curly-spacing": ["error", "always"],
32:     "max-len": ["error", { code: 120 }],
33:     "@typescript-eslint/no-explicit-any": "warn",
34:     "require-jsdoc": 0,
35:     "valid-jsdoc": 0,
36:     "@typescript-eslint/no-var-requires": 0,
37:     camelcase: 0,
38:   },
39: };
</file>

<file path="functions/.firebaserc">
1: {
2:   "projects": {
3:     "default": "fftcg-sync-service"
4:   }
5: }
</file>

<file path="functions/.gitignore">
 1: # Dependencies
 2: node_modules/
 3: 
 4: # Build output
 5: lib/
 6: dist/
 7: 
 8: # Environment variables
 9: .env
10: .env.local
11: .env.*.local
12: 
13: # Service account keys
14: service_account_key.json
15: *-service-account.json
16: 
17: # Firebase
18: .firebase/
19: firebase-debug.log
20: firebase-debug.*.log
21: 
22: # IDE
23: .vscode/
24: .idea/
25: 
26: # Logs
27: *.log
</file>

<file path="functions/.npmrc">
1: //us-central1-npm.pkg.dev/fftcg-sync-service/gcf-artifacts/:_authToken=${NPM_TOKEN}
2: @google-cloud:registry=https://us-central1-npm.pkg.dev/fftcg-sync-service/gcf-artifacts/
</file>

<file path="functions/.prettierrc">
1: {
2:   "singleQuote": false,
3:   "trailingComma": "es5",
4:   "bracketSpacing": true,
5:   "semi": true,
6:   "printWidth": 120,
7:   "tabWidth": 2,
8:   "endOfLine": "auto"
9: }
</file>

<file path="functions/.repomixignore">
1: lib/**
2: !*/
3: !.gitignore
4: service_account_key.json
5: !src/**
</file>

<file path="functions/firebase.json">
 1: {
 2:   "functions": [
 3:     {
 4:       "source": ".",
 5:       "codebase": "default",
 6:       "runtime": "nodejs18",
 7:       "region": "us-central1",
 8:       "ignore": ["node_modules", ".git", "firebase-debug.log", "firebase-debug.*.log", "*.local"],
 9:       "predeploy": [
10:         "npm run lint",
11:         "npm run build"
12:       ]
13:     }
14:   ],
15:   "emulators": {
16:     "functions": {
17:       "port": 5001
18:     },
19:     "firestore": {
20:       "port": 8080
21:     },
22:     "ui": {
23:       "enabled": true
24:     },
25:     "singleProjectMode": true
26:   }
27: }
</file>

<file path="functions/package.json">
 1: {
 2:   "name": "functions",
 3:   "scripts": {
 4:     "lint": "eslint --ext .js,.ts .",
 5:     "lint:fix": "eslint --ext .js,.ts . --fix",
 6:     "build": "rimraf lib && tsc",
 7:     "build:watch": "tsc --watch",
 8:     "serve": "npm run build && firebase emulators:start --only functions,firestore",
 9:     "shell": "npm run build && firebase functions:shell",
10:     "start": "npm run shell",
11:     "deploy": "firebase deploy --only functions",
12:     "logs": "firebase functions:log"
13:   },
14:   "engines": {
15:     "node": "18"
16:   },
17:   "main": "lib/index.js",
18:   "dependencies": {
19:     "@aws-sdk/client-s3": "^3.485.0",
20:     "@aws-sdk/s3-request-presigner": "^3.485.0",
21:     "axios": "^1.7.7",
22:     "cors": "^2.8.5",
23:     "dotenv": "^16.4.7",
24:     "express": "^4.18.2",
25:     "firebase-admin": "^12.0.0",
26:     "firebase-functions": "^6.2.0"
27:   },
28:   "devDependencies": {
29:     "@types/cors": "^2.8.17",
30:     "@types/express": "^4.17.21",
31:     "@typescript-eslint/eslint-plugin": "^5.12.0",
32:     "@typescript-eslint/parser": "^5.12.0",
33:     "eslint": "^8.9.0",
34:     "eslint-config-google": "^0.14.0",
35:     "eslint-plugin-import": "^2.25.4",
36:     "firebase-functions-test": "^3.1.0",
37:     "rimraf": "^5.0.0",
38:     "typescript": "^4.9.0"
39:   },
40:   "private": true,
41:   "publishConfig": {
42:     "registry": "https://us-central1-npm.pkg.dev/fftcg-sync-service/gcf-artifacts/"
43:   }
44: }
</file>

<file path="functions/repomix.config.json">
 1: {
 2:   "output": {
 3:     "filePath": "C:\\VSCode\\fftcg-sync-service\\codebase.xml",
 4:     "style": "xml",
 5:     "removeComments": false,
 6:     "removeEmptyLines": false,
 7:     "topFilesLength": 5,
 8:     "showLineNumbers": true,
 9:     "copyToClipboard": false
10:   },
11:   "include": [],
12:   "ignore": {
13:     "useGitignore": false,
14:     "useDefaultPatterns": true,
15:     "customPatterns": []
16:   },
17:   "security": {
18:     "enableSecurityCheck": true
19:   }
20: }
</file>

<file path="functions/src/config/environment.ts">
 1: // src/config/environment.ts
 2: import * as functions from "firebase-functions";
 3: import * as dotenv from "dotenv";
 4: 
 5: // Load .env file in development
 6: if (process.env.NODE_ENV !== "production") {
 7:   dotenv.config();
 8: }
 9: 
10: // Helper function to get config value
11: function getConfigValue(key: string): string {
12:   if (process.env.NODE_ENV === "production") {
13:     const config = functions.config();
14:     return config.r2?.[key.toLowerCase().replace("r2_", "")] || "";
15:   }
16:   return process.env[key] || "";
17: }
18: 
19: export const environment = {
20:   nodeEnv: process.env.NODE_ENV || "development",
21:   isLocal: process.env.NODE_ENV !== "production",
22:   r2: {
23:     accountId: getConfigValue("R2_ACCOUNT_ID"),
24:     accessKeyId: getConfigValue("R2_ACCESS_KEY_ID"),
25:     secretAccessKey: getConfigValue("R2_SECRET_ACCESS_KEY"),
26:     bucketName: getConfigValue("R2_BUCKET_NAME"),
27:     storagePath: getConfigValue("R2_STORAGE_PATH"),
28:     customDomain: getConfigValue("R2_CUSTOM_DOMAIN"),
29:   } as { [key: string]: string },
30: };
31: 
32: // Validate required environment variables
33: if (!environment.isLocal) {
34:   const required = ["R2_ACCOUNT_ID", "R2_ACCESS_KEY_ID", "R2_SECRET_ACCESS_KEY", "R2_BUCKET_NAME"];
35:   const missing = required.filter((key) => !(environment.r2[key.toLowerCase()] as string));
36:   if (missing.length) {
37:     throw new Error(`Missing required environment variables: ${missing.join(", ")}`);
38:   }
39: }
</file>

<file path="functions/src/config/firebase.ts">
 1: // functions/src/config/firebase.ts
 2: 
 3: import * as admin from "firebase-admin";
 4: 
 5: const app = !admin.apps.length ? admin.initializeApp() : admin.app();
 6: const db = admin.firestore(app);
 7: 
 8: // Enable ignoreUndefinedProperties and other settings
 9: db.settings({
10:   ignoreUndefinedProperties: true,
11:   timestampsInSnapshots: true,
12: });
13: 
14: export { db };
15: 
16: export const COLLECTION = {
17:   CARDS: "cards",
18:   PRICES: "prices",
19:   SYNC_METADATA: "syncMetadata",
20:   LOGS: "logs",
21:   CARD_HASHES: "cardHashes",
22:   PRICE_HASHES: "priceHashes",
23:   IMAGE_METADATA: "imageMetadata",
24:   HISTORICAL_PRICES: "historicalPrices",
25:   PRICE_ARCHIVES: "priceArchives",
26: };
27: 
28: export const BASE_URL = "https://tcgcsv.com/tcgplayer";
29: export const FFTCG_CATEGORY_ID = "24";
30: 
31: export const runtimeOpts = {
32:   timeoutSeconds: 540,
33:   memory: "1GiB",
34: } as const;
</file>

<file path="functions/src/config/r2.ts">
 1: // src/config/r2.ts
 2: 
 3: import * as dotenv from "dotenv";
 4: dotenv.config();
 5: 
 6: export const R2_CONFIG = {
 7:   ACCOUNT_ID: process.env.R2_ACCOUNT_ID || "",
 8:   ACCESS_KEY_ID: process.env.R2_ACCESS_KEY_ID || "",
 9:   SECRET_ACCESS_KEY: process.env.R2_SECRET_ACCESS_KEY || "",
10:   BUCKET_NAME: process.env.R2_BUCKET_NAME || "",
11:   STORAGE_PATH: process.env.R2_STORAGE_PATH || "",
12:   CUSTOM_DOMAIN: process.env.R2_CUSTOM_DOMAIN || "",
13: } as const;
14: 
15: if (!R2_CONFIG.ACCOUNT_ID) {
16:   console.warn("Missing R2_ACCOUNT_ID in .env file");
17: }
18: if (!R2_CONFIG.ACCESS_KEY_ID) {
19:   console.warn("Missing R2_ACCESS_KEY_ID in .env file");
20: }
21: if (!R2_CONFIG.SECRET_ACCESS_KEY) {
22:   console.warn("Missing R2_SECRET_ACCESS_KEY in .env file");
23: }
24: if (!R2_CONFIG.BUCKET_NAME) {
25:   console.warn("Missing R2_BUCKET_NAME in .env file");
26: }
27: if (!R2_CONFIG.STORAGE_PATH) {
28:   console.warn("Missing R2_STORAGE_PATH in .env file");
29: }
30: if (!R2_CONFIG.CUSTOM_DOMAIN) {
31:   console.warn("Missing R2_CUSTOM_DOMAIN in .env file");
32: }
33: 
34: console.log("R2 Config:", R2_CONFIG);
</file>

<file path="functions/src/index.ts">
  1: // src/index.ts
  2: import { onCall, HttpsError } from "firebase-functions/v2/https";
  3: import { onSchedule } from "firebase-functions/v2/scheduler";
  4: import { logger } from "firebase-functions/v2";
  5: import { cardSync } from "./services/cardSync";
  6: import { priceSync } from "./services/priceSync";
  7: import { retention } from "./utils/retention";
  8: import { runtimeOpts } from "./config/firebase";
  9: import * as dotenv from "dotenv";
 10: 
 11: dotenv.config();
 12: 
 13: // Manual card sync endpoint as a callable function
 14: export const manualCardSync = onCall(
 15:   {
 16:     memory: runtimeOpts.memory,
 17:     timeoutSeconds: runtimeOpts.timeoutSeconds,
 18:     region: "us-central1",
 19:   },
 20:   async (request) => {
 21:     try {
 22:       const forceUpdate = request.data.force === true;
 23:       const groupId = request.data.groupId as string | undefined;
 24: 
 25:       const result = await cardSync.syncCards({
 26:         forceUpdate,
 27:         groupId,
 28:         skipImages: false,
 29:         imagesOnly: false,
 30:         silent: false,
 31:         dryRun: false,
 32:       });
 33: 
 34:       return result;
 35:     } catch (error) {
 36:       logger.error("Manual card sync failed", { error });
 37:       throw new HttpsError(
 38:         "internal",
 39:         error instanceof Error ? error.message : "Unknown error"
 40:       );
 41:     }
 42:   }
 43: );
 44: 
 45: // Manual price sync endpoint as a callable function
 46: export const manualPriceSync = onCall(
 47:   {
 48:     memory: runtimeOpts.memory,
 49:     timeoutSeconds: runtimeOpts.timeoutSeconds,
 50:     region: "us-central1",
 51:   },
 52:   async (request) => {
 53:     try {
 54:       const forceUpdate = request.data.force === true;
 55:       const groupId = request.data.groupId as string | undefined;
 56: 
 57:       const result = await priceSync.syncPrices({
 58:         forceUpdate,
 59:         groupId,
 60:         silent: false,
 61:         dryRun: false,
 62:       });
 63: 
 64:       return result;
 65:     } catch (error) {
 66:       logger.error("Manual price sync failed", { error });
 67:       throw new HttpsError(
 68:         "internal",
 69:         error instanceof Error ? error.message : "Unknown error"
 70:       );
 71:     }
 72:   }
 73: );
 74: 
 75: // Manual cleanup endpoint as a callable function
 76: export const manualCleanup = onCall(
 77:   {
 78:     memory: runtimeOpts.memory,
 79:     timeoutSeconds: runtimeOpts.timeoutSeconds,
 80:     region: "us-central1",
 81:   },
 82:   async () => {
 83:     try {
 84:       await retention.cleanOldData();
 85:       return { success: true };
 86:     } catch (error) {
 87:       logger.error("Manual cleanup failed", { error });
 88:       throw new HttpsError(
 89:         "internal",
 90:         error instanceof Error ? error.message : "Unknown error"
 91:       );
 92:     }
 93:   }
 94: );
 95: 
 96: // Scheduled Functions
 97: export const scheduledCardSync = onSchedule(
 98:   {
 99:     schedule: "0 21 * * *", // Daily at 21:00 UTC
100:     timeZone: "UTC",
101:     memory: runtimeOpts.memory,
102:     timeoutSeconds: runtimeOpts.timeoutSeconds,
103:     retryCount: 3,
104:   },
105:   async () => {
106:     try {
107:       logger.info("Starting scheduled card sync");
108:       const result = await cardSync.syncCards({
109:         forceUpdate: false,
110:         skipImages: false,
111:         imagesOnly: false,
112:         silent: false,
113:         dryRun: false,
114:       });
115:       logger.info("Card sync completed", result);
116:     } catch (error) {
117:       logger.error("Scheduled card sync failed", { error });
118:       throw error;
119:     }
120:   }
121: );
122: 
123: export const scheduledPriceSync = onSchedule(
124:   {
125:     schedule: "30 21 * * *", // Daily at 21:30 UTC
126:     timeZone: "UTC",
127:     memory: runtimeOpts.memory,
128:     timeoutSeconds: runtimeOpts.timeoutSeconds,
129:     retryCount: 3,
130:   },
131:   async () => {
132:     try {
133:       logger.info("Starting scheduled price sync");
134:       const result = await priceSync.syncPrices({
135:         forceUpdate: false,
136:         silent: false,
137:         dryRun: false,
138:       });
139:       logger.info("Price sync completed", result);
140:     } catch (error) {
141:       logger.error("Scheduled price sync failed", { error });
142:       throw error;
143:     }
144:   }
145: );
146: 
147: export const scheduledCleanup = onSchedule(
148:   {
149:     schedule: "0 22 * * *", // Daily at 22:00 UTC
150:     timeZone: "UTC",
151:     memory: runtimeOpts.memory,
152:     timeoutSeconds: runtimeOpts.timeoutSeconds,
153:     retryCount: 3,
154:   },
155:   async () => {
156:     try {
157:       logger.info("Starting scheduled cleanup");
158:       await retention.cleanOldData();
159:       logger.info("Cleanup completed");
160:     } catch (error) {
161:       logger.error("Scheduled cleanup failed", { error });
162:       throw error;
163:     }
164:   }
165: );
</file>

<file path="functions/src/scripts/cleanup.ts">
 1: import { retention } from "../utils/retention";
 2: 
 3: async function main() {
 4:   console.log("Starting manual cleanup...");
 5:   try {
 6:     await retention.cleanOldData();
 7:     console.log("Cleanup completed successfully");
 8:   } catch (error) {
 9:     console.error("Cleanup failed:", error);
10:     process.exit(1);
11:   }
12: }
13: 
14: main();
</file>

<file path="functions/src/scripts/prodSync.ts">
  1: // src/scripts/prodSync.ts
  2: import { cardSync } from "../services/cardSync";
  3: import { priceSync } from "../services/priceSync";
  4: import { logger, LogData } from "../utils/logger";
  5: 
  6: 
  7: interface SyncStats {
  8:   success: boolean;
  9:   itemsProcessed: number;
 10:   itemsUpdated: number;
 11:   errors: string[];
 12:   duration: number;
 13: }
 14: 
 15: interface SyncOptions {
 16:   forceUpdate?: boolean;
 17:   groupId?: string;
 18:   cardsOnly?: boolean;
 19:   pricesOnly?: boolean;
 20: }
 21: 
 22: // Move runProductionSync into a class for better organization
 23: class ProductionSync {
 24:   async run(options: SyncOptions = {}) {
 25:     const startTime = Date.now();
 26:     const results: {
 27:       cards?: SyncStats;
 28:       prices?: SyncStats;
 29:     } = {};
 30: 
 31:     try {
 32:       logger.info("Starting production sync", { options } as LogData);
 33: 
 34:       // Run card sync if not prices-only
 35:       if (!options.pricesOnly) {
 36:         logger.info("Starting card sync...");
 37:         const cardResult = await cardSync.syncCards({
 38:           forceUpdate: options.forceUpdate,
 39:           groupId: options.groupId,
 40:         });
 41: 
 42:         results.cards = {
 43:           success: cardResult.success,
 44:           itemsProcessed: cardResult.itemsProcessed,
 45:           itemsUpdated: cardResult.itemsUpdated,
 46:           errors: cardResult.errors,
 47:           duration: cardResult.timing.duration || 0,
 48:         };
 49: 
 50:         logger.info("Card sync completed", { stats: results.cards } as LogData);
 51:       }
 52: 
 53:       // Run price sync if not cards-only
 54:       if (!options.cardsOnly) {
 55:         logger.info("Starting price sync...");
 56:         const priceResult = await priceSync.syncPrices({
 57:           forceUpdate: options.forceUpdate,
 58:           groupId: options.groupId,
 59:         });
 60: 
 61:         results.prices = {
 62:           success: priceResult.success,
 63:           itemsProcessed: priceResult.itemsProcessed,
 64:           itemsUpdated: priceResult.itemsUpdated,
 65:           errors: priceResult.errors,
 66:           duration: priceResult.timing.duration || 0,
 67:         };
 68: 
 69:         logger.info("Price sync completed", { stats: results.prices } as LogData);
 70:       }
 71: 
 72:       const totalDuration = (Date.now() - startTime) / 1000;
 73:       logger.info(`Full sync completed in ${totalDuration}s`, { results } as LogData);
 74: 
 75:       return results;
 76:     } catch (error) {
 77:       logger.error("Production sync failed", { error } as LogData);
 78:       throw error;
 79:     }
 80:   }
 81: }
 82: 
 83: function parseArgs(args: string[]): SyncOptions {
 84:   const options: SyncOptions = {};
 85: 
 86:   for (let i = 0; i < args.length; i++) {
 87:     switch (args[i]) {
 88:     case "--force":
 89:       options.forceUpdate = true;
 90:       break;
 91:     case "--group":
 92:       options.groupId = args[++i];
 93:       break;
 94:     case "--cards-only":
 95:       options.cardsOnly = true;
 96:       break;
 97:     case "--prices-only":
 98:       options.pricesOnly = true;
 99:       break;
100:     case "--help":
101:       printHelp();
102:       process.exit(0);
103:     }
104:   }
105: 
106:   return options;
107: }
108: 
109: function printHelp() {
110:   console.log(`
111: Usage: npx ts-node src/scripts/prodSync.ts [options]
112: 
113: Options:
114:   --force         Force update all items regardless of changes
115:   --group <id>    Sync specific group ID only
116:   --cards-only    Only sync card data
117:   --prices-only   Only sync price data
118:   --help          Show this help message
119:   
120: Examples:
121:   npx ts-node src/scripts/prodSync.ts
122:   npx ts-node src/scripts/prodSync.ts --force
123:   npx ts-node src/scripts/prodSync.ts --group 23244
124:   npx ts-node src/scripts/prodSync.ts --cards-only
125:   `);
126: }
127: 
128: // Create singleton instance
129: export const productionSync = new ProductionSync();
130: 
131: // Command line execution
132: async function main() {
133:   const args = process.argv.slice(2);
134:   const options = parseArgs(args);
135: 
136:   console.log("Starting production sync with options:", options);
137: 
138:   try {
139:     const results = await productionSync.run(options);
140:     console.log("Sync completed successfully!");
141:     console.log(JSON.stringify(results, null, 2));
142:     process.exit(0);
143:   } catch (error) {
144:     console.error("Sync failed:", error);
145:     process.exit(1);
146:   }
147: }
148: 
149: // Run if called directly
150: if (require.main === module) {
151:   main();
152: }
</file>

<file path="functions/src/scripts/setenv.ts">
 1: // scripts/setenv.ts
 2: import * as dotenv from "dotenv";
 3: import { exec } from "child_process";
 4: import { promisify } from "util";
 5: 
 6: const execAsync = promisify(exec);
 7: 
 8: async function setFirebaseConfig() {
 9:   try {
10:     dotenv.config();
11: 
12:     const config = {
13:       account_id: process.env.R2_ACCOUNT_ID,
14:       access_key_id: process.env.R2_ACCESS_KEY_ID,
15:       secret_access_key: process.env.R2_SECRET_ACCESS_KEY,
16:       bucket_name: process.env.R2_BUCKET_NAME,
17:       storage_path: process.env.R2_STORAGE_PATH,
18:       custom_domain: process.env.R2_CUSTOM_DOMAIN,
19:     };
20: 
21:     // Remove existing config
22:     await execAsync("firebase functions:config:unset r2");
23: 
24:     // Set new config
25:     const configString = Object.entries(config)
26:       .map(([key, value]) => `r2.${key}="${value}"`)
27:       .join(" ");
28: 
29:     await execAsync(`firebase functions:config:set ${configString}`);
30:     console.log("Firebase config updated successfully");
31:   } catch (error) {
32:     console.error("Error setting Firebase config:", error);
33:   }
34: }
35: 
36: setFirebaseConfig();
</file>

<file path="functions/src/scripts/syncAll.ts">
 1: import { cardSync } from "../services/cardSync";
 2: import { priceSync } from "../services/priceSync";
 3: 
 4: async function main() {
 5:   console.log("Starting full sync...");
 6: 
 7:   try {
 8:     console.log("\n1. Running card sync...");
 9:     const cardResult = await cardSync.syncCards();
10:     console.log("Card sync completed:", {
11:       success: cardResult.success,
12:       processed: cardResult.itemsProcessed,
13:       updated: cardResult.itemsUpdated,
14:       errors: cardResult.errors.length,
15:     });
16: 
17:     console.log("\n2. Running price sync...");
18:     const priceResult = await priceSync.syncPrices();
19:     console.log("Price sync completed:", {
20:       success: priceResult.success,
21:       processed: priceResult.itemsProcessed,
22:       updated: priceResult.itemsUpdated,
23:       errors: priceResult.errors.length,
24:     });
25: 
26:     const allErrors = [...cardResult.errors, ...priceResult.errors];
27:     if (allErrors.length > 0) {
28:       console.log("\nErrors encountered:");
29:       allErrors.forEach((error) => console.log(`- ${error}`));
30:     }
31: 
32:     console.log("\nFull sync completed!");
33:   } catch (error) {
34:     console.error("Full sync failed:", error);
35:     process.exit(1);
36:   }
37: }
38: 
39: main();
</file>

<file path="functions/src/scripts/syncCards.ts">
 1: import { cardSync } from "../services/cardSync";
 2: 
 3: async function main() {
 4:   try {
 5:     console.log("Starting manual card sync...");
 6:     const result = await cardSync.syncCards();
 7:     console.log("Card sync completed:", {
 8:       success: result.success,
 9:       processed: result.itemsProcessed,
10:       updated: result.itemsUpdated,
11:       errors: result.errors.length,
12:       duration: `${result.timing.duration}s`,
13:     });
14: 
15:     if (result.errors.length > 0) {
16:       console.log("\nErrors encountered:");
17:       result.errors.forEach((error) => console.log(`- ${error}`));
18:     }
19:   } catch (error) {
20:     console.error("Card sync failed:", error);
21:     process.exit(1);
22:   }
23: }
24: 
25: main();
</file>

<file path="functions/src/scripts/syncPrices.ts">
 1: import { priceSync } from "../services/priceSync";
 2: 
 3: async function main() {
 4:   console.log("Starting manual price sync...");
 5:   try {
 6:     const result = await priceSync.syncPrices();
 7:     console.log("Price sync completed:", {
 8:       success: result.success,
 9:       processed: result.itemsProcessed,
10:       updated: result.itemsUpdated,
11:       errors: result.errors.length,
12:       duration: `${result.timing.duration}s`,
13:     });
14: 
15:     if (result.errors.length > 0) {
16:       console.log("\nErrors encountered:");
17:       result.errors.forEach((error) => console.log(`- ${error}`));
18:     }
19:   } catch (error) {
20:     console.error("Price sync failed:", error);
21:     process.exit(1);
22:   }
23: }
24: 
25: main();
</file>

<file path="functions/src/scripts/testSync.ts">
  1: // src/scripts/testSync.ts
  2: import { cardSync } from "../services/cardSync";
  3: import { priceSync } from "../services/priceSync";
  4: import { logger } from "../utils/logger";
  5: import { withTimeout, TimeoutError } from "../utils/timeout";
  6: import { storageService } from "../services/storageService";
  7: 
  8: const MAX_SYNC_TIME = 30 * 60 * 1000; // 30 minutes
  9: const TEST_GROUP_ID = "23244"; // Dawn of Heroes
 10: const TEST_PRODUCT_ID = 508343; // Example product ID
 11: const IMAGE_BASE_URL = "https://fftcgcompanion.com/card-images";
 12: 
 13: async function testImageProcessing() {
 14:   try {
 15:     logger.info("Testing image processing...");
 16: 
 17:     // Test with a valid image URL using correct format
 18:     const validImageResult = await storageService.processAndStoreImage(
 19:       `${IMAGE_BASE_URL}/${TEST_GROUP_ID}/${TEST_PRODUCT_ID}_200w.jpg`,
 20:       TEST_PRODUCT_ID,
 21:       TEST_GROUP_ID,
 22:       "1-001" // Example card number
 23:     );
 24: 
 25:     logger.info("Valid image processing result:", {
 26:       highResUrl: validImageResult.highResUrl,
 27:       lowResUrl: validImageResult.lowResUrl,
 28:       isPlaceholder: validImageResult.metadata.isPlaceholder,
 29:       originalUrl: validImageResult.metadata.originalUrl,
 30:     });
 31: 
 32:     // Verify the image URLs follow the correct pattern
 33:     const urlPattern = new RegExp(`^${IMAGE_BASE_URL}/.*_[24]00w.jpg$`);
 34:     const isValidImageUrl = urlPattern.test(validImageResult.metadata.originalUrl || "");
 35: 
 36:     if (!isValidImageUrl) {
 37:       logger.error("Image URL pattern does not match expected format", {
 38:         url: validImageResult.metadata.originalUrl,
 39:         expectedPattern: `${IMAGE_BASE_URL}/{groupId}/{productId}_200w.jpg`,
 40:       });
 41:     }
 42: 
 43:     // Test with invalid/missing image (should return placeholder)
 44:     const placeholderResult = await storageService.processAndStoreImage(
 45:       undefined,
 46:       TEST_PRODUCT_ID,
 47:       TEST_GROUP_ID,
 48:       "1-001"
 49:     );
 50: 
 51:     logger.info("Placeholder image result:", {
 52:       highResUrl: placeholderResult.highResUrl,
 53:       lowResUrl: placeholderResult.lowResUrl,
 54:       isPlaceholder: placeholderResult.metadata.isPlaceholder,
 55:     });
 56: 
 57:     return {
 58:       validImage: {
 59:         success: validImageResult.metadata.isPlaceholder !== true,
 60:         correctUrlPattern: isValidImageUrl,
 61:         urls: {
 62:           original: validImageResult.metadata.originalUrl,
 63:           highRes: validImageResult.highResUrl,
 64:           lowRes: validImageResult.lowResUrl,
 65:         },
 66:       },
 67:       placeholderImage: {
 68:         success: placeholderResult.metadata.isPlaceholder === true,
 69:         urls: {
 70:           highRes: placeholderResult.highResUrl,
 71:           lowRes: placeholderResult.lowResUrl,
 72:         },
 73:       },
 74:     };
 75:   } catch (error) {
 76:     logger.error("Image processing test failed:", { error });
 77:     throw error;
 78:   }
 79: }
 80: 
 81: async function testSync() {
 82:   try {
 83:     logger.info("Starting test sync with group " + TEST_GROUP_ID);
 84: 
 85:     // Test image processing first
 86:     logger.info("Testing image processing capabilities...");
 87:     const imageResults = await testImageProcessing();
 88:     logger.info("Image processing test results:", imageResults);
 89: 
 90:     // Monitor card sync with timeout
 91:     const cardResult = await withTimeout(
 92:       cardSync.syncCards({
 93:         groupId: TEST_GROUP_ID,
 94:         forceUpdate: true,
 95:       }),
 96:       MAX_SYNC_TIME
 97:     );
 98: 
 99:     logger.info("Card sync results:", {
100:       processed: cardResult.itemsProcessed,
101:       updated: cardResult.itemsUpdated,
102:       errors: cardResult.errors,
103:       timing: cardResult.timing,
104:     });
105: 
106:     // Monitor price sync with timeout
107:     const priceResult = await withTimeout(
108:       priceSync.syncPrices({
109:         groupId: TEST_GROUP_ID,
110:         forceUpdate: true,
111:       }),
112:       MAX_SYNC_TIME
113:     );
114: 
115:     logger.info("Price sync results:", {
116:       processed: priceResult.itemsProcessed,
117:       updated: priceResult.itemsUpdated,
118:       errors: priceResult.errors,
119:       timing: priceResult.timing,
120:     });
121: 
122:     // Validate results
123:     const validationResults = {
124:       imageProcessing: imageResults,
125:       cardSync: {
126:         success: cardResult.success,
127:         hasUpdates: cardResult.itemsUpdated > 0,
128:         hasErrors: cardResult.errors.length > 0,
129:       },
130:       priceSync: {
131:         success: priceResult.success,
132:         hasUpdates: priceResult.itemsUpdated > 0,
133:         hasErrors: priceResult.errors.length > 0,
134:       },
135:     };
136: 
137:     logger.info("Test validation results:", validationResults);
138: 
139:     // Log any errors
140:     const allErrors = [...cardResult.errors, ...priceResult.errors];
141:     if (allErrors.length > 0) {
142:       logger.error("Errors during sync:", { errors: allErrors });
143:     }
144: 
145:     return validationResults;
146:   } catch (error) {
147:     if (error instanceof TimeoutError) {
148:       logger.error("Sync operation timed out", { error });
149:     } else {
150:       logger.error("Test sync failed:", { error });
151:     }
152:     throw error;
153:   }
154: }
155: 
156: // Execute if run directly
157: if (require.main === module) {
158:   testSync()
159:     .then((results) => {
160:       console.log("Test sync completed successfully!");
161:       console.log("Results:", JSON.stringify(results, null, 2));
162:       process.exit(0);
163:     })
164:     .catch((error) => {
165:       console.error("Test failed:", error);
166:       process.exit(1);
167:     });
168: }
169: 
170: export { testSync, testImageProcessing };
</file>

<file path="functions/src/services/cardSync.ts">
  1: // src/services/cardSync.ts
  2: import { db } from "../config/firebase";
  3: import { tcgcsvApi } from "../utils/api";
  4: import { storageService } from "./storageService";
  5: import { CardProduct, SyncResult, CardHashData, SyncTiming, SyncOptions } from "../types";
  6: import { logger } from "../utils/logger";
  7: import * as crypto from "crypto";
  8: 
  9: export class CardSyncService {
 10:   private readonly CARDS_COLLECTION = "cards";
 11:   private readonly HASH_COLLECTION = "cardHashes";
 12:   private readonly BATCH_SIZE = 5;
 13: 
 14:   private calculateHash(data: CardHashData): string {
 15:     return crypto.createHash("md5").update(JSON.stringify(data)).digest("hex");
 16:   }
 17: 
 18:   private async getStoredHash(productId: number): Promise<string | null> {
 19:     const doc = await db.collection(this.HASH_COLLECTION).doc(productId.toString()).get();
 20:     return doc.exists ? doc.data()?.hash : null;
 21:   }
 22: 
 23:   private async updateStoredHash(productId: number, hash: string): Promise<void> {
 24:     await db.collection(this.HASH_COLLECTION).doc(productId.toString()).set({
 25:       hash,
 26:       lastUpdated: new Date(),
 27:     });
 28:   }
 29: 
 30:   private getCardNumbers(card: CardProduct): string[] {
 31:     const numbers: string[] = [];
 32: 
 33:     // Get all number fields from extended data
 34:     card.extendedData
 35:       .filter((data) => data.name === "Number")
 36:       .forEach((numberField) => {
 37:         // Split on common separators and trim
 38:         const vals = numberField.value.split(/[,;/]/).map((n) => n.trim());
 39:         numbers.push(...vals);
 40:       });
 41: 
 42:     // If no numbers found, use product ID
 43:     if (numbers.length === 0) {
 44:       numbers.push(`P${card.productId}`);
 45:     }
 46: 
 47:     return [...new Set(numbers)]; // Remove duplicates
 48:   }
 49: 
 50:   private getDocumentIds(card: CardProduct): string[] {
 51:     return this.getCardNumbers(card).map((num) => `${card.productId}_${num}`);
 52:   }
 53: 
 54:   private isNonCardProduct(card: CardProduct): boolean {
 55:     const cardType = card.extendedData.find((data) => data.name === "CardType")?.value;
 56:     return !cardType || cardType.toLowerCase() === "sealed product";
 57:   }
 58: 
 59:   private updateTiming(timing: SyncTiming): void {
 60:     timing.lastUpdateTime = new Date();
 61:     if (timing.startTime) {
 62:       timing.duration = (timing.lastUpdateTime.getTime() - timing.startTime.getTime()) / 1000;
 63:     }
 64:   }
 65: 
 66:   private async processCardBatch(
 67:     cards: CardProduct[],
 68:     groupId: string,
 69:     options: { forceUpdate?: boolean } = {}
 70:   ): Promise<{
 71:     processed: number;
 72:     updated: number;
 73:     errors: string[];
 74:   }> {
 75:     const result = {
 76:       processed: 0,
 77:       updated: 0,
 78:       errors: [] as string[],
 79:     };
 80: 
 81:     const batches = [];
 82:     for (let i = 0; i < cards.length; i += this.BATCH_SIZE) {
 83:       batches.push(cards.slice(i, i + this.BATCH_SIZE));
 84:     }
 85: 
 86:     for (const batch of batches) {
 87:       try {
 88:         await Promise.all(
 89:           batch.map(async (card) => {
 90:             try {
 91:               result.processed++;
 92: 
 93:               const relevantData: CardHashData = {
 94:                 name: card.name,
 95:                 cleanName: card.cleanName,
 96:                 modifiedOn: card.modifiedOn,
 97:                 extendedData: card.extendedData,
 98:               };
 99:               const currentHash = this.calculateHash(relevantData);
100:               const storedHash = await this.getStoredHash(card.productId);
101: 
102:               if (currentHash === storedHash && !options.forceUpdate) {
103:                 logger.info(`Skipping card ${card.productId} - no changes`);
104:                 return;
105:               }
106: 
107:               const cardNumbers = this.getCardNumbers(card);
108:               const documentIds = this.getDocumentIds(card);
109:               const primaryCardNumber = cardNumbers[0];
110: 
111:               const imageResult = await storageService.processAndStoreImage(
112:                 card.imageUrl,
113:                 card.productId,
114:                 groupId,
115:                 primaryCardNumber
116:               );
117: 
118:               const cardDoc = {
119:                 ...card,
120:                 imageUrl: undefined,
121:                 highResUrl: imageResult.highResUrl,
122:                 lowResUrl: imageResult.lowResUrl,
123:                 imageMetadata: imageResult.metadata,
124:                 lastUpdated: new Date(),
125:                 groupId: parseInt(groupId),
126:                 isNonCard: this.isNonCardProduct(card),
127:                 cardNumbers: cardNumbers,
128:                 primaryCardNumber: primaryCardNumber,
129:               };
130: 
131:               // Create a batch for multiple document writes
132:               const batch = db.batch();
133:               documentIds.forEach((docId) => {
134:                 batch.set(db.collection(this.CARDS_COLLECTION).doc(docId), cardDoc, { merge: true });
135:               });
136:               await batch.commit();
137: 
138:               await this.updateStoredHash(card.productId, currentHash);
139: 
140:               result.updated++;
141:               logger.info(`Updated card ${card.productId}: ${card.name} with numbers: ${cardNumbers.join(", ")}`);
142:             } catch (error) {
143:               const errorMessage = error instanceof Error ? error.message : "Unknown error";
144:               result.errors.push(`Error processing card ${card.productId}: ${errorMessage}`);
145:               logger.error(`Error processing card ${card.productId}`, { error: errorMessage });
146:             }
147:           })
148:         );
149:       } catch (error) {
150:         const errorMessage = error instanceof Error ? error.message : "Unknown error";
151:         result.errors.push(`Error processing batch: ${errorMessage}`);
152:         logger.error("Error processing batch", { error: errorMessage });
153:       }
154:     }
155: 
156:     return result;
157:   }
158: 
159:   async syncCards(options: SyncOptions = {}): Promise<SyncResult> {
160:     const result: SyncResult = {
161:       success: true,
162:       itemsProcessed: 0,
163:       itemsUpdated: 0,
164:       errors: [],
165:       timing: {
166:         startTime: new Date(),
167:       },
168:     };
169: 
170:     try {
171:       logger.info("Starting card sync", { options });
172: 
173:       const groups = options.groupId ? [{ groupId: options.groupId }] : await tcgcsvApi.getGroups();
174:       logger.info(`Found ${groups.length} groups to process`);
175: 
176:       for (const group of groups) {
177:         result.timing.groupStartTime = new Date();
178:         try {
179:           const cards = await tcgcsvApi.getGroupProducts(group.groupId);
180:           logger.info(`Retrieved ${cards.length} cards for group ${group.groupId}`);
181: 
182:           const batchResult = await this.processCardBatch(cards, group.groupId, options);
183: 
184:           result.itemsProcessed += batchResult.processed;
185:           result.itemsUpdated += batchResult.updated;
186:           result.errors.push(...batchResult.errors);
187: 
188:           this.updateTiming(result.timing);
189:         } catch (error) {
190:           const errorMessage = error instanceof Error ? error.message : "Unknown error";
191:           result.errors.push(`Error processing group ${group.groupId}: ${errorMessage}`);
192:           logger.error(`Error processing group ${group.groupId}`, { error: errorMessage });
193:         }
194:       }
195:     } catch (error) {
196:       result.success = false;
197:       const errorMessage = error instanceof Error ? error.message : "Unknown error";
198:       result.errors.push(`Card sync failed: ${errorMessage}`);
199:       logger.error("Card sync failed", { error: errorMessage });
200:     }
201: 
202:     result.timing.endTime = new Date();
203:     result.timing.duration = (result.timing.endTime.getTime() - result.timing.startTime.getTime()) / 1000;
204: 
205:     logger.logSyncStats({
206:       startTime: result.timing.startTime,
207:       endTime: result.timing.endTime,
208:       totalItems: result.itemsProcessed,
209:       successCount: result.itemsUpdated,
210:       errorCount: result.errors.length,
211:       duration: result.timing.duration,
212:     });
213: 
214:     return result;
215:   }
216: }
217: 
218: export const cardSync = new CardSyncService();
</file>

<file path="functions/src/services/priceSync.ts">
  1: // src/services/priceSync.ts
  2: import { db } from "../config/firebase";
  3: import { tcgcsvApi } from "../utils/api";
  4: import { CardPrice, SyncResult, SyncTiming, SyncOptions } from "../types";
  5: import { logger } from "../utils/logger";
  6: import * as crypto from "crypto";
  7: 
  8: export class PriceSyncService {
  9:   private readonly PRICES_COLLECTION = "prices";
 10:   private readonly HISTORICAL_PRICES_COLLECTION = "historicalPrices";
 11:   private readonly HASH_COLLECTION = "priceHashes";
 12: 
 13:   private calculateHash(price: CardPrice): string {
 14:     const relevantData = {
 15:       normal: price.normal,
 16:       foil: price.foil,
 17:       lastUpdated: price.lastUpdated,
 18:     };
 19:     return crypto.createHash("md5").update(JSON.stringify(relevantData)).digest("hex");
 20:   }
 21: 
 22:   private async getStoredHash(productId: number): Promise<string | null> {
 23:     const doc = await db.collection(this.HASH_COLLECTION).doc(productId.toString()).get();
 24:     return doc.exists ? doc.data()?.hash : null;
 25:   }
 26: 
 27:   private async updateStoredHash(productId: number, hash: string): Promise<void> {
 28:     await db.collection(this.HASH_COLLECTION).doc(productId.toString()).set({
 29:       hash,
 30:       lastUpdated: new Date(),
 31:     });
 32:   }
 33: 
 34:   private validatePrice(price: CardPrice): boolean {
 35:     const validatePriceData = (data: typeof price.normal | typeof price.foil) => {
 36:       if (!data) return false;
 37:       return true; // Accept any price data as valid
 38:     };
 39: 
 40:     const hasValidNormal = price.normal ? validatePriceData(price.normal) : false;
 41:     const hasValidFoil = price.foil ? validatePriceData(price.foil) : false;
 42: 
 43:     return hasValidNormal || hasValidFoil;
 44:   }
 45: 
 46:   private updateTiming(timing: SyncTiming): void {
 47:     timing.lastUpdateTime = new Date();
 48:     if (timing.startTime) {
 49:       timing.duration = (timing.lastUpdateTime.getTime() - timing.startTime.getTime()) / 1000;
 50:     }
 51:     logger.info(`Price sync progress - Duration: ${timing.duration}s`, {
 52:       lastUpdate: timing.lastUpdateTime,
 53:       duration: timing.duration,
 54:     });
 55:   }
 56: 
 57:   private async saveHistoricalPrice(price: CardPrice, groupId: string): Promise<void> {
 58:     const today = new Date();
 59:     today.setHours(0, 0, 0, 0);
 60:     const docId = `${price.productId}_${today.toISOString().split("T")[0]}`;
 61: 
 62:     // Check if we already have today's record
 63:     const docRef = db.collection(this.HISTORICAL_PRICES_COLLECTION).doc(docId);
 64:     const doc = await docRef.get();
 65: 
 66:     if (doc.exists) {
 67:       logger.info(`Historical price for ${price.productId} already exists for today, skipping`);
 68:       return;
 69:     }
 70: 
 71:     const historicalPrice = {
 72:       productId: price.productId,
 73:       groupId,
 74:       date: today,
 75:       ...(price.normal && {
 76:         normal: {
 77:           directLow: price.normal.directLowPrice,
 78:           high: price.normal.highPrice,
 79:           low: price.normal.lowPrice,
 80:           market: price.normal.marketPrice,
 81:           mid: price.normal.midPrice,
 82:         },
 83:       }),
 84:       ...(price.foil && {
 85:         foil: {
 86:           directLow: price.foil.directLowPrice,
 87:           high: price.foil.highPrice,
 88:           low: price.foil.lowPrice,
 89:           market: price.foil.marketPrice,
 90:           mid: price.foil.midPrice,
 91:         },
 92:       }),
 93:     };
 94: 
 95:     await docRef.set(historicalPrice);
 96:     logger.info(`Saved historical price for product ${price.productId} for date ${today.toISOString().split("T")[0]}`);
 97:   }
 98: 
 99:   // src/services/priceSync.ts - Update processPriceBatch method
100:   private async processPriceBatch(
101:     prices: CardPrice[],
102:     groupId: string,
103:     options: { forceUpdate?: boolean } = {}
104:   ): Promise<{
105:   processed: number;
106:   updated: number;
107:   errors: string[];
108: }> {
109:     const result = {
110:       processed: 0,
111:       updated: 0,
112:       errors: [] as string[],
113:     };
114: 
115:     const writeBatch = db.batch();
116:     const updates: Array<() => Promise<void>> = [];
117: 
118:     for (const price of prices) {
119:       try {
120:         result.processed++;
121: 
122:         if (!this.validatePrice(price)) {
123:           logger.info(`Skipping price for product ${price.productId} - no valid price data`);
124:           continue;
125:         }
126: 
127:         const currentHash = this.calculateHash(price);
128:         const storedHash = await this.getStoredHash(price.productId);
129: 
130:         // Always save historical price
131:         updates.push(() => this.saveHistoricalPrice(price, groupId));
132: 
133:         if (currentHash === storedHash && !options.forceUpdate) {
134:           logger.info(`Skipping price update for ${price.productId} - no changes`);
135:           continue;
136:         }
137: 
138:         const priceDoc = {
139:           ...price,
140:           lastUpdated: new Date(),
141:           groupId,
142:         };
143: 
144:         writeBatch.set(
145:           db.collection(this.PRICES_COLLECTION).doc(price.productId.toString()),
146:           priceDoc,
147:           { merge: true }
148:         );
149: 
150:         updates.push(() => this.updateStoredHash(price.productId, currentHash));
151:         result.updated++;
152:       } catch (error) {
153:         const errorMessage = error instanceof Error ? error.message : "Unknown error";
154:         result.errors.push(`Error processing price for product ${price.productId}: ${errorMessage}`);
155:         logger.error(`Error processing price for product ${price.productId}`, { error: errorMessage });
156:       }
157:     }
158: 
159:     try {
160:       await writeBatch.commit();
161:       await Promise.all(updates.map((update) => update()));
162:     } catch (error) {
163:       const errorMessage = error instanceof Error ? error.message : "Unknown error";
164:       result.errors.push(`Error committing batch: ${errorMessage}`);
165:       logger.error("Error committing batch", { error: errorMessage });
166:     }
167: 
168:     return result;
169:   }
170: 
171:   async syncPrices(options: SyncOptions = {}): Promise<SyncResult> {
172:     const result: SyncResult = {
173:       success: true,
174:       itemsProcessed: 0,
175:       itemsUpdated: 0,
176:       errors: [],
177:       timing: {
178:         startTime: new Date(),
179:       },
180:     };
181: 
182:     try {
183:       logger.info("Starting price sync", { options });
184: 
185:       const groups = options.groupId ? [{ groupId: options.groupId }] : await tcgcsvApi.getGroups();
186:       logger.info(`Found ${groups.length} groups to process`);
187: 
188:       for (const group of groups) {
189:         result.timing.groupStartTime = new Date();
190:         try {
191:           const prices = await tcgcsvApi.getGroupPrices(group.groupId);
192:           logger.info(`Retrieved ${prices.length} prices for group ${group.groupId}`);
193: 
194:           const batchResult = await this.processPriceBatch(prices, group.groupId, options);
195: 
196:           result.itemsProcessed += batchResult.processed;
197:           result.itemsUpdated += batchResult.updated;
198:           result.errors.push(...batchResult.errors);
199: 
200:           this.updateTiming(result.timing);
201:         } catch (error) {
202:           const errorMessage = error instanceof Error ? error.message : "Unknown error";
203:           result.errors.push(`Error processing prices for group ${group.groupId}: ${errorMessage}`);
204:           logger.error(`Error processing prices for group ${group.groupId}`, { error: errorMessage });
205:         }
206:       }
207:     } catch (error) {
208:       result.success = false;
209:       const errorMessage = error instanceof Error ? error.message : "Unknown error";
210:       result.errors.push(`Price sync failed: ${errorMessage}`);
211:       logger.error("Price sync failed", { error: errorMessage });
212:     }
213: 
214:     result.timing.endTime = new Date();
215:     result.timing.duration = (result.timing.endTime.getTime() - result.timing.startTime.getTime()) / 1000;
216: 
217:     logger.info(`Price sync completed in ${result.timing.duration}s`, {
218:       processed: result.itemsProcessed,
219:       updated: result.itemsUpdated,
220:       errors: result.errors.length,
221:       timing: result.timing,
222:     });
223: 
224:     return result;
225:   }
226: }
227: 
228: export const priceSync = new PriceSyncService();
</file>

<file path="functions/src/services/storageService.ts">
  1: // src/services/storageService.ts
  2: import { S3Client, PutObjectCommand, HeadObjectCommand } from "@aws-sdk/client-s3";
  3: import axios from "axios";
  4: import { R2_CONFIG } from "../config/r2";
  5: import { logger } from "../utils/logger";
  6: 
  7: interface ImageResult {
  8:   highResUrl: string;
  9:   lowResUrl: string;
 10:   metadata: {
 11:     contentType: string;
 12:     productId: string;
 13:     groupId: string;
 14:     lastUpdated: string;
 15:     isPlaceholder?: boolean;
 16:     originalUrl?: string;
 17:     existingImage?: boolean;
 18:     errorMessage?: string;
 19:   };
 20: }
 21: 
 22: export class StorageService {
 23:   private client: S3Client;
 24:   private readonly bucket: string;
 25:   private readonly customDomain: string;
 26:   private readonly storagePath: string;
 27:   private readonly maxRetries = 3;
 28:   private readonly timeoutMs = 30000; // 30 seconds
 29:   private readonly PLACEHOLDER_URL = "https://fftcgcompanion.com/card-images/image-coming-soon.jpeg";
 30: 
 31:   constructor() {
 32:     this.client = new S3Client({
 33:       region: "auto",
 34:       endpoint: `https://${R2_CONFIG.ACCOUNT_ID}.r2.cloudflarestorage.com`,
 35:       credentials: {
 36:         accessKeyId: R2_CONFIG.ACCESS_KEY_ID,
 37:         secretAccessKey: R2_CONFIG.SECRET_ACCESS_KEY,
 38:       },
 39:       forcePathStyle: true,
 40:     });
 41: 
 42:     this.bucket = R2_CONFIG.BUCKET_NAME;
 43:     this.customDomain = R2_CONFIG.CUSTOM_DOMAIN;
 44:     this.storagePath = R2_CONFIG.STORAGE_PATH;
 45:   }
 46: 
 47:   private isValidImageUrl(url: string | undefined): boolean {
 48:     if (!url) return false;
 49: 
 50:     // Check for TCGPlayer's standard image size patterns, regardless of format
 51:     const validPatterns = [
 52:       "_200w.", // Match _200w followed by any extension
 53:       "_400w.", // Match _400w followed by any extension
 54:       "_1000x1000.", // Match _1000x1000 followed by any extension
 55:     ];
 56: 
 57:     // If URL contains any of our valid patterns, it's a valid TCGPlayer image URL
 58:     const isValidPattern = validPatterns.some((pattern) => url.includes(pattern));
 59: 
 60:     // If URL is from TCGPlayer but doesn't match our patterns, or is any other URL, consider it invalid
 61:     if (!isValidPattern) {
 62:       logger.info(`Invalid image URL pattern: ${url}, using placeholder`);
 63:       return false;
 64:     }
 65: 
 66:     return true;
 67:   }
 68: 
 69:   private async checkImageExists(path: string): Promise<boolean> {
 70:     try {
 71:       await this.client.send(
 72:         new HeadObjectCommand({
 73:           Bucket: this.bucket,
 74:           Key: path,
 75:         })
 76:       );
 77:       return true;
 78:     } catch (error) {
 79:       return false;
 80:     }
 81:   }
 82: 
 83:   private async validateImage(buffer: Buffer): Promise<boolean> {
 84:     if (buffer.length < 4) return false;
 85: 
 86:     const header = buffer.slice(0, 4);
 87:     // JPEG magic number: FF D8 FF
 88:     const isJPEG = header[0] === 0xff && header[1] === 0xd8 && header[2] === 0xff;
 89:     // PNG magic number: 89 50 4E 47
 90:     const isPNG = header[0] === 0x89 && header[1] === 0x50 && header[2] === 0x4e && header[3] === 0x47;
 91: 
 92:     return isJPEG || isPNG;
 93:   }
 94: 
 95:   private async downloadImage(url: string, retries = this.maxRetries): Promise<Buffer> {
 96:     let lastError: Error | null = null;
 97: 
 98:     for (let attempt = 0; attempt <= retries; attempt++) {
 99:       try {
100:         const response = await axios.get(url, {
101:           responseType: "arraybuffer",
102:           timeout: this.timeoutMs,
103:           headers: {
104:             "User-Agent": "FFTCG-Sync-Service/1.0",
105:             "Accept": "image/jpeg,image/png,image/*",
106:           },
107:           maxContentLength: 10 * 1024 * 1024, // 10MB max
108:           validateStatus: (status) => status === 200, // Only accept 200 status
109:         });
110: 
111:         const buffer = Buffer.from(response.data);
112: 
113:         if (await this.validateImage(buffer)) {
114:           return buffer;
115:         } else {
116:           throw new Error("Invalid image format");
117:         }
118:       } catch (error) {
119:         lastError = error instanceof Error ? error : new Error(String(error));
120:         const axiosError = error as { response?: { status?: number } };
121: 
122:         logger.error(`Failed to download image (attempt ${attempt + 1}/${retries + 1})`, {
123:           url,
124:           error: lastError.message,
125:           status: axiosError?.response?.status,
126:         });
127: 
128:         if (attempt === retries) break;
129:         await new Promise((resolve) => setTimeout(resolve, 2000 * Math.pow(2, attempt)));
130:       }
131:     }
132: 
133:     throw lastError || new Error("Download failed after retries");
134:   }
135: 
136:   private async uploadToR2WithRetry(
137:     buffer: Buffer,
138:     path: string,
139:     metadata: Record<string, string>,
140:     retries = this.maxRetries
141:   ): Promise<string> {
142:     let lastError: Error | null = null;
143: 
144:     const stringMetadata = Object.entries(metadata).reduce(
145:       (acc, [key, value]) => ({
146:         ...acc,
147:         [key]: String(value),
148:       }),
149:       {}
150:     );
151: 
152:     for (let attempt = 0; attempt <= retries; attempt++) {
153:       try {
154:         await this.client.send(
155:           new PutObjectCommand({
156:             Bucket: this.bucket,
157:             Key: path,
158:             Body: buffer,
159:             ContentType: "image/jpeg",
160:             Metadata: stringMetadata,
161:             ContentLength: buffer.length,
162:             CacheControl: "public, max-age=31536000",
163:             ACL: "public-read",
164:           })
165:         );
166:         return `${this.customDomain}/${path}`;
167:       } catch (error) {
168:         lastError = error instanceof Error ? error : new Error(String(error));
169:         logger.error(`Upload attempt ${attempt + 1} failed`, {
170:           path,
171:           error: lastError.message,
172:         });
173:         if (attempt === retries) break;
174:         await new Promise((resolve) => setTimeout(resolve, 1000 * (attempt + 1)));
175:       }
176:     }
177: 
178:     throw lastError || new Error("Upload failed after retries");
179:   }
180: 
181:   private getImagePath(groupId: string, cardNumber: string, resolution: "200w" | "400w"): string {
182:     return `${this.storagePath}/${groupId}/${cardNumber}_${resolution}.jpg`;
183:   }
184: 
185:   public async processAndStoreImage(
186:     imageUrl: string | undefined,
187:     productId: number,
188:     groupId: string,
189:     cardNumber: string
190:   ): Promise<ImageResult> {
191:     const baseMetadata = {
192:       productId: productId.toString(),
193:       groupId,
194:       lastUpdated: new Date().toISOString(),
195:       contentType: "image/jpeg",
196:     };
197: 
198:     // Check for valid TCGPlayer URL first
199:     if (!this.isValidImageUrl(imageUrl)) {
200:       logger.info(`Invalid TCGPlayer image URL for product ${productId}, using placeholder`, {
201:         imageUrl,
202:         productId,
203:       });
204:       return {
205:         highResUrl: this.PLACEHOLDER_URL,
206:         lowResUrl: this.PLACEHOLDER_URL,
207:         metadata: {
208:           ...baseMetadata,
209:           isPlaceholder: true,
210:           originalUrl: imageUrl,
211:           errorMessage: "Invalid TCGPlayer URL pattern",
212:         },
213:       };
214:     }
215: 
216:     try {
217:       // Check if images already exist in R2
218:       const highResPath = this.getImagePath(groupId, cardNumber, "400w");
219:       const lowResPath = this.getImagePath(groupId, cardNumber, "200w");
220: 
221:       const [highResExists, lowResExists] = await Promise.all([
222:         this.checkImageExists(highResPath),
223:         this.checkImageExists(lowResPath),
224:       ]);
225: 
226:       // If both images exist, return their URLs
227:       if (highResExists && lowResExists) {
228:         const existingHighResUrl = `${this.customDomain}/${highResPath}`;
229:         const existingLowResUrl = `${this.customDomain}/${lowResPath}`;
230: 
231:         logger.info(`Using existing images for product ${productId}`);
232:         return {
233:           highResUrl: existingHighResUrl,
234:           lowResUrl: existingLowResUrl,
235:           metadata: {
236:             ...baseMetadata,
237:             originalUrl: imageUrl,
238:             existingImage: true,
239:           },
240:         };
241:       }
242: 
243:       try {
244:         // Download from TCGPlayer with different resolutions
245:         // Using optional chaining and providing fallback for undefined case
246:         const baseUrl = imageUrl || "";
247:         const highResTcgUrl = baseUrl.replace("/fit-in/", "/fit-in/437x437/");
248:         const lowResTcgUrl = baseUrl.replace("/fit-in/", "/fit-in/223x223/");
249: 
250:         const [highResBuffer, lowResBuffer] = await Promise.all([
251:           this.downloadImage(highResTcgUrl),
252:           this.downloadImage(lowResTcgUrl),
253:         ]);
254: 
255:         // Upload both versions to R2
256:         const [storedHighResUrl, storedLowResUrl] = await Promise.all([
257:           this.uploadToR2WithRetry(highResBuffer, highResPath, baseMetadata),
258:           this.uploadToR2WithRetry(lowResBuffer, lowResPath, baseMetadata),
259:         ]);
260: 
261:         return {
262:           highResUrl: storedHighResUrl,
263:           lowResUrl: storedLowResUrl,
264:           metadata: {
265:             ...baseMetadata,
266:             originalUrl: imageUrl,
267:           },
268:         };
269:       } catch (error) {
270:         logger.error(`Failed to process images for ${productId}`, { error });
271:         return {
272:           highResUrl: this.PLACEHOLDER_URL,
273:           lowResUrl: this.PLACEHOLDER_URL,
274:           metadata: {
275:             ...baseMetadata,
276:             isPlaceholder: true,
277:             originalUrl: imageUrl,
278:             errorMessage: error instanceof Error ? error.message : "Unknown error",
279:           },
280:         };
281:       }
282:     } catch (error) {
283:       logger.error(`Failed to process images for ${productId}`, { error });
284:       return {
285:         highResUrl: this.PLACEHOLDER_URL,
286:         lowResUrl: this.PLACEHOLDER_URL,
287:         metadata: {
288:           ...baseMetadata,
289:           isPlaceholder: true,
290:           originalUrl: imageUrl,
291:           errorMessage: error instanceof Error ? error.message : "Unknown error",
292:         },
293:       };
294:     }
295:   }
296: }
297: 
298: export const storageService = new StorageService();
</file>

<file path="functions/src/types/index.ts">
 1: export interface CardProduct {
 2:   productId: number;
 3:   name: string;
 4:   cleanName: string;
 5:   imageUrl?: string;
 6:   categoryId: number;
 7:   groupId: number;
 8:   url: string;
 9:   modifiedOn: string;
10:   imageCount: number;
11:   extendedData: Array<{
12:     name: string;
13:     displayName: string;
14:     value: string;
15:   }>;
16: }
17: 
18: export interface CardPrice {
19:   productId: number;
20:   normal?: {
21:     directLowPrice: number | null;
22:     highPrice: number;
23:     lowPrice: number;
24:     marketPrice: number;
25:     midPrice: number;
26:     subTypeName: "Normal";
27:   };
28:   foil?: {
29:     directLowPrice: number | null;
30:     highPrice: number;
31:     lowPrice: number;
32:     marketPrice: number;
33:     midPrice: number;
34:     subTypeName: "Foil";
35:   };
36:   lastUpdated: Date;
37: }
38: 
39: export interface HistoricalPrice {
40:   productId: number;
41:   date: Date;
42:   normal?: {
43:     directLow: number | null;
44:     high: number;
45:     low: number;
46:     market: number;
47:     mid: number;
48:   };
49:   foil?: {
50:     directLow: number | null;
51:     high: number;
52:     low: number;
53:     market: number;
54:     mid: number;
55:   };
56:   groupId: string;
57: }
58: 
59: export interface SyncTiming {
60:   startTime: Date;
61:   endTime?: Date;
62:   duration?: number;
63:   groupStartTime?: Date;
64:   imageStartTime?: Date;
65:   lastUpdateTime?: Date;
66: }
67: 
68: export interface SyncResult {
69:   success: boolean;
70:   itemsProcessed: number;
71:   itemsUpdated: number;
72:   errors: string[];
73:   timing: SyncTiming;
74: }
75: 
76: export interface CardHashData {
77:   name: string;
78:   cleanName: string;
79:   modifiedOn: string;
80:   extendedData: Array<{
81:     name: string;
82:     displayName: string;
83:     value: string;
84:   }>;
85: }
86: 
87: export interface SyncOptions {
88:   groupId?: string;
89:   forceUpdate?: boolean;
90:   skipImages?: boolean;
91:   imagesOnly?: boolean;
92:   silent?: boolean;
93:   dryRun?: boolean;
94: }
</file>

<file path="functions/src/utils/api.ts">
  1: import axios, { AxiosError } from "axios";
  2: import { CardProduct, CardPrice } from "../types";
  3: import { logger } from "./logger";
  4: 
  5: export class TcgcsvApi {
  6:   private readonly baseUrl = "https://tcgcsv.com/tcgplayer";
  7:   private readonly categoryId = "24"; // Final Fantasy TCG
  8: 
  9:   private async makeRequest<T>(endpoint: string): Promise<T> {
 10:     const url = `${this.baseUrl}/${endpoint}`;
 11:     logger.info(`Making request to: ${url}`);
 12: 
 13:     try {
 14:       const response = await axios.get<T>(url, {
 15:         timeout: 30000,
 16:         headers: {
 17:           "Accept": "application/json",
 18:           "User-Agent": "FFTCG-Sync-Service/1.0",
 19:         },
 20:       });
 21:       return response.data;
 22:     } catch (error) {
 23:       if (error instanceof AxiosError && error.response?.status === 403) {
 24:         throw new Error(`Access denied to TCGCSV API at path: ${endpoint}`);
 25:       }
 26:       throw error;
 27:     }
 28:   }
 29: 
 30:   async getGroups(): Promise<Array<{ groupId: string }>> {
 31:     const response = await this.makeRequest<{ results: Array<{ groupId: string }> }>(`${this.categoryId}/groups`);
 32:     logger.info(`Retrieved ${response.results.length} groups`);
 33:     return response.results;
 34:   }
 35: 
 36:   async getGroupProducts(groupId: string): Promise<CardProduct[]> {
 37:     const response = await this.makeRequest<{ results: CardProduct[] }>(`${this.categoryId}/${groupId}/products`);
 38:     logger.info(`Retrieved ${response.results.length} products for group ${groupId}`);
 39: 
 40:     // Transform the results to use correct image URLs
 41:     const products = response.results.map((product) => ({
 42:       ...product,
 43:       // No modification needed, keep original TCGPlayer URL
 44:     }));
 45: 
 46:     return products;
 47:   }
 48: 
 49:   async getGroupPrices(groupId: string): Promise<CardPrice[]> {
 50:     interface RawPriceData {
 51:       productId: number;
 52:       lowPrice: number | null;
 53:       midPrice: number | null;
 54:       highPrice: number | null;
 55:       marketPrice: number | null;
 56:       directLowPrice: number | null;
 57:       subTypeName: string;
 58:     }
 59: 
 60:     interface PriceResponse {
 61:       success: boolean;
 62:       errors: string[];
 63:       results: RawPriceData[];
 64:     }
 65: 
 66:     const response = await this.makeRequest<PriceResponse>(`${this.categoryId}/${groupId}/prices`);
 67:     logger.info(`Retrieved ${response.results.length} prices for group ${groupId}`);
 68: 
 69:     // Group prices by productId
 70:     const priceMap = new Map<number, CardPrice>();
 71: 
 72:     response.results.forEach((price) => {
 73:       const existing = priceMap.get(price.productId) || {
 74:         productId: price.productId,
 75:         lastUpdated: new Date(),
 76:       };
 77: 
 78:       if (price.subTypeName === "Normal") {
 79:         existing.normal = {
 80:           directLowPrice: price.directLowPrice,
 81:           highPrice: price.highPrice || 0,
 82:           lowPrice: price.lowPrice || 0,
 83:           marketPrice: price.marketPrice || 0,
 84:           midPrice: price.midPrice || 0,
 85:           subTypeName: "Normal",
 86:         };
 87:       } else if (price.subTypeName === "Foil") {
 88:         existing.foil = {
 89:           directLowPrice: price.directLowPrice,
 90:           highPrice: price.highPrice || 0,
 91:           lowPrice: price.lowPrice || 0,
 92:           marketPrice: price.marketPrice || 0,
 93:           midPrice: price.midPrice || 0,
 94:           subTypeName: "Foil",
 95:         };
 96:       }
 97: 
 98:       priceMap.set(price.productId, existing);
 99:     });
100: 
101:     return Array.from(priceMap.values());
102:   }
103: }
104: 
105: export const tcgcsvApi = new TcgcsvApi();
</file>

<file path="functions/src/utils/logger.ts">
 1: // src/utils/logger.ts
 2: import { db } from "../config/firebase";
 3: import { environment } from "../config/environment";
 4: import { SyncResult } from "../types";
 5: 
 6: export type LogData = Record<string, unknown>;
 7: 
 8: export interface SyncStats {
 9:   startTime: Date;
10:   endTime?: Date;
11:   totalItems: number;
12:   successCount: number;
13:   errorCount: number;
14:   duration?: number;
15: }
16: 
17: export class Logger {
18:   private readonly COLLECTION = "logs";
19: 
20:   async info(message: string, data?: LogData | SyncResult): Promise<void> {
21:     await this.log("INFO", message, data);
22:   }
23: 
24:   async error(message: string, data?: LogData | { error: unknown }): Promise<void> {
25:     await this.log("ERROR", message, data);
26:   }
27: 
28:   async logSyncStats(stats: SyncStats): Promise<void> {
29:     const duration = stats.endTime ? (stats.endTime.getTime() - stats.startTime.getTime()) / 1000 : undefined;
30: 
31:     const successRate = ((stats.successCount / stats.totalItems) * 100).toFixed(1);
32: 
33:     console.log({
34:       duration: duration ? `${duration}s` : "unknown",
35:       successRate: `${successRate}%`,
36:       totalItems: stats.totalItems,
37:       successful: stats.successCount,
38:       errors: stats.errorCount,
39:     });
40: 
41:     if (!environment.isLocal) {
42:       await db.collection(this.COLLECTION).add({
43:         type: "SYNC_STATS",
44:         timestamp: new Date(),
45:         stats: {
46:           ...stats,
47:           duration,
48:           successRate: parseFloat(successRate),
49:         },
50:       });
51:     }
52:   }
53: 
54:   async log(
55:     level: "INFO" | "ERROR",
56:     message: string,
57:     metadata?: LogData | SyncResult | { error: unknown }
58:   ): Promise<void> {
59:     const entry = {
60:       timestamp: new Date(),
61:       level,
62:       message,
63:       metadata: metadata || null,
64:       environment: environment.nodeEnv,
65:     };
66: 
67:     // Always log to console with appropriate level
68:     const logFn = level === "ERROR" ? console.error : console.log;
69:     logFn(`[${level}] ${message}`, metadata || "");
70: 
71:     // Only log to Firestore if not in local development
72:     if (!environment.isLocal) {
73:       try {
74:         await db.collection(this.COLLECTION).add(entry);
75:       } catch (error) {
76:         console.error("Failed to write log to Firestore:", error);
77:         // Don't throw the error to prevent disrupting the application
78:       }
79:     }
80:   }
81: }
82: 
83: export const logger = new Logger();
</file>

<file path="functions/src/utils/retention.ts">
 1: import { db } from "../config/firebase";
 2: import { logger } from "./logger";
 3: 
 4: export class RetentionService {
 5:   private readonly RETENTION_CONFIG = {
 6:     logs: 7,
 7:     cardHashes: 7,
 8:     priceHashes: 7,
 9:     syncMetadata: 7,
10:   };
11: 
12:   async cleanOldData(): Promise<void> {
13:     try {
14:       logger.info("Starting data retention cleanup");
15: 
16:       for (const [collection, days] of Object.entries(this.RETENTION_CONFIG)) {
17:         const cutoff = new Date();
18:         cutoff.setDate(cutoff.getDate() - days);
19: 
20:         const snapshot = await db.collection(collection).where("lastUpdated", "<", cutoff).get();
21: 
22:         if (!snapshot.empty) {
23:           const batch = db.batch();
24:           snapshot.docs.forEach((doc) => batch.delete(doc.ref));
25:           await batch.commit();
26: 
27:           logger.info(`Cleaned up ${snapshot.size} documents from ${collection}`);
28:         }
29:       }
30: 
31:       logger.info("Data retention cleanup completed");
32:     } catch (error) {
33:       const errorMessage = error instanceof Error ? error.message : "Unknown error";
34:       logger.error("Data retention cleanup failed", { error: errorMessage });
35:       throw error;
36:     }
37:   }
38: }
39: 
40: export const retention = new RetentionService();
</file>

<file path="functions/src/utils/timeout.ts">
 1: // src/utils/timeout.ts
 2: export class TimeoutError extends Error {
 3:   constructor(message: string) {
 4:     super(message);
 5:     this.name = "TimeoutError";
 6:   }
 7: }
 8: 
 9: export function withTimeout<T>(promise: Promise<T>, timeoutMs: number): Promise<T> {
10:   return Promise.race([
11:     promise,
12:     new Promise<T>((_, reject) => {
13:       setTimeout(() => {
14:         reject(new TimeoutError(`Operation timed out after ${timeoutMs}ms`));
15:       }, timeoutMs);
16:     }),
17:   ]);
18: }
</file>

<file path="functions/tsconfig.dev.json">
1: {
2:   "include": [
3:     ".eslintrc.js"
4:   ]
5: }
</file>

<file path="functions/tsconfig.json">
 1: {
 2:   "compilerOptions": {
 3:     "module": "commonjs",
 4:     "moduleResolution": "node",
 5:     "noImplicitReturns": true,
 6:     "noUnusedLocals": true,
 7:     "outDir": "lib",
 8:     "sourceMap": true,
 9:     "strict": true,
10:     "target": "es2017",
11:     "skipLibCheck": true, // Add this line
12:     "esModuleInterop": true, // Make sure this is present
13:     "resolveJsonModule": true, // Add this line
14:     "baseUrl": "./src", // Add this line
15:     "paths": {
16:       // Add this section
17:       "*": ["*"]
18:     }
19:   },
20:   "compileOnSave": true,
21:   "include": ["src"],
22:   "exclude": ["node_modules", "lib"]
23: }
</file>

<file path="package.json">
 1: {
 2:   "name": "fftcg-sync-service",
 3:   "version": "1.0.0",
 4:   "description": "FFTCG Card Data Sync Service",
 5:   "scripts": {
 6:     "start": "cd functions && npm run serve",
 7:     "build": "cd functions && npm run build",
 8:     "deploy": "cd functions && npm run deploy",
 9:     "test": "cd functions && npm test",
10:     "lint": "cd functions && npm run lint",
11:     "lint:fix": "cd functions && npm run lint:fix",
12:     "serve": "cd functions && npm run serve",
13:     "shell": "cd functions && npm run shell",
14:     "logs": "cd functions && npm run logs",
15:     "install:all": "npm install && cd functions && npm install && npm run build",
16:     "clean": "cd functions && npm run clean"    
17:   },
18:   "devDependencies": {
19:     "@types/express": "^4.17.21",
20:     "@types/node": "^18.19.64",
21:     "@typescript-eslint/eslint-plugin": "^6.0.0",
22:     "@typescript-eslint/parser": "^6.0.0",
23:     "eslint": "^8.0.0",
24:     "eslint-config-google": "^0.14.0",
25:     "eslint-plugin-import": "^2.25.4",
26:     "typescript": "^4.9.5"
27:   },
28:   "engines": {
29:     "node": "18"
30:   },
31:   "private": true,
32:   "dependencies": {
33:     "firebase-functions": "^6.1.0"
34:   }
35: }
</file>

<file path="public/index.html">
 1: <!DOCTYPE html>
 2: <html lang="en">
 3: <head>
 4:     <meta charset="UTF-8">
 5:     <meta name="viewport" content="width=device-width, initial-scale=1.0">
 6:     <title>FFTCG Sync Service</title>
 7:     <style>
 8:         body {
 9:             font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
10:             margin: 0;
11:             padding: 20px;
12:             display: flex;
13:             justify-content: center;
14:             align-items: center;
15:             min-height: 100vh;
16:             text-align: center;
17:             background-color: #f5f5f5;
18:         }
19:         .container {
20:             max-width: 600px;
21:         }
22:         h1 {
23:             color: #333;
24:         }
25:         .docs-link {
26:             display: inline-block;
27:             margin-top: 20px;
28:             padding: 10px 20px;
29:             background-color: #646cff;
30:             color: white;
31:             text-decoration: none;
32:             border-radius: 4px;
33:         }
34:         .docs-link:hover {
35:             background-color: #535bf2;
36:         }
37:     </style>
38: </head>
39: <body>
40:     <div class="container">
41:         <h1>FFTCG Sync Service</h1>
42:         <p>Welcome to the FFTCG Sync Service. This service synchronizes Final Fantasy Trading Card Game data from TCGplayer.</p>
43:         <a href="https://docs-fftcg-sync-service.web.app" class="docs-link">View Documentation</a>
44:     </div>
45: </body>
46: </html>
</file>

<file path="repomix.config.json">
 1: {
 2:   "output": {
 3:     "filePath": "codebase.xml",
 4:     "style": "xml",
 5:     "removeComments": false,
 6:     "removeEmptyLines": false,
 7:     "topFilesLength": 5,
 8:     "showLineNumbers": true,
 9:     "copyToClipboard": false
10:   },
11:   "include": [],
12:   "ignore": {
13:     "useGitignore": true,
14:     "useDefaultPatterns": true,
15:     "customPatterns": []
16:   },
17:   "security": {
18:     "enableSecurityCheck": true
19:   }
20: }
</file>

<file path="storage.rules">
 1: rules_version = '2';
 2: service firebase.storage {
 3:   match /b/{bucket}/o {
 4:     // Helper function to check if user is authorized
 5:     function isAuthorizedUser() {
 6:       return request.auth != null && 
 7:              (request.auth.token.email == 'mrw1986@gmail.com' ||
 8:               request.auth.token.email == 'preliatorzero@gmail.com' ||
 9:               request.auth.token.email == 'fftcgcompanion@gmail.com');
10:     }
11: 
12:     // Helper function to check if request is from Cloud Functions
13:     function isCloudFunction() {
14:       return request.auth != null &&
15:              request.auth.token.firebase.sign_in_provider == 'google.com' &&
16:              request.auth.token.email.matches('.*@firebase.google.com$');
17:     }
18: 
19:     match /{allPaths=**} {
20:       // Allow public read access to all files (perfect for card images)
21:       allow read: if true;
22:       
23:       // Allow write access only from:
24:       // 1. Cloud Functions (for automated syncs)
25:       // 2. Authorized users (for manual updates)
26:       allow write: if isCloudFunction() || isAuthorizedUser();
27:     }
28:   }
29: }
</file>

<file path="tsconfig.json">
 1: {
 2:   "extends": "./functions/tsconfig.json",
 3:   "compilerOptions": {
 4:     "baseUrl": ".",
 5:     "paths": {
 6:       "*": ["node_modules/*", "functions/node_modules/*"]
 7:     },
 8:     "types": []
 9:   },
10:   "include": [
11:     "functions/src"
12:   ],
13:   "exclude": [
14:     "node_modules",
15:     "functions/node_modules"
16:   ]
17: }
</file>

</repository_files>
