This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-20T15:40:53.389Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

- Line numbers have been added to the beginning of each line.
</notes>

<additional_info>

For more information about Repomix, visit: https://github.com/yamadashy/repomix
</additional_info>

</file_summary>

<repository_structure>
.eslintrc.fix.js
.eslintrc.js
.firebaserc
firebase.json
firestore.indexes.json
firestore.rules
functions/.eslintignore
functions/.eslintrc.base.cjs
functions/.eslintrc.fix.js
functions/.eslintrc.js
functions/package.json
functions/repomix-output.txt
functions/src/config/firebase.ts
functions/src/global.d.ts
functions/src/index.ts
functions/src/services/cardSync.ts
functions/src/services/priceSync.ts
functions/src/types/express.d.ts
functions/src/types/index.ts
functions/src/types/node.d.ts
functions/src/utils/cache.ts
functions/src/utils/logger.ts
functions/src/utils/progress.ts
functions/tsconfig.dev.json
functions/tsconfig.json
package.json
storage.rules
tsconfig.json
</repository_structure>

<repository_files>
This section contains the contents of the repository's files.

<file path=".eslintrc.fix.js">
 1: module.exports = {
 2:   extends: "./functions/.eslintrc.js",
 3:   rules: {
 4:     "linebreak-style": ["error", "windows"],
 5:     "quotes": ["error", "double"],
 6:     "indent": ["error", 2],
 7:     "object-curly-spacing": ["error", "always"],
 8:     "max-len": ["error", { "code": 120 }],
 9:     "require-jsdoc": "off",
10:     "valid-jsdoc": "off",
11:     "@typescript-eslint/no-explicit-any": "warn",
12:     "comma-dangle": ["error", "always-multiline"]
13:   },
14: };
</file>

<file path=".eslintrc.js">
1: module.exports = {
2:     root: true,
3:     extends: './functions/.eslintrc.js',
4:   };
</file>

<file path=".firebaserc">
1: {
2:   "projects": {
3:     "default": "fftcg-sync-service"
4:   }
5: }
</file>

<file path="firebase.json">
 1: {
 2:   "firestore": {
 3:     "rules": "firestore.rules",
 4:     "indexes": "firestore.indexes.json"
 5:   },
 6:   "functions": [
 7:     {
 8:       "source": "functions",
 9:       "codebase": "default",
10:       "ignore": [
11:         "node_modules",
12:         ".git",
13:         "firebase-debug.log",
14:         "firebase-debug.*.log",
15:         "*.local"
16:       ],
17:       "predeploy": [
18:         "npm --prefix \"$RESOURCE_DIR\" run lint",
19:         "npm --prefix \"$RESOURCE_DIR\" run build"
20:       ]
21:     }
22:   ],
23:   "storage": {
24:     "rules": "storage.rules"
25:   },
26:   "emulators": {
27:     "functions": {
28:       "port": 5001
29:     },
30:     "firestore": {
31:       "port": 8080
32:     },
33:     "storage": {
34:       "port": 9199
35:     },
36:     "ui": {
37:       "enabled": true
38:     },
39:     "singleProjectMode": true
40:   }
41: }
</file>

<file path="firestore.indexes.json">
1: {
2:   "indexes": [],
3:   "fieldOverrides": []
4: }
</file>

<file path="firestore.rules">
1: rules_version = '2';
2: service cloud.firestore {
3:   match /databases/{database}/documents {
4:     match /{document=**} {
5:       // Only allow access from our Cloud Functions
6:       allow read, write: if false;
7:     }
8:   }
9: }
</file>

<file path="functions/.eslintignore">
1: node_modules/
2: lib/
3: coverage/
4: *.d.ts
5: *.cjs
</file>

<file path="functions/.eslintrc.base.cjs">
1: module.exports = {
2:     rules: {
3:       "valid-jsdoc": "off",
4:       "require-jsdoc": "off"
5:     }
6:   };
</file>

<file path="functions/.eslintrc.fix.js">
 1: module.exports = {
 2:   extends: "./.eslintrc.js",
 3:   rules: {
 4:     "max-len": ["error", {"code": 120}],
 5:     "valid-jsdoc": 0,
 6:     "require-jsdoc": 0,
 7:     "@typescript-eslint/no-explicit-any": 0,
 8:     "@typescript-eslint/explicit-function-return-type": 0,
 9:     "@typescript-eslint/explicit-module-boundary-types": 0,
10:     "@typescript-eslint/no-unused-vars": ["error", {
11:       "argsIgnorePattern": "^_",
12:       "varsIgnorePattern": "^_",
13:     }],
14:     // Add these additional rules to be extra sure
15:     "jsdoc/require-jsdoc": 0,
16:     "jsdoc/valid-jsdoc": 0,
17:     "jsdoc/require-param-type": 0,
18:     "jsdoc/require-returns": 0,
19:   },
20: };
</file>

<file path="functions/.eslintrc.js">
 1: module.exports = {
 2:   root: true,
 3:   env: {
 4:     es6: true,
 5:     node: true,
 6:   },
 7:   extends: [
 8:     "eslint:recommended",
 9:     "plugin:import/errors",
10:     "plugin:import/warnings",
11:     "plugin:import/typescript",
12:     "google",
13:     "plugin:@typescript-eslint/recommended",
14:   ],
15:   parser: "@typescript-eslint/parser",
16:   parserOptions: {
17:     project: ["tsconfig.json", "tsconfig.dev.json"],
18:     tsconfigRootDir: __dirname,
19:     sourceType: "module",
20:     createDefaultProgram: true,
21:   },
22:   ignorePatterns: [
23:     "/lib/**/*",
24:     "/generated/**/*",
25:     "node_modules/",
26:     "*.cjs",
27:   ],
28:   plugins: [
29:     "@typescript-eslint",
30:     "import",
31:   ],
32:   rules: {
33:     "quotes": ["error", "double"],
34:     "import/no-unresolved": 0,
35:     "indent": ["error", 2],
36:     "max-len": ["error", {"code": 120}],
37:     "@typescript-eslint/no-explicit-any": "off",
38:     "@typescript-eslint/no-unused-vars": ["error", {
39:       "argsIgnorePattern": "^_",
40:       "varsIgnorePattern": "^_",
41:     }],
42:     "valid-jsdoc": 0,
43:     "require-jsdoc": 0,
44:   },
45:   overrides: [
46:     {
47:       files: ["*.js", "*.cjs"],
48:       rules: {
49:         "@typescript-eslint/no-var-requires": "off",
50:       },
51:     },
52:   ],
53: };
</file>

<file path="functions/package.json">
 1: {
 2:   "name": "functions",
 3:   "scripts": {
 4:     "clean": "rimraf lib",
 5:     "lint": "eslint --ext .js,.ts .",
 6:     "lint:fix": "eslint --ext .js,.ts . --fix",
 7:     "build": "npm run clean && tsc",
 8:     "build:watch": "tsc --watch",
 9:     "serve": "npm run build && firebase emulators:start --only functions,firestore,storage",
10:     "shell": "npm run build && firebase functions:shell",
11:     "start": "npm run shell",
12:     "deploy": "npm run lint:fix && firebase deploy --only functions",
13:     "logs": "firebase functions:log",
14:     "lint:fix:force": "eslint . --ext .js,.ts --fix --config .eslintrc.fix.js"
15:   },
16:   "engines": {
17:     "node": "18"
18:   },
19:   "main": "lib/index.js",
20:   "dependencies": {
21:     "axios": "^1.7.7",
22:     "firebase-admin": "^12.0.0",
23:     "firebase-functions": "^6.1.0",
24:     "lru-cache": "^7.14.1"
25:   },
26:   "devDependencies": {
27:     "@types/express": "^4.17.21",
28:     "@types/node": "^18.19.64",
29:     "@typescript-eslint/eslint-plugin": "^6.0.0",
30:     "@typescript-eslint/parser": "^6.0.0",
31:     "eslint": "^8.0.0",
32:     "eslint-config-google": "^0.14.0",
33:     "eslint-plugin-import": "^2.25.4",
34:     "firebase-functions-test": "^3.1.0",
35:     "rimraf": "^5.0.0",
36:     "typescript": "^4.9.5"
37:   },
38:   "private": true
39: }
</file>

<file path="functions/repomix-output.txt">
  1: This file is a merged representation of the entire codebase, combining all repository files into a single document.
  2: Generated by Repomix on: 2024-11-20T06:59:40.307Z
  3: 
  4: ================================================================
  5: File Summary
  6: ================================================================
  7: 
  8: Purpose:
  9: --------
 10: This file contains a packed representation of the entire repository's contents.
 11: It is designed to be easily consumable by AI systems for analysis, code review,
 12: or other automated processes.
 13: 
 14: File Format:
 15: ------------
 16: The content is organized as follows:
 17: 1. This summary section
 18: 2. Repository information
 19: 3. Repository structure
 20: 4. Multiple file entries, each consisting of:
 21:   a. A separator line (================)
 22:   b. The file path (File: path/to/file)
 23:   c. Another separator line
 24:   d. The full contents of the file
 25:   e. A blank line
 26: 
 27: Usage Guidelines:
 28: -----------------
 29: - This file should be treated as read-only. Any changes should be made to the
 30:   original repository files, not this packed version.
 31: - When processing this file, use the file path to distinguish
 32:   between different files in the repository.
 33: - Be aware that this file may contain sensitive information. Handle it with
 34:   the same level of security as you would the original repository.
 35: 
 36: Notes:
 37: ------
 38: - Some files may have been excluded based on .gitignore rules and Repomix's
 39:   configuration.
 40: - Binary files are not included in this packed representation. Please refer to
 41:   the Repository Structure section for a complete list of file paths, including
 42:   binary files.
 43: 
 44: Additional Info:
 45: ----------------
 46: 
 47: For more information about Repomix, visit: https://github.com/yamadashy/repomix
 48: 
 49: ================================================================
 50: Repository Structure
 51: ================================================================
 52: .eslintrc.fix.js
 53: .eslintrc.js
 54: .gitignore
 55: package.json
 56: src/config/firebase.ts
 57: src/global.d.ts
 58: src/index.ts
 59: src/services/cardSync.ts
 60: src/services/priceSync.ts
 61: src/types/express.d.ts
 62: src/types/index.ts
 63: src/types/node.d.ts
 64: src/utils/cache.ts
 65: src/utils/logger.ts
 66: src/utils/progress.ts
 67: tsconfig.dev.json
 68: tsconfig.json
 69: 
 70: ================================================================
 71: Repository Files
 72: ================================================================
 73: 
 74: ================
 75: File: .eslintrc.fix.js
 76: ================
 77: module.exports = {
 78:     extends: "./.eslintrc.js",
 79:     rules: {
 80:       "max-len": ["error", { "code": 120 }],
 81:       "require-jsdoc": "off",
 82:       "@typescript-eslint/no-explicit-any": "off",
 83:       "@typescript-eslint/no-unused-vars": ["error", { 
 84:         "argsIgnorePattern": "^_",
 85:         "varsIgnorePattern": "^_"
 86:       }]
 87:     },
 88:   };
 89: 
 90: ================
 91: File: .eslintrc.js
 92: ================
 93: module.exports = {
 94:   root: true,
 95:   env: {
 96:     es6: true,
 97:     node: true,
 98:   },
 99:   extends: [
100:     "eslint:recommended",
101:     "plugin:import/errors",
102:     "plugin:import/warnings",
103:     "plugin:import/typescript",
104:     "google",
105:     "plugin:@typescript-eslint/recommended",
106:   ],
107:   parser: "@typescript-eslint/parser",
108:   parserOptions: {
109:     project: ["tsconfig.json", "tsconfig.dev.json"],
110:     sourceType: "module",
111:   },
112:   ignorePatterns: [
113:     "/lib/**/*", // Ignore built files.
114:     "/generated/**/*", // Ignore generated files.
115:   ],
116:   plugins: [
117:     "@typescript-eslint",
118:     "import",
119:   ],
120:   rules: {
121:     "quotes": ["error", "double"],
122:     "import/no-unresolved": 0,
123:     "indent": ["error", 2],
124:   },
125: };
126: 
127: ================
128: File: .gitignore
129: ================
130: # Compiled JavaScript files
131: lib/**/*.js
132: lib/**/*.js.map
133: 
134: # TypeScript v1 declaration files
135: typings/
136: 
137: # Node.js dependency directory
138: node_modules/
139: *.local
140: 
141: ================
142: File: package.json
143: ================
144: {
145:   "name": "functions",
146:   "scripts": {
147:     "clean": "rimraf lib",
148:     "lint": "eslint --ext .js,.ts .",
149:     "lint:fix": "eslint --ext .js,.ts . --fix",
150:     "build": "npm run clean && tsc",
151:     "build:watch": "tsc --watch",
152:     "serve": "npm run build && firebase emulators:start --only functions,firestore,storage",
153:     "shell": "npm run build && firebase functions:shell",
154:     "start": "npm run shell",
155:     "deploy": "npm run lint:fix && firebase deploy --only functions",
156:     "logs": "firebase functions:log"
157:   },
158:   "engines": {
159:     "node": "18"
160:   },
161:   "main": "lib/index.js",
162:   "dependencies": {
163:     "axios": "^1.7.7",
164:     "firebase-admin": "^12.0.0",
165:     "firebase-functions": "^5.1.0",
166:     "lru-cache": "^7.14.1"
167:   },
168:   "devDependencies": {
169:     "@types/express": "^4.17.21",
170:     "@types/node": "^18.0.0",
171:     "@typescript-eslint/eslint-plugin": "^6.0.0",
172:     "@typescript-eslint/parser": "^6.0.0",
173:     "eslint": "^8.0.0",
174:     "eslint-config-google": "^0.14.0",
175:     "eslint-plugin-import": "^2.25.4",
176:     "firebase-functions-test": "^3.1.0",
177:     "rimraf": "^5.0.0",
178:     "typescript": "^4.9.5"
179:   },
180:   "private": true
181: }
182: 
183: ================
184: File: src/config/firebase.ts
185: ================
186: import * as admin from "firebase-admin";
187: 
188: const app = !admin.apps.length ? admin.initializeApp() : admin.app();
189: const db = admin.firestore(app);
190: const storage = admin.storage(app);
191: 
192: export {db, storage}; // Export storage as well
193: 
194: export const COLLECTION = {
195:   CARDS: "cards",
196:   PRICES: "prices",
197:   SYNC_METADATA: "syncMetadata",
198:   LOGS: "logs",
199:   CARD_HASHES: "cardHashes",
200:   PRICE_HASHES: "priceHashes",
201: };
202: 
203: export const STORAGE = {
204:   BUCKETS: {
205:     CARD_IMAGES: "card-images",
206:   },
207:   PATHS: {
208:     IMAGES: "images",
209:   },
210: };
211: 
212: export const BASE_URL = "https://tcgcsv.com";
213: export const FFTCG_CATEGORY_ID = "24";
214: 
215: export const runtimeOpts = {
216:   timeoutSeconds: 540,
217:   memory: "1GB",
218: } as const;
219: 
220: ================
221: File: src/global.d.ts
222: ================
223: /// <reference types="node" />
224: /// <reference types="express" />
225: 
226: ================
227: File: src/index.ts
228: ================
229: import * as functions from "firebase-functions";
230: import {Request, Response} from "express";
231: import {syncCards} from "./services/cardSync";
232: import {syncPrices} from "./services/priceSync";
233: import {runtimeOpts} from "./config/firebase";
234: import {SyncOptions} from "./types";
235: 
236: // Scheduled card sync
237: exports.scheduledCardSync = functions
238:   .runWith(runtimeOpts)
239:   .pubsub.schedule("0 21 * * *")
240:   .timeZone("UTC")
241:   .onRun(async (_context) => {
242:     await syncCards();
243:     return null;
244:   });
245: 
246: // Manual card sync endpoint
247: exports.testCardSync = functions
248:   .runWith(runtimeOpts)
249:   .https.onRequest(async (req: Request, res: Response) => {
250:     const options: SyncOptions = {
251:       dryRun: req.query.dryRun === "true",
252:       limit: req.query.limit ? parseInt(req.query.limit as string) : undefined,
253:       groupId: req.query.groupId as string,
254:     };
255: 
256:     const result = await syncCards(options);
257:     res.json(result);
258:   });
259: 
260: // Scheduled price sync
261: exports.scheduledPriceSync = functions
262:   .runWith(runtimeOpts)
263:   .pubsub.schedule("30 21 * * *")
264:   .timeZone("UTC")
265:   .onRun(async (_context) => {
266:     await syncPrices();
267:     return null;
268:   });
269: 
270: // Manual price sync endpoint
271: exports.testPriceSync = functions
272:   .runWith(runtimeOpts)
273:   .https.onRequest(async (req: Request, res: Response) => {
274:     const options: SyncOptions = {
275:       dryRun: req.query.dryRun === "true",
276:       limit: req.query.limit ? parseInt(req.query.limit as string) : undefined,
277:       groupId: req.query.groupId as string,
278:       productId: req.query.productId ? parseInt(req.query.productId as string) : undefined,
279:       showAll: req.query.showAll === "true",
280:     };
281: 
282:     const result = await syncPrices(options);
283:     res.json(result);
284:   });
285: 
286: ================
287: File: src/services/cardSync.ts
288: ================
289: import axios, {AxiosError} from "axios";
290: import {db, COLLECTION, FFTCG_CATEGORY_ID} from "../config/firebase";
291: import {CardProduct, SyncOptions, SyncMetadata} from "../types";
292: import {cardCache, getCacheKey} from "../utils/cache";
293: import {logError, logInfo, logWarning} from "../utils/logger";
294: import * as crypto from "crypto";
295: 
296: const BASE_URL = "https://tcgcsv.com";
297: const MAX_RETRIES = 3;
298: 
299: async function makeRequest<T>(endpoint: string, retryCount = 0): Promise<T> {
300:   try {
301:     await new Promise((resolve) => setTimeout(resolve, 1000)); // Rate limiting
302:     const url = `${BASE_URL}/${endpoint}`;
303:     await logInfo(`Making request to: ${url} (Attempt ${retryCount + 1}/${MAX_RETRIES})`);
304: 
305:     const response = await axios.get<T>(url);
306:     return response.data;
307:   } catch (error) {
308:     if (retryCount < MAX_RETRIES - 1 && error instanceof AxiosError) {
309:       const delay = Math.pow(2, retryCount) * 1000;
310:       await logWarning(`Request failed, retrying in ${delay}ms...`);
311:       await new Promise((resolve) => setTimeout(resolve, delay));
312:       return makeRequest<T>(endpoint, retryCount + 1);
313:     }
314:     throw error;
315:   }
316: }
317: 
318: function getDataHash(data: any): string {
319:   return crypto.createHash("md5")
320:     .update(JSON.stringify(data, Object.keys(data).sort()))
321:     .digest("hex");
322: }
323: 
324: export async function syncCards(options: SyncOptions = {}): Promise<SyncMetadata> {
325:   const startTime = Date.now();
326:   const metadata: SyncMetadata = {
327:     lastSync: new Date(),
328:     status: "in_progress",
329:     cardCount: 0,
330:     type: options.dryRun ? "manual" : "scheduled",
331:     groupsProcessed: 0,
332:     groupsUpdated: 0,
333:     errors: [],
334:   };
335: 
336:   try {
337:     // Fetch groups
338:     const groupsResponse = await makeRequest<{ results: any[] }>(
339:       `${FFTCG_CATEGORY_ID}/groups`
340:     );
341:     const groups = groupsResponse.results;
342: 
343:     logInfo(`Found ${groups.length} groups`);
344: 
345:     let processedCards = 0;
346:     const existingHashes = new Map<string, string>();
347: 
348:     // Load existing hashes from Firestore
349:     const hashesSnapshot = await db.collection("cardHashes").get();
350:     hashesSnapshot.forEach((doc) => {
351:       existingHashes.set(doc.id, doc.data().hash);
352:     });
353: 
354:     for (const group of groups) {
355:       if (options.groupId && group.groupId !== options.groupId) continue;
356: 
357:       try {
358:         metadata.groupsProcessed++;
359:         const productsResponse = await makeRequest<{ results: CardProduct[] }>(
360:           `${FFTCG_CATEGORY_ID}/${group.groupId}/products`
361:         );
362:         const products = productsResponse.results;
363: 
364:         const groupHash = getDataHash(products);
365:         const existingHash = existingHashes.get(group.groupId.toString());
366: 
367:         if (!options.dryRun && (!existingHash || existingHash !== groupHash)) {
368:           metadata.groupsUpdated++;
369:           const batch = db.batch();
370: 
371:           for (const product of products) {
372:             if (options.limit && processedCards >= options.limit) break;
373: 
374:             const cardRef = db.collection(COLLECTION.CARDS)
375:               .doc(product.productId.toString());
376:             batch.set(cardRef, {
377:               ...product,
378:               lastUpdated: new Date(),
379:               groupHash,
380:             }, {merge: true});
381: 
382:             cardCache.set(getCacheKey("card", product.productId), product);
383:             processedCards++;
384:           }
385: 
386:           // Update hash
387:           const hashRef = db.collection("cardHashes")
388:             .doc(group.groupId.toString());
389:           batch.set(hashRef, {
390:             hash: groupHash,
391:             lastUpdated: new Date(),
392:           });
393: 
394:           await batch.commit();
395:           logInfo(`Updated ${products.length} cards from group ${group.groupId}`);
396:         } else {
397:           logInfo(`No updates needed for group ${group.groupId} (unchanged)`);
398:         }
399: 
400:         metadata.cardCount += products.length;
401:       } catch (error: any) { // Type assertion
402:         const errorMessage = `Error processing group ${group.groupId}: ${error?.message || "Unknown error"}`;
403:         metadata.errors.push(errorMessage);
404:         logError(error, "syncCards:processGroup");
405:       }
406: 
407:       if (options.limit && processedCards >= options.limit) break;
408:     }
409: 
410:     metadata.status = metadata.errors.length > 0 ? "completed_with_errors" : "success";
411:   } catch (error: any) { // Type assertion
412:     metadata.status = "failed";
413:     metadata.errors.push(error?.message || "Unknown error");
414:     logError(error, "syncCards:main");
415:   }
416: 
417:   metadata.lastSync = new Date();
418:   metadata.duration = Date.now() - startTime;
419: 
420:   if (!options.dryRun) {
421:     await db.collection(COLLECTION.SYNC_METADATA)
422:       .add(metadata);
423:   }
424: 
425:   return metadata;
426: }
427: 
428: ================
429: File: src/services/priceSync.ts
430: ================
431: import axios, {AxiosError} from "axios";
432: import {db, COLLECTION, FFTCG_CATEGORY_ID, BASE_URL} from "../config/firebase";
433: import {CardPrice, SyncOptions, SyncMetadata, PriceData} from "../types";
434: import {logError, logInfo, logWarning} from "../utils/logger";
435: import {ProgressTracker} from "../utils/progress";
436: import * as crypto from "crypto";
437: 
438: const MAX_RETRIES = 3;
439: 
440: async function makeRequest<T>(endpoint: string, retryCount = 0): Promise<T> {
441:   try {
442:     await new Promise((resolve) => setTimeout(resolve, 1000)); // Rate limiting
443:     const url = `${BASE_URL}/${endpoint}`;
444:     await logInfo(`Making request to: ${url} (Attempt ${retryCount + 1}/${MAX_RETRIES})`);
445: 
446:     const response = await axios.get<T>(url);
447:     return response.data;
448:   } catch (error) {
449:     if (retryCount < MAX_RETRIES - 1 && error instanceof AxiosError) {
450:       const delay = Math.pow(2, retryCount) * 1000;
451:       await logWarning(`Request failed, retrying in ${delay}ms...`);
452:       await new Promise((resolve) => setTimeout(resolve, delay));
453:       return makeRequest<T>(endpoint, retryCount + 1);
454:     }
455:     throw error;
456:   }
457: }
458: 
459: function getDataHash(data: any): string {
460:   return crypto.createHash("md5")
461:     .update(JSON.stringify(data, Object.keys(data).sort()))
462:     .digest("hex");
463: }
464: 
465: function processPrices(prices: CardPrice[]): Record<number, PriceData> {
466:   const priceMap: Record<number, PriceData> = {};
467: 
468:   prices.forEach((price) => {
469:     if (!priceMap[price.productId]) {
470:       priceMap[price.productId] = {
471:         lastUpdated: new Date(),
472:       };
473:     }
474: 
475:     if (price.subTypeName === "Normal") {
476:       priceMap[price.productId].normal = price;
477:     } else {
478:       priceMap[price.productId].foil = price;
479:     }
480:   });
481: 
482:   return priceMap;
483: }
484: 
485: export async function syncPrices(options: SyncOptions = {}): Promise<SyncMetadata> {
486:   const startTime = Date.now();
487:   const metadata: SyncMetadata = {
488:     lastSync: new Date(),
489:     status: "in_progress",
490:     cardCount: 0,
491:     type: options.dryRun ? "manual" : "scheduled",
492:     groupsProcessed: 0,
493:     groupsUpdated: 0,
494:     errors: [],
495:   };
496: 
497:   try {
498:     // If specific productId is provided, fetch just that group
499:     if (options.productId) {
500:       const card = await db.collection(COLLECTION.CARDS)
501:         .doc(options.productId.toString())
502:         .get();
503: 
504:       if (!card.exists) {
505:         throw new Error(`Card with ID ${options.productId} not found`);
506:       }
507: 
508:       const cardData = card.data();
509:       options.groupId = cardData?.groupId?.toString();
510:     }
511: 
512:     // Fetch groups or use specific group
513:     const groupsResponse = await makeRequest<{ results: any[] }>(
514:       `${FFTCG_CATEGORY_ID}/groups`
515:     );
516:     const groups = groupsResponse.results;
517: 
518:     if (options.groupId) {
519:       const group = groups.find((g) => g.groupId.toString() === options.groupId);
520:       if (!group) {
521:         throw new Error(`Group ${options.groupId} not found`);
522:       }
523:       groups.length = 0;
524:       groups.push(group);
525:     }
526: 
527:     const progress = new ProgressTracker(groups.length, "Processing groups");
528: 
529:     for (const group of groups) {
530:       try {
531:         metadata.groupsProcessed++;
532:         const pricesResponse = await makeRequest<{ results: CardPrice[] }>(
533:           `${FFTCG_CATEGORY_ID}/${group.groupId}/prices`
534:         );
535:         const prices = pricesResponse.results;
536: 
537:         if (options.productId) {
538:           const filteredPrices = prices.filter((p) => p.productId === options.productId);
539:           if (filteredPrices.length === 0) {
540:             throw new Error(`No prices found for product ${options.productId}`);
541:           }
542:           prices.length = 0;
543:           prices.push(...filteredPrices);
544:         }
545: 
546:         const priceHash = getDataHash(prices);
547:         const hashDoc = await db.collection(COLLECTION.PRICE_HASHES)
548:           .doc(group.groupId.toString())
549:           .get();
550: 
551:         const existingHash = hashDoc.exists ? hashDoc.data()?.hash : null;
552: 
553:         if (!options.dryRun && (!existingHash || existingHash !== priceHash)) {
554:           metadata.groupsUpdated++;
555:           const batch = db.batch();
556:           const processedPrices = processPrices(prices);
557: 
558:           for (const [productId, priceData] of Object.entries(processedPrices)) {
559:             if (options.limit && metadata.cardCount >= options.limit) break;
560: 
561:             const priceRef = db.collection(COLLECTION.PRICES)
562:               .doc(productId);
563:             batch.set(priceRef, priceData, {merge: true});
564: 
565:             metadata.cardCount++;
566:           }
567: 
568:           // Update hash
569:           const hashRef = db.collection(COLLECTION.PRICE_HASHES)
570:             .doc(group.groupId.toString());
571:           batch.set(hashRef, {
572:             hash: priceHash,
573:             lastUpdated: new Date(),
574:           });
575: 
576:           await batch.commit();
577:           await logInfo(`Updated ${metadata.cardCount} prices from group ${group.groupId}`);
578:         } else {
579:           await logInfo(`No updates needed for group ${group.groupId} (unchanged)`);
580:         }
581:       } catch (error: any) {
582:         const errorMessage = `Error processing group ${group.groupId}: ${error?.message || "Unknown error"}`;
583:         metadata.errors.push(errorMessage);
584:         await logError(error, "syncPrices:processGroup");
585:       }
586: 
587:       progress.update();
588: 
589:       if (options.limit && metadata.cardCount >= options.limit) break;
590:     }
591: 
592:     metadata.status = metadata.errors.length > 0 ? "completed_with_errors" : "success";
593:   } catch (error: any) {
594:     metadata.status = "failed";
595:     metadata.errors.push(error?.message || "Unknown error");
596:     await logError(error, "syncPrices:main");
597:   }
598: 
599:   metadata.lastSync = new Date();
600:   metadata.duration = Date.now() - startTime;
601: 
602:   if (!options.dryRun) {
603:     await db.collection(COLLECTION.SYNC_METADATA)
604:       .add(metadata);
605:   }
606: 
607:   return metadata;
608: }
609: 
610: ================
611: File: src/types/express.d.ts
612: ================
613: /// <reference types="express" />
614: 
615: ================
616: File: src/types/index.ts
617: ================
618: export interface GenericError extends Error {
619:     code?: string;
620:     message: string;
621:     stack?: string;
622:   }
623:   
624:   export interface CardProduct {
625:     productId: number;
626:     name: string;
627:     cleanName: string;
628:     imageUrl: string;
629:     categoryId: number;
630:     groupId: number;
631:     url: string;
632:     modifiedOn: string;
633:     imageCount: number;
634:     extendedData: Array<{
635:       name: string;
636:       displayName: string;
637:       value: string;
638:     }>;
639:   }
640:   
641:   export interface CardPrice {
642:     productId: number;
643:     lowPrice: number;
644:     midPrice: number;
645:     highPrice: number;
646:     marketPrice: number | null;
647:     directLowPrice: number | null;
648:     subTypeName: "Normal" | "Foil";
649:   }
650:   
651:   export interface SyncOptions {
652:     dryRun?: boolean;
653:     limit?: number;
654:     groupId?: string;
655:     productId?: number;
656:     showAll?: boolean;
657:   }
658:   
659:   export interface SyncMetadata {
660:     lastSync: Date;
661:     status: "in_progress" | "success" | "failed" | "completed_with_errors";
662:     cardCount: number;
663:     type: "manual" | "scheduled";
664:     groupsProcessed: number;
665:     groupsUpdated: number;
666:     errors: string[];
667:     duration?: number;
668:   }
669:   
670:   export type CacheType = "card" | "price";
671:   
672:   export interface PriceData {
673:     normal?: CardPrice;
674:     foil?: CardPrice;
675:     lastUpdated: Date;
676:   }
677:   
678:   export type LogData = any;
679:   export type GenericObject = Record<string, any>;
680: 
681: ================
682: File: src/types/node.d.ts
683: ================
684: /// <reference types="node" />
685: 
686: ================
687: File: src/utils/cache.ts
688: ================
689: import LRUCache from "lru-cache";
690: import {CacheType, CardProduct} from "../types";
691: 
692: const options = {
693:   max: 500,
694:   ttl: 1000 * 60 * 60, // 1 hour
695: };
696: 
697: export const cardCache = new LRUCache<string, CardProduct>(options);
698: 
699: export const getCacheKey = (type: CacheType, id: number): string => {
700:   return `${type}:${id}`;
701: };
702: 
703: ================
704: File: src/utils/logger.ts
705: ================
706: import * as functions from "firebase-functions";
707: import { db, COLLECTION } from "../config/firebase";
708: import { GenericError, LogData, GenericObject } from "../types";
709: 
710: export const logger = functions.logger;
711: 
712: interface LogEntry {
713:   timestamp: Date;
714:   level: "INFO" | "WARNING" | "ERROR";
715:   message: string;
716:   context?: string;
717:   data?: LogData;
718: }
719: 
720: async function saveLogEntry(entry: LogEntry): Promise<void> {
721:   await db.collection(COLLECTION.LOGS).add(entry);
722: }
723: 
724: export const logError = async (error: GenericError | GenericObject, context: string) => {
725:   const entry: LogEntry = {
726:     timestamp: new Date(),
727:     level: "ERROR",
728:     message: error.message || "Unknown error",
729:     context,
730:     data: {
731:       stack: error.stack,
732:       code: error.code,
733:     },
734:   };
735: 
736:   logger.error(entry.message, entry.data);
737:   await saveLogEntry(entry);
738: };
739: 
740: export const logInfo = async (message: string, data?: LogData) => {
741:   const entry: LogEntry = {
742:     timestamp: new Date(),
743:     level: "INFO",
744:     message,
745:     data,
746:   };
747: 
748:   logger.info(message, data);
749:   await saveLogEntry(entry);
750: };
751: 
752: export const logWarning = async (message: string, data?: LogData) => {
753:   const entry: LogEntry = {
754:     timestamp: new Date(),
755:     level: "WARNING",
756:     message,
757:     data,
758:   };
759: 
760:   logger.warn(message, data);
761:   await saveLogEntry(entry);
762: };
763: 
764: ================
765: File: src/utils/progress.ts
766: ================
767: import { logInfo } from "./logger";
768: 
769: /**
770:  * Tracks progress of long-running operations
771:  */
772: export class ProgressTracker {
773:   private startTime: number;
774:   private current: number;
775: 
776:   /**
777:    * Creates a new progress tracker
778:    * @param total Total number of items to process
779:    * @param description Description of the operation
780:    */
781:   constructor(
782:     private total: number,
783:     private description: string,
784:   ) {
785:     this.startTime = Date.now();
786:     this.current = 0;
787:   }
788: 
789:   /**
790:    * Updates progress and logs current status
791:    * @param amount Number of items processed in this update
792:    */
793:   update(amount = 1): void {
794:     this.current += amount;
795:     const elapsed = (Date.now() - this.startTime) / 1000;
796:     const percent = (this.current / this.total) * 100;
797:     const remaining = this.total - this.current;
798: 
799:     logInfo(
800:       `${this.description}: ${this.current}/${this.total} ` +
801:       `(${percent.toFixed(1)}%) - ${remaining} remaining - ` +
802:       `Elapsed time: ${elapsed.toFixed(1)}s`,
803:     );
804:   }
805: 
806:   /**
807:    * Gets current progress status
808:    */
809:   getProgress(): { current: number; total: number; elapsed: number } {
810:     return {
811:       current: this.current,
812:       total: this.total,
813:       elapsed: (Date.now() - this.startTime) / 1000,
814:     };
815:   }
816: }
817: 
818: ================
819: File: tsconfig.dev.json
820: ================
821: {
822:   "include": [
823:     ".eslintrc.js"
824:   ]
825: }
826: 
827: ================
828: File: tsconfig.json
829: ================
830: {
831:   "compilerOptions": {
832:     "module": "commonjs",
833:     "noImplicitReturns": true,
834:     "noUnusedLocals": true,
835:     "outDir": "lib",
836:     "sourceMap": true,
837:     "strict": true,
838:     "target": "es2017",
839:     "esModuleInterop": true,
840:     "skipLibCheck": true,
841:     "resolveJsonModule": true,
842:     "typeRoots": [
843:       "./node_modules/@types"
844:     ],
845:     "types": [
846:       "node",
847:       "express"
848:     ],
849:     "baseUrl": "./src",
850:     "paths": {
851:       "*": ["*", "types/*"]
852:     }
853:   },
854:   "compileOnSave": true,
855:   "include": [
856:     "src"
857:   ],
858:   "exclude": [
859:     "node_modules",
860:     "lib"
861:   ]
862: }
</file>

<file path="functions/src/config/firebase.ts">
 1: import * as admin from "firebase-admin";
 2: 
 3: const app = !admin.apps.length ? admin.initializeApp() : admin.app();
 4: const db = admin.firestore(app);
 5: const storage = admin.storage(app);
 6: 
 7: export {db, storage}; // Export storage as well
 8: 
 9: export const COLLECTION = {
10:   CARDS: "cards",
11:   PRICES: "prices",
12:   SYNC_METADATA: "syncMetadata",
13:   LOGS: "logs",
14:   CARD_HASHES: "cardHashes",
15:   PRICE_HASHES: "priceHashes",
16: };
17: 
18: export const STORAGE = {
19:   BUCKETS: {
20:     CARD_IMAGES: "card-images",
21:   },
22:   PATHS: {
23:     IMAGES: "images",
24:   },
25: };
26: 
27: export const BASE_URL = "https://tcgcsv.com";
28: export const FFTCG_CATEGORY_ID = "24";
29: 
30: export const runtimeOpts = {
31:   timeoutSeconds: 540,
32:   memory: "1GiB", // Changed from "1GB" to "1GiB"
33: } as const;
</file>

<file path="functions/src/global.d.ts">
1: // / <reference types="node" />
2: // / <reference types="express" />
</file>

<file path="functions/src/index.ts">
 1: import {onRequest} from "firebase-functions/v2/https";
 2: import {onSchedule} from "firebase-functions/v2/scheduler";
 3: import {Request, Response} from "express";
 4: import {syncCards} from "./services/cardSync";
 5: import {syncPrices} from "./services/priceSync";
 6: import {runtimeOpts} from "./config/firebase";
 7: import {SyncOptions} from "./types";
 8: 
 9: // Scheduled card sync
10: export const scheduledCardSync = onSchedule({
11:   schedule: "0 21 * * *",
12:   timeZone: "UTC",
13:   memory: runtimeOpts.memory,
14: }, async (_event) => { // Added underscore prefix
15:   await syncCards();
16: });
17: 
18: // Manual card sync endpoint
19: export const testCardSync = onRequest(
20:   {
21:     timeoutSeconds: runtimeOpts.timeoutSeconds,
22:     memory: runtimeOpts.memory,
23:   },
24:   async (req: Request, res: Response) => {
25:     const options: SyncOptions = {
26:       dryRun: req.query.dryRun === "true",
27:       limit: req.query.limit ? parseInt(req.query.limit as string) : undefined,
28:       groupId: req.query.groupId as string,
29:     };
30: 
31:     const result = await syncCards(options);
32:     res.json(result);
33:   }
34: );
35: 
36: // Scheduled price sync
37: export const scheduledPriceSync = onSchedule({
38:   schedule: "30 21 * * *",
39:   timeZone: "UTC",
40:   memory: runtimeOpts.memory,
41: }, async (_event) => { // Added underscore prefix
42:   await syncPrices();
43: });
44: 
45: // Manual price sync endpoint
46: export const testPriceSync = onRequest(
47:   {
48:     timeoutSeconds: runtimeOpts.timeoutSeconds,
49:     memory: runtimeOpts.memory,
50:   },
51:   async (req: Request, res: Response) => {
52:     const options: SyncOptions = {
53:       dryRun: req.query.dryRun === "true",
54:       limit: req.query.limit ? parseInt(req.query.limit as string) : undefined,
55:       groupId: req.query.groupId as string,
56:       productId: req.query.productId ? parseInt(req.query.productId as string) : undefined,
57:       showAll: req.query.showAll === "true",
58:     };
59: 
60:     const result = await syncPrices(options);
61:     res.json(result);
62:   }
63: );
</file>

<file path="functions/src/services/cardSync.ts">
  1: import axios, {AxiosError} from "axios";
  2: import {db, COLLECTION, FFTCG_CATEGORY_ID} from "../config/firebase";
  3: import {CardProduct, SyncOptions, SyncMetadata} from "../types";
  4: import {cardCache, getCacheKey} from "../utils/cache";
  5: import {logError, logInfo, logWarning} from "../utils/logger";
  6: import * as crypto from "crypto";
  7: 
  8: const BASE_URL = "https://tcgcsv.com";
  9: const MAX_RETRIES = 3;
 10: 
 11: /**
 12:  * Makes an HTTP request with retry logic
 13:  * @param endpoint API endpoint to request
 14:  * @param retryCount Current retry attempt number
 15:  * @return Promise with the response data
 16:  */
 17: async function makeRequest<T>(endpoint: string, retryCount = 0): Promise<T> {
 18:   try {
 19:     await new Promise((resolve) => setTimeout(resolve, 1000)); // Rate limiting
 20:     const url = `${BASE_URL}/${endpoint}`;
 21:     await logInfo(`Making request to: ${url} (Attempt ${retryCount + 1}/${MAX_RETRIES})`);
 22: 
 23:     const response = await axios.get<T>(url);
 24:     return response.data;
 25:   } catch (error) {
 26:     if (retryCount < MAX_RETRIES - 1 && error instanceof AxiosError) {
 27:       const delay = Math.pow(2, retryCount) * 1000;
 28:       await logWarning(`Request failed, retrying in ${delay}ms...`);
 29:       await new Promise((resolve) => setTimeout(resolve, delay));
 30:       return makeRequest<T>(endpoint, retryCount + 1);
 31:     }
 32:     throw error;
 33:   }
 34: }
 35: 
 36: /**
 37:  * Generates a hash of data for comparison
 38:  * @param data Data to hash
 39:  * @return MD5 hash string
 40:  */
 41: function getDataHash(data: any): string {
 42:   return crypto.createHash("md5")
 43:     .update(JSON.stringify(data, Object.keys(data).sort()))
 44:     .digest("hex");
 45: }
 46: 
 47: /**
 48:  * Synchronizes card data from TCGCSV API to Firestore
 49:  * @param options Sync configuration options
 50:  * @return Sync operation metadata
 51:  */
 52: export async function syncCards(options: SyncOptions = {}): Promise<SyncMetadata> {
 53:   const startTime = Date.now();
 54:   const metadata: SyncMetadata = {
 55:     lastSync: new Date(),
 56:     status: "in_progress",
 57:     cardCount: 0,
 58:     type: options.dryRun ? "manual" : "scheduled",
 59:     groupsProcessed: 0,
 60:     groupsUpdated: 0,
 61:     errors: [],
 62:   };
 63: 
 64:   try {
 65:     // Fetch groups
 66:     const groupsResponse = await makeRequest<{ results: any[] }>(
 67:       `${FFTCG_CATEGORY_ID}/groups`
 68:     );
 69:     const groups = groupsResponse.results;
 70: 
 71:     logInfo(`Found ${groups.length} groups`);
 72: 
 73:     let processedCards = 0;
 74:     const existingHashes = new Map<string, string>();
 75: 
 76:     // Load existing hashes from Firestore
 77:     const hashesSnapshot = await db.collection("cardHashes").get();
 78:     hashesSnapshot.forEach((doc) => {
 79:       existingHashes.set(doc.id, doc.data().hash);
 80:     });
 81: 
 82:     for (const group of groups) {
 83:       if (options.groupId && group.groupId !== options.groupId) continue;
 84: 
 85:       try {
 86:         metadata.groupsProcessed++;
 87:         const productsResponse = await makeRequest<{ results: CardProduct[] }>(
 88:           `${FFTCG_CATEGORY_ID}/${group.groupId}/products`
 89:         );
 90:         const products = productsResponse.results;
 91: 
 92:         const groupHash = getDataHash(products);
 93:         const existingHash = existingHashes.get(group.groupId.toString());
 94: 
 95:         if (!options.dryRun && (!existingHash || existingHash !== groupHash)) {
 96:           metadata.groupsUpdated++;
 97:           const batch = db.batch();
 98: 
 99:           for (const product of products) {
100:             if (options.limit && processedCards >= options.limit) break;
101: 
102:             const cardRef = db.collection(COLLECTION.CARDS)
103:               .doc(product.productId.toString());
104:             batch.set(cardRef, {
105:               ...product,
106:               lastUpdated: new Date(),
107:               groupHash,
108:             }, {merge: true});
109: 
110:             cardCache.set(getCacheKey("card", product.productId), product);
111:             processedCards++;
112:           }
113: 
114:           // Update hash
115:           const hashRef = db.collection("cardHashes")
116:             .doc(group.groupId.toString());
117:           batch.set(hashRef, {
118:             hash: groupHash,
119:             lastUpdated: new Date(),
120:           });
121: 
122:           await batch.commit();
123:           logInfo(`Updated ${products.length} cards from group ${group.groupId}`);
124:         } else {
125:           logInfo(`No updates needed for group ${group.groupId} (unchanged)`);
126:         }
127: 
128:         metadata.cardCount += products.length;
129:       } catch (error: any) { // Type assertion
130:         const errorMessage = `Error processing group ${group.groupId}: ${error?.message || "Unknown error"}`;
131:         metadata.errors.push(errorMessage);
132:         logError(error, "syncCards:processGroup");
133:       }
134: 
135:       if (options.limit && processedCards >= options.limit) break;
136:     }
137: 
138:     metadata.status = metadata.errors.length > 0 ? "completed_with_errors" : "success";
139:   } catch (error: any) { // Type assertion
140:     metadata.status = "failed";
141:     metadata.errors.push(error?.message || "Unknown error");
142:     logError(error, "syncCards:main");
143:   }
144: 
145:   metadata.lastSync = new Date();
146:   metadata.duration = Date.now() - startTime;
147: 
148:   if (!options.dryRun) {
149:     await db.collection(COLLECTION.SYNC_METADATA)
150:       .add(metadata);
151:   }
152: 
153:   return metadata;
154: }
</file>

<file path="functions/src/services/priceSync.ts">
  1: import axios, {AxiosError} from "axios";
  2: import {db, COLLECTION, FFTCG_CATEGORY_ID, BASE_URL} from "../config/firebase";
  3: import {CardPrice, SyncOptions, SyncMetadata, PriceData} from "../types";
  4: import {logError, logInfo, logWarning} from "../utils/logger";
  5: import {ProgressTracker} from "../utils/progress";
  6: import * as crypto from "crypto";
  7: 
  8: const MAX_RETRIES = 3;
  9: 
 10: /**
 11:  * Makes an HTTP request with retry logic
 12:  * @param endpoint API endpoint to request
 13:  * @param retryCount Current retry attempt number
 14:  * @return Promise with the response data
 15:  */
 16: async function makeRequest<T>(endpoint: string, retryCount = 0): Promise<T> {
 17:   try {
 18:     await new Promise((resolve) => setTimeout(resolve, 1000)); // Rate limiting
 19:     const url = `${BASE_URL}/${endpoint}`;
 20:     await logInfo(`Making request to: ${url} (Attempt ${retryCount + 1}/${MAX_RETRIES})`);
 21: 
 22:     const response = await axios.get<T>(url);
 23:     return response.data;
 24:   } catch (error) {
 25:     if (retryCount < MAX_RETRIES - 1 && error instanceof AxiosError) {
 26:       const delay = Math.pow(2, retryCount) * 1000;
 27:       await logWarning(`Request failed, retrying in ${delay}ms...`);
 28:       await new Promise((resolve) => setTimeout(resolve, delay));
 29:       return makeRequest<T>(endpoint, retryCount + 1);
 30:     }
 31:     throw error;
 32:   }
 33: }
 34: 
 35: /**
 36:  * Generates a hash of data for comparison
 37:  * @param data Data to hash
 38:  * @return MD5 hash string
 39:  */
 40: function getDataHash(data: any): string {
 41:   return crypto.createHash("md5")
 42:     .update(JSON.stringify(data, Object.keys(data).sort()))
 43:     .digest("hex");
 44: }
 45: 
 46: /**
 47:  * Processes raw price data into a structured format
 48:  * @param prices Array of raw price data
 49:  * @return Processed price data map
 50:  */
 51: function processPrices(prices: CardPrice[]): Record<number, PriceData> {
 52:   const priceMap: Record<number, PriceData> = {};
 53: 
 54:   prices.forEach((price) => {
 55:     if (!priceMap[price.productId]) {
 56:       priceMap[price.productId] = {
 57:         lastUpdated: new Date(),
 58:       };
 59:     }
 60: 
 61:     if (price.subTypeName === "Normal") {
 62:       priceMap[price.productId].normal = price;
 63:     } else {
 64:       priceMap[price.productId].foil = price;
 65:     }
 66:   });
 67: 
 68:   return priceMap;
 69: }
 70: 
 71: /**
 72: * Synchronizes price data from TCGCSV API to Firestore
 73: * @param options Sync configuration options
 74: * @return Sync operation metadata
 75: */
 76: export async function syncPrices(options: SyncOptions = {}): Promise<SyncMetadata> {
 77:   const startTime = Date.now();
 78:   const metadata: SyncMetadata = {
 79:     lastSync: new Date(),
 80:     status: "in_progress",
 81:     cardCount: 0,
 82:     type: options.dryRun ? "manual" : "scheduled",
 83:     groupsProcessed: 0,
 84:     groupsUpdated: 0,
 85:     errors: [],
 86:   };
 87: 
 88:   try {
 89:     // If specific productId is provided, fetch just that group
 90:     if (options.productId) {
 91:       const card = await db.collection(COLLECTION.CARDS)
 92:         .doc(options.productId.toString())
 93:         .get();
 94: 
 95:       if (!card.exists) {
 96:         throw new Error(`Card with ID ${options.productId} not found`);
 97:       }
 98: 
 99:       const cardData = card.data();
100:       options.groupId = cardData?.groupId?.toString();
101:     }
102: 
103:     // Fetch groups or use specific group
104:     const groupsResponse = await makeRequest<{ results: any[] }>(
105:       `${FFTCG_CATEGORY_ID}/groups`
106:     );
107:     const groups = groupsResponse.results;
108: 
109:     if (options.groupId) {
110:       const group = groups.find((g) => g.groupId.toString() === options.groupId);
111:       if (!group) {
112:         throw new Error(`Group ${options.groupId} not found`);
113:       }
114:       groups.length = 0;
115:       groups.push(group);
116:     }
117: 
118:     const progress = new ProgressTracker(groups.length, "Processing groups");
119: 
120:     for (const group of groups) {
121:       try {
122:         metadata.groupsProcessed++;
123:         const pricesResponse = await makeRequest<{ results: CardPrice[] }>(
124:           `${FFTCG_CATEGORY_ID}/${group.groupId}/prices`
125:         );
126:         const prices = pricesResponse.results;
127: 
128:         if (options.productId) {
129:           const filteredPrices = prices.filter((p) => p.productId === options.productId);
130:           if (filteredPrices.length === 0) {
131:             throw new Error(`No prices found for product ${options.productId}`);
132:           }
133:           prices.length = 0;
134:           prices.push(...filteredPrices);
135:         }
136: 
137:         const priceHash = getDataHash(prices);
138:         const hashDoc = await db.collection(COLLECTION.PRICE_HASHES)
139:           .doc(group.groupId.toString())
140:           .get();
141: 
142:         const existingHash = hashDoc.exists ? hashDoc.data()?.hash : null;
143: 
144:         if (!options.dryRun && (!existingHash || existingHash !== priceHash)) {
145:           metadata.groupsUpdated++;
146:           const batch = db.batch();
147:           const processedPrices = processPrices(prices);
148: 
149:           for (const [productId, priceData] of Object.entries(processedPrices)) {
150:             if (options.limit && metadata.cardCount >= options.limit) break;
151: 
152:             const priceRef = db.collection(COLLECTION.PRICES)
153:               .doc(productId);
154:             batch.set(priceRef, priceData, {merge: true});
155: 
156:             metadata.cardCount++;
157:           }
158: 
159:           // Update hash
160:           const hashRef = db.collection(COLLECTION.PRICE_HASHES)
161:             .doc(group.groupId.toString());
162:           batch.set(hashRef, {
163:             hash: priceHash,
164:             lastUpdated: new Date(),
165:           });
166: 
167:           await batch.commit();
168:           await logInfo(`Updated ${metadata.cardCount} prices from group ${group.groupId}`);
169:         } else {
170:           await logInfo(`No updates needed for group ${group.groupId} (unchanged)`);
171:         }
172:       } catch (error: any) {
173:         const errorMessage = `Error processing group ${group.groupId}: ${error?.message || "Unknown error"}`;
174:         metadata.errors.push(errorMessage);
175:         await logError(error, "syncPrices:processGroup");
176:       }
177: 
178:       progress.update();
179: 
180:       if (options.limit && metadata.cardCount >= options.limit) break;
181:     }
182: 
183:     metadata.status = metadata.errors.length > 0 ? "completed_with_errors" : "success";
184:   } catch (error: any) {
185:     metadata.status = "failed";
186:     metadata.errors.push(error?.message || "Unknown error");
187:     await logError(error, "syncPrices:main");
188:   }
189: 
190:   metadata.lastSync = new Date();
191:   metadata.duration = Date.now() - startTime;
192: 
193:   if (!options.dryRun) {
194:     await db.collection(COLLECTION.SYNC_METADATA)
195:       .add(metadata);
196:   }
197: 
198:   return metadata;
199: }
</file>

<file path="functions/src/types/express.d.ts">
1: // / <reference types="express" />
2: import * as express from "express";
3: export = express;
</file>

<file path="functions/src/types/index.ts">
 1: export interface GenericError extends Error {
 2:     code?: string;
 3:     message: string;
 4:     stack?: string;
 5:   }
 6: 
 7: export interface CardProduct {
 8:     productId: number;
 9:     name: string;
10:     cleanName: string;
11:     imageUrl: string;
12:     categoryId: number;
13:     groupId: number;
14:     url: string;
15:     modifiedOn: string;
16:     imageCount: number;
17:     extendedData: Array<{
18:       name: string;
19:       displayName: string;
20:       value: string;
21:     }>;
22:   }
23: 
24: export interface CardPrice {
25:     productId: number;
26:     lowPrice: number;
27:     midPrice: number;
28:     highPrice: number;
29:     marketPrice: number | null;
30:     directLowPrice: number | null;
31:     subTypeName: "Normal" | "Foil";
32:   }
33: 
34: export interface SyncOptions {
35:     dryRun?: boolean;
36:     limit?: number;
37:     groupId?: string;
38:     productId?: number;
39:     showAll?: boolean;
40:   }
41: 
42: export interface SyncMetadata {
43:     lastSync: Date;
44:     status: "in_progress" | "success" | "failed" | "completed_with_errors";
45:     cardCount: number;
46:     type: "manual" | "scheduled";
47:     groupsProcessed: number;
48:     groupsUpdated: number;
49:     errors: string[];
50:     duration?: number;
51:   }
52: 
53: export type CacheType = "card" | "price";
54: 
55: export interface PriceData {
56:     normal?: CardPrice;
57:     foil?: CardPrice;
58:     lastUpdated: Date;
59:   }
60: 
61: export type LogData = any;
62: export type GenericObject = Record<string, any>;
</file>

<file path="functions/src/types/node.d.ts">
1: // / <reference types="node" />
</file>

<file path="functions/src/utils/cache.ts">
 1: import LRUCache from "lru-cache";
 2: import {CacheType, CardProduct} from "../types";
 3: 
 4: const options = {
 5:   max: 500,
 6:   ttl: 1000 * 60 * 60, // 1 hour
 7: };
 8: 
 9: export const cardCache = new LRUCache<string, CardProduct>(options);
10: 
11: export const getCacheKey = (type: CacheType, id: number): string => {
12:   return `${type}:${id}`;
13: };
</file>

<file path="functions/src/utils/logger.ts">
 1: import * as functions from "firebase-functions";
 2: import {db, COLLECTION} from "../config/firebase";
 3: import {GenericError, LogData, GenericObject} from "../types";
 4: 
 5: export const logger = functions.logger;
 6: 
 7: interface LogEntry {
 8:   timestamp: Date;
 9:   level: "INFO" | "WARNING" | "ERROR";
10:   message: string;
11:   context?: string;
12:   data?: LogData;
13: }
14: 
15: /**
16:  * Saves a log entry to Firestore
17:  * @param entry Log entry to save
18:  */
19: async function saveLogEntry(entry: LogEntry): Promise<void> {
20:   await db.collection(COLLECTION.LOGS).add(entry);
21: }
22: 
23: export const logError = async (error: GenericError | GenericObject, context: string) => {
24:   const entry: LogEntry = {
25:     timestamp: new Date(),
26:     level: "ERROR",
27:     message: error.message || "Unknown error",
28:     context,
29:     data: {
30:       stack: error.stack,
31:       code: error.code,
32:     },
33:   };
34: 
35:   logger.error(entry.message, entry.data);
36:   await saveLogEntry(entry);
37: };
38: 
39: export const logInfo = async (message: string, data?: LogData) => {
40:   const entry: LogEntry = {
41:     timestamp: new Date(),
42:     level: "INFO",
43:     message,
44:     data,
45:   };
46: 
47:   logger.info(message, data);
48:   await saveLogEntry(entry);
49: };
50: 
51: export const logWarning = async (message: string, data?: LogData) => {
52:   const entry: LogEntry = {
53:     timestamp: new Date(),
54:     level: "WARNING",
55:     message,
56:     data,
57:   };
58: 
59:   logger.warn(message, data);
60:   await saveLogEntry(entry);
61: };
</file>

<file path="functions/src/utils/progress.ts">
 1: import {logInfo} from "./logger";
 2: 
 3: /**
 4:  * Tracks progress of long-running operations
 5:  */
 6: export class ProgressTracker {
 7:   private startTime: number;
 8:   private current: number;
 9: 
10:   /**
11:    * Creates a new progress tracker
12:    * @param {number} total - Total number of items to process
13:    * @param {string} description - Description of the operation
14:    */
15:   constructor(
16:     private total: number,
17:     private description: string,
18:   ) {
19:     this.startTime = Date.now();
20:     this.current = 0;
21:   }
22: 
23:   /**
24:    * Updates progress and logs current status
25:    * @param {number} amount - Number of items processed in this update
26:    * @return {void}
27:    */
28:   update(amount = 1): void {
29:     this.current += amount;
30:     const elapsed = (Date.now() - this.startTime) / 1000;
31:     const percent = (this.current / this.total) * 100;
32:     const remaining = this.total - this.current;
33: 
34:     logInfo(
35:       `${this.description}: ${this.current}/${this.total} ` +
36:       `(${percent.toFixed(1)}%) - ${remaining} remaining - ` +
37:       `Elapsed time: ${elapsed.toFixed(1)}s`,
38:     );
39:   }
40: 
41:   /**
42:    * Gets current progress status
43:    * @return {Object} Progress information
44:    */
45:   getProgress(): { current: number; total: number; elapsed: number } {
46:     return {
47:       current: this.current,
48:       total: this.total,
49:       elapsed: (Date.now() - this.startTime) / 1000,
50:     };
51:   }
52: }
</file>

<file path="functions/tsconfig.dev.json">
1: {
2:   "extends": "./tsconfig.json",
3:   "include": [
4:     ".eslintrc.js",
5:     ".eslintrc.fix.js",
6:     ".eslintrc.base.cjs"
7:   ]
8: }
</file>

<file path="functions/tsconfig.json">
 1: {
 2:   "compilerOptions": {
 3:     "module": "commonjs",
 4:     "noImplicitReturns": true,
 5:     "noUnusedLocals": true,
 6:     "outDir": "lib",
 7:     "sourceMap": true,
 8:     "strict": true,
 9:     "target": "es2017",
10:     "esModuleInterop": true,
11:     "skipLibCheck": true,
12:     "typeRoots": [
13:       "./node_modules/@types",
14:       "./src/types"
15:     ],
16:     "types": ["node", "express"],
17:     "baseUrl": "./src"
18:   },
19:   "compileOnSave": true,
20:   "include": [
21:     "src/**/*",
22:     ".eslintrc.js",
23:     ".eslintrc.fix.js",
24:     ".eslintrc.base.cjs"
25:   ],
26:   "exclude": [
27:     "node_modules",
28:     "lib"
29:   ]
30: }
</file>

<file path="package.json">
 1: {
 2:   "name": "fftcg-sync-service",
 3:   "version": "1.0.0",
 4:   "description": "FFTCG Card Data Sync Service",
 5:   "scripts": {
 6:     "start": "cd functions && npm run serve",
 7:     "build": "cd functions && npm run build",
 8:     "deploy": "cd functions && npm run deploy",
 9:     "test": "cd functions && npm test",
10:     "lint": "cd functions && npm run lint",
11:     "lint:fix": "cd functions && npm run lint:fix",
12:     "serve": "cd functions && npm run serve",
13:     "shell": "cd functions && npm run shell",
14:     "logs": "cd functions && npm run logs",
15:     "install:all": "npm install && cd functions && npm install && npm run build",
16:     "clean": "cd functions && npm run clean"
17:   },
18:   "devDependencies": {
19:     "@types/express": "^4.17.21",
20:     "@types/node": "^18.19.64",
21:     "@typescript-eslint/eslint-plugin": "^6.0.0",
22:     "@typescript-eslint/parser": "^6.0.0",
23:     "eslint": "^8.0.0",
24:     "eslint-config-google": "^0.14.0",
25:     "eslint-plugin-import": "^2.25.4",
26:     "typescript": "^4.9.5"
27:   },
28:   "engines": {
29:     "node": "18"
30:   },
31:   "private": true,
32:   "dependencies": {
33:     "firebase-functions": "^6.1.0"
34:   }
35: }
</file>

<file path="storage.rules">
1: rules_version = '2';
2: service firebase.storage {
3:   match /b/{bucket}/o {
4:     match /{allPaths=**} {
5:       // Only allow access from our Cloud Functions
6:       allow read, write: if false;
7:     }
8:   }
9: }
</file>

<file path="tsconfig.json">
 1: {
 2:   "extends": "./functions/tsconfig.json",
 3:   "compilerOptions": {
 4:     "baseUrl": ".",
 5:     "paths": {
 6:       "*": ["node_modules/*", "functions/node_modules/*"]
 7:     },
 8:     "types": []
 9:   },
10:   "include": [
11:     "functions/src"
12:   ],
13:   "exclude": [
14:     "node_modules",
15:     "functions/node_modules"
16:   ]
17: }
</file>

</repository_files>
