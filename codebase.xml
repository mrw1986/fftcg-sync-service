This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-29T21:35:38.601Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

- Line numbers have been added to the beginning of each line.
</notes>

<additional_info>

For more information about Repomix, visit: https://github.com/yamadashy/repomix
</additional_info>

</file_summary>

<repository_structure>
.eslintignore
.eslintrc.base.cjs
.eslintrc.fix.js
.eslintrc.js
package.json
src/config/firebase.ts
src/index.ts
src/services/cardSync.ts
src/services/priceSync.ts
src/test/testEndpoints.ts
src/test/testImageHandler.ts
src/test/testSync.ts
src/test/validateSync.ts
src/types/index.ts
src/utils/backup.ts
src/utils/cache.ts
src/utils/databaseBackup.ts
src/utils/databaseCleanup.ts
src/utils/databaseRefresh.ts
src/utils/databaseReset.ts
src/utils/error.ts
src/utils/imageCache.ts
src/utils/imageCompressor.ts
src/utils/imageHandler.ts
src/utils/imageValidator.ts
src/utils/logger.ts
src/utils/progress.ts
src/utils/syncLogger.ts
src/utils/syncUtils.ts
tsconfig.dev.json
tsconfig.json
</repository_structure>

<repository_files>
This section contains the contents of the repository's files.

<file path=".eslintignore">
1: node_modules/
2: lib/
3: coverage/
4: *.d.ts
5: *.cjs
</file>

<file path=".eslintrc.base.cjs">
1: module.exports = {
2:     rules: {
3:       "valid-jsdoc": "off",
4:       "require-jsdoc": "off"
5:     }
6:   };
</file>

<file path=".eslintrc.fix.js">
 1: module.exports = {
 2:   extends: "./.eslintrc.js",
 3:   rules: {
 4:     "max-len": ["error", {"code": 120}],
 5:     "valid-jsdoc": 0,
 6:     "require-jsdoc": 0,
 7:     "@typescript-eslint/no-explicit-any": 0,
 8:     "@typescript-eslint/explicit-function-return-type": 0,
 9:     "@typescript-eslint/explicit-module-boundary-types": 0,
10:     "@typescript-eslint/no-unused-vars": ["error", {
11:       "argsIgnorePattern": "^_",
12:       "varsIgnorePattern": "^_",
13:     }],
14:     // Add these additional rules to be extra sure
15:     "jsdoc/require-jsdoc": 0,
16:     "jsdoc/valid-jsdoc": 0,
17:     "jsdoc/require-param-type": 0,
18:     "jsdoc/require-returns": 0,
19:   },
20: };
</file>

<file path=".eslintrc.js">
 1: module.exports = {
 2:   root: true,
 3:   env: {
 4:     es6: true,
 5:     node: true,
 6:   },
 7:   extends: [
 8:     "eslint:recommended",
 9:     "plugin:import/errors",
10:     "plugin:import/warnings",
11:     "plugin:import/typescript",
12:     "google",
13:     "plugin:@typescript-eslint/recommended",
14:   ],
15:   parser: "@typescript-eslint/parser",
16:   parserOptions: {
17:     project: ["tsconfig.json", "tsconfig.dev.json"],
18:     tsconfigRootDir: __dirname,
19:     sourceType: "module",
20:     createDefaultProgram: true,
21:   },
22:   ignorePatterns: [
23:     "/lib/**/*",
24:     "/generated/**/*",
25:     "node_modules/",
26:     "*.cjs",
27:   ],
28:   plugins: [
29:     "@typescript-eslint",
30:     "import",
31:   ],
32:   rules: {
33:     "quotes": ["error", "double"],
34:     "import/no-unresolved": 0,
35:     "indent": ["error", 2],
36:     "max-len": ["error", {"code": 120}],
37:     "@typescript-eslint/no-explicit-any": "off",
38:     "@typescript-eslint/no-unused-vars": ["error", {
39:       "argsIgnorePattern": "^_",
40:       "varsIgnorePattern": "^_",
41:     }],
42:     "valid-jsdoc": 0,
43:     "require-jsdoc": 0,
44:   },
45:   overrides: [
46:     {
47:       files: ["*.js", "*.cjs"],
48:       rules: {
49:         "@typescript-eslint/no-var-requires": "off",
50:       },
51:     },
52:   ],
53: };
</file>

<file path="package.json">
 1: {
 2:   "name": "functions",
 3:   "scripts": {
 4:     "clean": "rimraf lib",
 5:     "lint": "eslint --ext .js,.ts .",
 6:     "lint:fix": "eslint --ext .js,.ts . --fix",
 7:     "build": "npm run clean && tsc",
 8:     "build:watch": "tsc --watch",
 9:     "serve": "npm run build && firebase emulators:start --only functions,firestore,storage",
10:     "shell": "npm run build && firebase functions:shell",
11:     "start": "npm run shell",
12:     "deploy": "npm run lint:fix && firebase deploy --only functions",
13:     "logs": "firebase functions:log",
14:     "lint:fix:force": "eslint . --ext .js,.ts --fix --config .eslintrc.fix.js",
15:     "test:images": "ts-node src/test/testImageHandler.ts",
16:     "test:sync": "ts-node src/test/testSync.ts",
17:     "test:all": "npm run test:images && npm run test:sync",
18:     "backup-db": "ts-node src/utils/databaseBackup.ts",
19:     "clear-db": "ts-node src/utils/databaseReset.ts",
20:     "sync:data": "ts-node src/utils/databaseRefresh.ts --skip-images",
21:     "sync:data:force": "ts-node src/utils/databaseRefresh.ts --skip-images --force",
22:     "sync:data:dry": "ts-node src/utils/databaseRefresh.ts --skip-images --dry-run",
23:     "sync:data:verbose": "ts-node src/utils/databaseRefresh.ts --skip-images --verbose",
24:     "sync:images": "ts-node src/utils/databaseRefresh.ts --images-only",
25:     "sync:images:force": "ts-node src/utils/databaseRefresh.ts --images-only --force",
26:     "sync:images:dry": "ts-node src/utils/databaseRefresh.ts --images-only --dry-run",
27:     "sync:images:verbose": "ts-node src/utils/databaseRefresh.ts --images-only --verbose",
28:     "sync:full": "ts-node src/utils/databaseRefresh.ts",
29:     "sync:full:force": "ts-node src/utils/databaseRefresh.ts --force",
30:     "sync:full:dry": "ts-node src/utils/databaseRefresh.ts --dry-run",
31:     "sync:full:verbose": "ts-node src/utils/databaseRefresh.ts --verbose",
32:     "sync:group": "ts-node src/utils/databaseRefresh.ts --group-id",
33:     "sync:group:images": "ts-node src/utils/databaseRefresh.ts --group-id --images-only",
34:     "sync:group:data": "ts-node src/utils/databaseRefresh.ts --group-id --skip-images",
35:     "cleanup:images": "ts-node src/utils/databaseCleanup.ts"
36:   },
37:   "engines": {
38:     "node": "18"
39:   },
40:   "main": "lib/index.js",
41:   "dependencies": {
42:     "axios": "^1.7.7",
43:     "cors": "^2.8.5",
44:     "firebase-admin": "^12.0.0",
45:     "firebase-functions": "^6.1.1",
46:     "lru-cache": "^7.14.1",
47:     "sharp": "^0.33.1",
48:     "refresh-db": "ts-node src/utils/databaseRefresh.ts"
49:   },
50:   "devDependencies": {
51:     "@types/cors": "^2.8.17",
52:     "@types/express": "^4.17.21",
53:     "@types/node": "^18.19.64",
54:     "@typescript-eslint/eslint-plugin": "^6.0.0",
55:     "@typescript-eslint/parser": "^6.0.0",
56:     "eslint": "^8.0.0",
57:     "eslint-config-google": "^0.14.0",
58:     "eslint-plugin-import": "^2.25.4",
59:     "firebase-functions-test": "^3.1.0",
60:     "rimraf": "^5.0.0",
61:     "typescript": "^4.9.5"
62:   },
63:   "private": true
64: }
</file>

<file path="src/config/firebase.ts">
 1: // functions/src/config/firebase.ts
 2: 
 3: import * as admin from "firebase-admin";
 4: 
 5: const app = !admin.apps.length ? admin.initializeApp() : admin.app();
 6: const db = admin.firestore(app);
 7: 
 8: // Enable ignoreUndefinedProperties and other settings
 9: db.settings({
10:   ignoreUndefinedProperties: true,
11:   timestampsInSnapshots: true,
12: });
13: 
14: const storage = admin.storage(app);
15: 
16: export {db, storage};
17: 
18: export const COLLECTION = {
19:   CARDS: "cards",
20:   PRICES: "prices",
21:   SYNC_METADATA: "syncMetadata",
22:   LOGS: "logs",
23:   CARD_HASHES: "cardHashes",
24:   PRICE_HASHES: "priceHashes",
25:   IMAGE_METADATA: "imageMetadata",
26: };
27: 
28: export const STORAGE = {
29:   BUCKETS: {
30:     CARD_IMAGES: "fftcg-sync-service.firebasestorage.app",
31:   },
32:   PATHS: {
33:     IMAGES: "card-images",
34:   },
35: };
36: 
37: export const BASE_URL = "https://tcgcsv.com/tcgplayer";
38: export const FFTCG_CATEGORY_ID = "24";
39: 
40: export const runtimeOpts = {
41:   timeoutSeconds: 540,
42:   memory: "1GiB",
43: } as const;
</file>

<file path="src/index.ts">
  1: import {onRequest} from "firebase-functions/v2/https";
  2: import {onSchedule} from "firebase-functions/v2/scheduler";
  3: import {Request, Response} from "express";
  4: import {syncCards} from "./services/cardSync";
  5: import {syncPrices} from "./services/priceSync";
  6: import {runtimeOpts} from "./config/firebase";
  7: import {SyncOptions} from "./types";
  8: import cors = require("cors");
  9: 
 10: // Initialize CORS middleware with appropriate typing
 11: const corsMiddleware = cors({
 12:   origin: true,
 13:   methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
 14:   allowedHeaders: ["Content-Type", "Authorization"],
 15:   credentials: true,
 16: });
 17: 
 18: // Wrap async function with CORS and error handling
 19: const withCorsAndErrors = (handler: (req: Request, res: Response) => Promise<void>) => {
 20:   return async (req: Request, res: Response): Promise<void> => {
 21:     // Handle CORS preflight requests
 22:     if (req.method === "OPTIONS") {
 23:       return new Promise((resolve) => {
 24:         corsMiddleware(req, res, () => {
 25:           res.status(204).send("");
 26:           resolve();
 27:         });
 28:       });
 29:     }
 30: 
 31:     // Handle actual request with CORS
 32:     return new Promise((resolve, reject) => {
 33:       corsMiddleware(req, res, async () => {
 34:         try {
 35:           await handler(req, res);
 36:           resolve();
 37:         } catch (error) {
 38:           console.error("Function error:", error);
 39:           res.status(500).json({
 40:             error: error instanceof Error ? error.message : "Internal server error",
 41:             timestamp: new Date().toISOString(),
 42:           });
 43:           reject(error);
 44:         }
 45:       });
 46:     });
 47:   };
 48: };
 49: 
 50: export const scheduledCardSync = onSchedule({
 51:   schedule: "0 21 * * *", // Daily at 21:00 UTC
 52:   timeZone: "UTC",
 53:   memory: runtimeOpts.memory,
 54:   timeoutSeconds: runtimeOpts.timeoutSeconds,
 55:   retryCount: 3,
 56: }, async (_context) => {
 57:   await syncCards();
 58: });
 59: 
 60: export const testCardSync = onRequest({
 61:   timeoutSeconds: runtimeOpts.timeoutSeconds,
 62:   memory: runtimeOpts.memory,
 63:   maxInstances: 1,
 64: }, withCorsAndErrors(async (req: Request, res: Response): Promise<void> => {
 65:   const options: SyncOptions = {
 66:     dryRun: req.query.dryRun !== "false", // default to true
 67:     limit: req.query.limit ? parseInt(req.query.limit as string) : 5,
 68:     groupId: req.query.groupId as string,
 69:   };
 70: 
 71:   const result = await syncCards(options);
 72:   res.json(result);
 73: }));
 74: 
 75: export const manualCardSync = onRequest({
 76:   timeoutSeconds: runtimeOpts.timeoutSeconds,
 77:   memory: runtimeOpts.memory,
 78:   maxInstances: 1,
 79: }, withCorsAndErrors(async (_req: Request, res: Response): Promise<void> => {
 80:   const result = await syncCards({dryRun: false});
 81:   res.json(result);
 82: }));
 83: 
 84: export const scheduledPriceSync = onSchedule({
 85:   schedule: "30 21 * * *", // Daily at 21:30 UTC
 86:   timeZone: "UTC",
 87:   memory: runtimeOpts.memory,
 88:   timeoutSeconds: runtimeOpts.timeoutSeconds,
 89:   retryCount: 3,
 90: }, async (_context) => {
 91:   await syncPrices();
 92: });
 93: 
 94: export const testPriceSync = onRequest({
 95:   timeoutSeconds: runtimeOpts.timeoutSeconds,
 96:   memory: runtimeOpts.memory,
 97:   maxInstances: 1,
 98: }, withCorsAndErrors(async (req: Request, res: Response): Promise<void> => {
 99:   const options: SyncOptions = {
100:     dryRun: req.query.dryRun === "true",
101:     limit: req.query.limit ? parseInt(req.query.limit as string) : undefined,
102:     groupId: req.query.groupId as string,
103:     productId: req.query.productId ? parseInt(req.query.productId as string) : undefined,
104:     showAll: req.query.showAll === "true",
105:   };
106: 
107:   const result = await syncPrices(options);
108:   res.json(result);
109: }));
110: 
111: export const manualPriceSync = onRequest({
112:   timeoutSeconds: runtimeOpts.timeoutSeconds,
113:   memory: runtimeOpts.memory,
114:   maxInstances: 1,
115: }, withCorsAndErrors(async (_req: Request, res: Response): Promise<void> => {
116:   const result = await syncPrices();
117:   res.json(result);
118: }));
119: 
120: export const healthCheck = onRequest({
121:   timeoutSeconds: 10,
122:   memory: "128MiB",
123: }, withCorsAndErrors(async (_req: Request, res: Response): Promise<void> => {
124:   res.json({
125:     status: "healthy",
126:     timestamp: new Date().toISOString(),
127:     version: "1.0.0",
128:   });
129: }));
</file>

<file path="src/services/cardSync.ts">
  1: // src/services/cardSync.ts
  2: 
  3: import {
  4:   db,
  5:   COLLECTION,
  6:   FFTCG_CATEGORY_ID,
  7:   BASE_URL,
  8: } from "../config/firebase";
  9: import {
 10:   CardProduct,
 11:   SyncOptions,
 12:   SyncMetadata,
 13:   GenericError,
 14:   BatchProcessingStats,
 15: } from "../types";
 16: import { cardCache, getCacheKey } from "../utils/cache";
 17: import { logError, logInfo } from "../utils/logger";
 18: import * as crypto from "crypto";
 19: import { SyncLogger } from "../utils/syncLogger";
 20: import { ImageHandler } from "../utils/imageHandler";
 21: import { makeRequest, processBatch } from "../utils/syncUtils";
 22: import { Query } from '@google-cloud/firestore';
 23: 
 24: // Add this type
 25: type FirestoreQuery = Query<FirebaseFirestore.DocumentData>;
 26: 
 27: class SyncError extends Error implements GenericError {
 28:   code?: string;
 29: 
 30:   constructor(
 31:     message: string,
 32:     code?: string,
 33:     public details?: Record<string, unknown>
 34:   ) {
 35:     super(message);
 36:     this.name = "SyncError";
 37:     this.code = code;
 38:   }
 39: 
 40:   toGenericError(): GenericError {
 41:     return {
 42:       name: this.name,
 43:       message: this.message,
 44:       code: this.code,
 45:       stack: this.stack,
 46:     };
 47:   }
 48: }
 49: 
 50: function getCardNumber(product: CardProduct): string {
 51:   const numberField = product.extendedData.find(
 52:     (data) => data.name === "Number"
 53:   );
 54:   return numberField ? numberField.value : "";
 55: }
 56: 
 57: function getDocumentId(product: CardProduct): string {
 58:   const cardNumber = getCardNumber(product);
 59:   return sanitizeDocumentId(product.productId, cardNumber);
 60: }
 61: 
 62: function getDataHash(data: any): string {
 63:   return crypto
 64:     .createHash("md5")
 65:     .update(JSON.stringify(data, Object.keys(data).sort()))
 66:     .digest("hex");
 67: }
 68: 
 69: async function processGroupProducts(
 70:   group: any,
 71:   options: SyncOptions,
 72:   metadata: SyncMetadata,
 73:   existingHashes: Map<string, string>,
 74:   imageHandler: ImageHandler,
 75:   logger?: SyncLogger
 76: ): Promise<number> {
 77:   const groupId = group.groupId.toString();
 78:   let processedCards = 0;
 79: 
 80:   try {
 81:     const productsResponse = await makeRequest<{ results: CardProduct[] }>(
 82:       `${FFTCG_CATEGORY_ID}/${groupId}/products`,
 83:       BASE_URL,
 84:       { metadata: { groupId, groupName: group.name } }
 85:     );
 86: 
 87:     const products = productsResponse.results;
 88: 
 89:     if (logger) {
 90:       await logger.logGroupDetails(groupId, products.length, products.length);
 91:     }
 92: 
 93:     const groupHash = getDataHash(products);
 94:     const existingHash = existingHashes.get(groupId);
 95: 
 96:     if (logger && options.dryRun) {
 97:       for (const product of products) {
 98:         if (options.limit && processedCards >= options.limit) break;
 99: 
100:         const cardNumber = getCardNumber(product);
101:         await logger.logCardDetails({
102:           id: product.productId,
103:           name: product.name,
104:           groupId: groupId,
105:           cardNumber,
106:           highResUrl: product.highResUrl || "",
107:           lowResUrl: product.lowResUrl || "",
108:           rawPrices: [],
109:         });
110:         processedCards++;
111:       }
112:     }
113: 
114:     const shouldUpdate =
115:       options.force || !existingHash || existingHash !== groupHash;
116: 
117:     if (!options.dryRun && shouldUpdate) {
118:       metadata.groupsUpdated++;
119: 
120:       await processBatch(
121:         products,
122:         async (batch) => {
123:           const writeBatch = db.batch();
124:           const imagePromises: Promise<any>[] = [];
125: 
126:           for (const product of batch) {
127:             if (options.limit && processedCards >= options.limit) break;
128: 
129:             const cardNumber = getCardNumber(product);
130: 
131:             if (!options.skipImages) {
132:               imagePromises.push(
133:                 imageHandler.processImage(
134:                   product.imageUrl || "",
135:                   groupId,
136:                   product.productId,
137:                   cardNumber
138:                 )
139:               );
140:             }
141: 
142:             const cardRef = db
143:               .collection(COLLECTION.CARDS)
144:               .doc(getDocumentId(product));
145: 
146:             const productData = {
147:               ...product,
148:               highResUrl: product.highResUrl || "",
149:               lowResUrl: product.lowResUrl || "",
150:               lastUpdated: new Date(),
151:               groupHash,
152:             };
153: 
154:             // Remove imageUrl field
155:             delete productData.imageUrl;
156: 
157:             if (productData.imageMetadata) {
158:               const {
159:                 contentType,
160:                 size,
161:                 updated,
162:                 hash,
163:                 groupId,
164:                 productId,
165:                 cardNumber,
166:                 lastUpdated,
167:                 originalSize,
168:                 highResSize,
169:                 lowResSize,
170:               } = productData.imageMetadata;
171: 
172:               productData.imageMetadata = {
173:                 contentType,
174:                 size,
175:                 updated,
176:                 hash,
177:                 groupId,
178:                 productId,
179:                 cardNumber,
180:                 lastUpdated,
181:                 originalSize,
182:                 highResSize,
183:                 lowResSize,
184:               };
185:             }
186: 
187:             writeBatch.set(cardRef, productData, { merge: true });
188: 
189:             cardCache.set(
190:               getCacheKey("card", product.productId, cardNumber),
191:               productData
192:             );
193:             processedCards++;
194:           }
195: 
196:           if (imagePromises.length > 0) {
197:             const imageResults = await Promise.allSettled(imagePromises);
198: 
199:             imageResults.forEach((result, index) => {
200:               if (result.status === "fulfilled") {
201:                 const product = batch[index];
202:                 const cardRef = db
203:                   .collection(COLLECTION.CARDS)
204:                   .doc(getDocumentId(product));
205: 
206:                 writeBatch.update(cardRef, {
207:                   originalUrl: result.value.originalUrl,
208:                   highResUrl: result.value.highResUrl,
209:                   lowResUrl: result.value.lowResUrl,
210:                   imageMetadata: {
211:                     contentType: result.value.metadata.contentType,
212:                     size: result.value.metadata.size,
213:                     updated: result.value.metadata.updated,
214:                     hash: result.value.metadata.hash,
215:                     originalSize: result.value.metadata.originalSize,
216:                     highResSize: result.value.metadata.highResSize,
217:                     lowResSize: result.value.metadata.lowResSize,
218:                   },
219:                 });
220: 
221:                 if (result.value.updated) {
222:                   metadata.imagesUpdated = (metadata.imagesUpdated || 0) + 1;
223:                 }
224:               }
225:             });
226: 
227:             metadata.imagesProcessed =
228:               (metadata.imagesProcessed || 0) + imagePromises.length;
229:           }
230: 
231:           const hashRef = db.collection(COLLECTION.CARD_HASHES).doc(groupId);
232:           writeBatch.set(hashRef, {
233:             hash: groupHash,
234:             lastUpdated: new Date(),
235:           });
236: 
237:           await writeBatch.commit();
238:         },
239:         {
240:           batchSize: 100,
241:           onBatchComplete: async (stats: BatchProcessingStats) => {
242:             await logInfo("Batch processing progress", stats);
243:           },
244:         }
245:       );
246: 
247:       await logInfo(`Updated ${processedCards} cards from group ${groupId}`, {
248:         groupId,
249:         processedCards,
250:         imagesProcessed: metadata.imagesProcessed,
251:         imagesUpdated: metadata.imagesUpdated,
252:         timestamp: new Date().toISOString(),
253:       });
254:     } else {
255:       await logInfo(`No updates needed for group ${groupId}`, {
256:         status: "unchanged",
257:         groupId,
258:         cardCount: products.length,
259:         timestamp: new Date().toISOString(),
260:       });
261:     }
262: 
263:     metadata.cardCount += products.length;
264:     return processedCards;
265:   } catch (error) {
266:     const syncError =
267:       error instanceof Error
268:         ? new SyncError(error.message, "GROUP_PROCESSING_ERROR", { groupId })
269:         : new SyncError("Unknown group processing error", "UNKNOWN_ERROR", {
270:             groupId,
271:           });
272: 
273:     const errorMessage = `Error processing group ${groupId}: ${syncError.message}`;
274:     metadata.errors.push(errorMessage);
275:     await logError(syncError.toGenericError(), "processGroupProducts");
276:     return processedCards;
277:   }
278: }
279: 
280: export async function syncCards(
281:   options: SyncOptions = {}
282: ): Promise<SyncMetadata> {
283:   const logger = options.silent
284:     ? undefined
285:     : new SyncLogger({
286:         type: options.dryRun ? "manual" : "scheduled",
287:         limit: options.limit,
288:         dryRun: options.dryRun,
289:         groupId: options.groupId,
290:         batchSize: 25,
291:       });
292: 
293:   if (logger) await logger.start();
294: 
295:   const metadata: SyncMetadata = {
296:     lastSync: new Date(),
297:     status: "in_progress",
298:     cardCount: 0,
299:     type: options.dryRun ? "manual" : "scheduled",
300:     groupsProcessed: 0,
301:     groupsUpdated: 0,
302:     errors: [],
303:     imagesProcessed: 0,
304:     imagesUpdated: 0,
305:   };
306: 
307:   try {
308:     let groups: any[] = [];
309: 
310:     // Skip card data sync if only processing images
311:     if (!options.imagesOnly) {
312:       if (options.groupId) {
313:         const groupResponse = await makeRequest<{ results: any[] }>(
314:           `${FFTCG_CATEGORY_ID}/groups`,
315:           BASE_URL,
316:           { metadata: { operation: "fetchGroups" } }
317:         );
318: 
319:         const group = groupResponse.results.find(
320:           (g) => g.groupId.toString() === options.groupId
321:         );
322:         if (!group) {
323:           throw new SyncError(
324:             `Group ${options.groupId} not found`,
325:             "GROUP_NOT_FOUND",
326:             { groupId: options.groupId }
327:           );
328:         }
329: 
330:         groups = [group];
331:         await logInfo(`Processing single group: ${options.groupId}`);
332:       } else {
333:         const groupsResponse = await makeRequest<{ results: any[] }>(
334:           `${FFTCG_CATEGORY_ID}/groups`,
335:           BASE_URL,
336:           { metadata: { operation: "fetchGroups" } }
337:         );
338:         groups = groupsResponse.results;
339:       }
340: 
341:       if (logger) {
342:         await logger.logGroupFound(groups.length);
343:       }
344:     }
345: 
346:     let processedCards = 0;
347:     const existingHashes = new Map<string, string>();
348: 
349:     // Only fetch hashes if we're not just processing images
350:     if (!options.imagesOnly) {
351:       const hashQueries = groups.map((group) =>
352:         db
353:           .collection(COLLECTION.CARD_HASHES)
354:           .doc(group.groupId.toString())
355:           .get()
356:       );
357: 
358:       const hashDocs = await Promise.all(hashQueries);
359:       hashDocs.forEach((doc) => {
360:         if (doc.exists) {
361:           existingHashes.set(doc.id, doc.data()?.hash);
362:         }
363:       });
364:     }
365: 
366:     const imageHandler = new ImageHandler();
367: 
368:     // If only processing images, fetch existing cards from Firestore
369:     if (options.imagesOnly) {
370:       try {
371:         let baseQuery: FirestoreQuery = db.collection(COLLECTION.CARDS);
372: 
373:         if (options.groupId) {
374:           baseQuery = baseQuery.where("groupId", "==", options.groupId);
375:         }
376: 
377:         if (options.limit) {
378:           baseQuery = baseQuery.limit(options.limit);
379:         }
380: 
381:         const snapshot = await baseQuery.get();
382: 
383:         await logInfo(`Processing images for ${snapshot.size} cards`);
384: 
385:         for (const doc of snapshot.docs) {
386:           const card = doc.data();
387:           await processCardImages(card, imageHandler, options, metadata);
388:           processedCards++;
389: 
390:           if (options.limit && processedCards >= options.limit) break;
391:         }
392:       } catch (error) {
393:         const syncError =
394:           error instanceof Error
395:             ? new SyncError(error.message, "IMAGE_PROCESSING_ERROR")
396:             : new SyncError(
397:                 "Unknown error during image processing",
398:                 "UNKNOWN_ERROR"
399:               );
400: 
401:         metadata.status = "failed";
402:         metadata.errors.push(syncError.message);
403:         await logError(syncError.toGenericError(), "syncCards:imageProcessing");
404:       }
405:     } else {
406:       for (const group of groups) {
407:         metadata.groupsProcessed++;
408:         const groupProcessedCards = await processGroupProducts(
409:           group,
410:           options,
411:           metadata,
412:           existingHashes,
413:           imageHandler,
414:           logger
415:         );
416: 
417:         processedCards += groupProcessedCards;
418:         if (options.limit && processedCards >= options.limit) break;
419:       }
420:     }
421: 
422:     metadata.status =
423:       metadata.errors.length > 0 ? "completed_with_errors" : "success";
424:   } catch (error) {
425:     const syncError =
426:       error instanceof Error
427:         ? new SyncError(error.message, "SYNC_MAIN_ERROR")
428:         : new SyncError("Unknown sync error", "UNKNOWN_ERROR");
429: 
430:     metadata.status = "failed";
431:     metadata.errors.push(syncError.message);
432:     await logError(syncError.toGenericError(), "syncCards:main");
433:   }
434: 
435:   metadata.lastSync = new Date();
436:   return metadata;
437: }
438: 
439: async function processCardImages(
440:   card: any,
441:   imageHandler: ImageHandler,
442:   options: SyncOptions,
443:   metadata: SyncMetadata
444: ): Promise<void> {
445:   try {
446:     if (card.imageUrl) {
447:       const result = await imageHandler.processImage(
448:         card.originalUrl || card.imageUrl, // Fallback to imageUrl during migration
449:         card.groupId.toString(),
450:         card.productId,
451:         card.cardNumber
452:       );
453: 
454:       if (result.updated) {
455:         metadata.imagesUpdated = (metadata.imagesUpdated || 0) + 1;
456:       }
457:       metadata.imagesProcessed = (metadata.imagesProcessed || 0) + 1;
458:     }
459:   } catch (error) {
460:     metadata.errors.push(
461:       `Failed to process image for card ${card.productId}: ${
462:         error instanceof Error ? error.message : "Unknown error"
463:       }`
464:     );
465:   }
466: }
</file>

<file path="src/services/priceSync.ts">
  1: // src/services/priceSync.ts
  2: 
  3: import {
  4:   db,
  5:   COLLECTION,
  6:   FFTCG_CATEGORY_ID,
  7:   BASE_URL,
  8: } from "../config/firebase";
  9: import {
 10:   CardPrice,
 11:   SyncOptions,
 12:   SyncMetadata,
 13:   PriceData,
 14:   GenericError,
 15: } from "../types";
 16: import {logError, logInfo} from "../utils/logger";
 17: import {SyncLogger} from "../utils/syncLogger";
 18: import {makeRequest, processBatch} from
 19:   "../utils/syncUtils";
 20: import * as crypto from "crypto";
 21: 
 22: 
 23: class SyncError extends Error implements GenericError {
 24:   code?: string;
 25: 
 26:   constructor(
 27:     message: string,
 28:     code?: string,
 29:     public details?: Record<string, unknown>
 30:   ) {
 31:     super(message);
 32:     this.name = "SyncError";
 33:     this.code = code;
 34:   }
 35: 
 36:   toGenericError(): GenericError {
 37:     return {
 38:       name: this.name,
 39:       message: this.message,
 40:       code: this.code,
 41:       stack: this.stack,
 42:     };
 43:   }
 44: }
 45: 
 46: async function getCardNumberFromFirestore(productId: number): Promise<string> {
 47:   const snapshot = await db
 48:     .collection(COLLECTION.CARDS)
 49:     .where("productId", "==", productId)
 50:     .get();
 51: 
 52:   if (!snapshot.empty) {
 53:     const doc = snapshot.docs[0];
 54:     const cardData = doc.data();
 55:     const numberField = cardData.extendedData?.find(
 56:       (data: any) => data.name === "Number"
 57:     );
 58:     return numberField?.value || "";
 59:   }
 60:   return "";
 61: }
 62: 
 63: function getDataHash(data: any): string {
 64:   return crypto
 65:     .createHash("md5")
 66:     .update(JSON.stringify(data, Object.keys(data).sort()))
 67:     .digest("hex");
 68: }
 69: 
 70: async function processPrices(
 71:   prices: CardPrice[]
 72: ): Promise<Record<string, PriceData>> {
 73:   const priceMap: Record<string, PriceData> = {};
 74: 
 75:   for (const price of prices) {
 76:     const cardNumber = await getCardNumberFromFirestore(price.productId);
 77:     const docId = sanitizeDocumentId(price.productId, cardNumber);
 78: 
 79:     if (!priceMap[docId]) {
 80:       priceMap[docId] = {
 81:         lastUpdated: new Date(),
 82:         productId: price.productId,
 83:         cardNumber, // Keep the original card number in the data
 84:       };
 85:     }
 86: 
 87:     if (price.subTypeName === "Normal") {
 88:       priceMap[docId].normal = price;
 89:     } else {
 90:       priceMap[docId].foil = price;
 91:     }
 92:   }
 93: 
 94:   return priceMap;
 95: }
 96: 
 97: async function processGroupPrices(
 98:   group: any,
 99:   options: SyncOptions,
100:   metadata: SyncMetadata,
101:   logger?: SyncLogger
102: ): Promise<void> {
103:   const groupId = group.groupId.toString();
104: 
105:   try {
106:     // Direct API call to the specific group's prices endpoint
107:     const pricesResponse = await makeRequest<{ results: CardPrice[] }>(
108:       `${FFTCG_CATEGORY_ID}/${groupId}/prices`,
109:       BASE_URL,
110:       {metadata: {groupId, groupName: group.name}}
111:     );
112: 
113:     const prices = pricesResponse.results;
114: 
115:     if (logger) {
116:       await logger.logGroupDetails(groupId, prices.length, prices.length);
117:     }
118: 
119:     if (options.productId) {
120:       const filteredPrices = prices.filter(
121:         (p) => p.productId === options.productId
122:       );
123:       if (filteredPrices.length === 0) {
124:         throw new SyncError(
125:           `No prices found for product ${options.productId}`,
126:           "NO_PRICES_FOUND",
127:           {productId: options.productId}
128:         );
129:       }
130:     }
131: 
132:     const priceHash = getDataHash(prices);
133:     const hashDoc = await db
134:       .collection(COLLECTION.PRICE_HASHES)
135:       .doc(groupId)
136:       .get();
137: 
138:     const existingHash = hashDoc.exists ? hashDoc.data()?.hash : null;
139: 
140:     if (logger && options.dryRun) {
141:       for (const price of prices) {
142:         const cardNumber = await getCardNumberFromFirestore(price.productId);
143:         await logger.logCardDetails({
144:           id: price.productId,
145:           name: `Product ${price.productId}`,
146:           groupId: groupId,
147:           cardNumber,
148:           normalPrice:
149:             price.subTypeName === "Normal" ? price.midPrice : undefined,
150:           foilPrice: price.subTypeName === "Foil" ? price.midPrice : undefined,
151:           rawPrices: [
152:             {
153:               type: price.subTypeName,
154:               price: price.midPrice,
155:               groupId: groupId,
156:             },
157:           ],
158:         });
159:       }
160:     }
161: 
162:     if (
163:       !options.dryRun &&
164:       (!existingHash || existingHash !== priceHash || options.force)
165:     ) {
166:       metadata.groupsUpdated++;
167:       const processedPrices = await processPrices(prices);
168: 
169:       await processBatch(
170:         Object.entries(processedPrices),
171:         async (batch) => {
172:           const writeBatch = db.batch();
173: 
174:           for (const [docId, priceData] of batch) {
175:             if (options.limit && metadata.cardCount >= options.limit) break;
176: 
177:             const priceRef = db.collection(COLLECTION.PRICES).doc(docId);
178:             writeBatch.set(priceRef, priceData, {merge: true});
179: 
180:             metadata.cardCount++;
181:           }
182: 
183:           const hashRef = db.collection(COLLECTION.PRICE_HASHES).doc(groupId);
184:           writeBatch.set(hashRef, {
185:             hash: priceHash,
186:             lastUpdated: new Date(),
187:           });
188: 
189:           await writeBatch.commit();
190:         },
191:         {
192:           batchSize: 100,
193:           onBatchComplete: async (stats) => {
194:             await logInfo("Batch processing progress", stats);
195:           },
196:         }
197:       );
198: 
199:       await logInfo(
200:         `Updated ${metadata.cardCount} prices from group ${groupId}`
201:       );
202:     } else {
203:       await logInfo(`No updates needed for group ${groupId} (unchanged)`);
204:     }
205:   } catch (error) {
206:     const syncError =
207:       error instanceof SyncError ?
208:         error :
209:         error instanceof Error ?
210:           new SyncError(error.message, "GROUP_PROCESSING_ERROR", {groupId}) :
211:           new SyncError("Unknown group processing error", "UNKNOWN_ERROR", {
212:             groupId,
213:           });
214: 
215:     const errorMessage = `Error processing group ${groupId}: ${syncError.message}`;
216:     metadata.errors.push(errorMessage);
217:     await logError(syncError.toGenericError(), "processGroupPrices");
218:   }
219: }
220: 
221: export async function syncPrices(
222:   options: SyncOptions = {}
223: ): Promise<SyncMetadata> {
224:   const logger = options.silent ?
225:     undefined :
226:     new SyncLogger({
227:       type: options.dryRun ? "manual" : "scheduled",
228:       limit: options.limit,
229:       dryRun: options.dryRun,
230:       groupId: options.groupId,
231:       batchSize: 25,
232:     });
233: 
234:   if (logger) await logger.start();
235: 
236:   const startTime = Date.now();
237:   const metadata: SyncMetadata = {
238:     lastSync: new Date(),
239:     status: "in_progress",
240:     cardCount: 0,
241:     type: options.dryRun ? "manual" : "scheduled",
242:     groupsProcessed: 0,
243:     groupsUpdated: 0,
244:     errors: [],
245:   };
246: 
247:   try {
248:     let groups: any[] = [];
249: 
250:     if (options.groupId) {
251:       // Get group info for the specific group
252:       const groupResponse = await makeRequest<{ results: any[] }>(
253:         `${FFTCG_CATEGORY_ID}/groups`,
254:         BASE_URL,
255:         {metadata: {operation: "fetchGroups"}}
256:       );
257: 
258:       const group = groupResponse.results.find(
259:         (g) => g.groupId.toString() === options.groupId
260:       );
261:       if (!group) {
262:         throw new Error(`Group ${options.groupId} not found`);
263:       }
264: 
265:       groups = [group];
266:       console.log(`Processing single group: ${options.groupId}`);
267:     } else {
268:       const groupsResponse = await makeRequest<{ results: any[] }>(
269:         `${FFTCG_CATEGORY_ID}/groups`,
270:         BASE_URL,
271:         {metadata: {operation: "fetchGroups"}}
272:       );
273:       groups = groupsResponse.results;
274:     }
275: 
276:     if (logger) {
277:       await logger.logGroupFound(groups.length);
278:     }
279: 
280:     for (const group of groups) {
281:       metadata.groupsProcessed++;
282:       await processGroupPrices(group, options, metadata, logger);
283: 
284:       if (options.limit && metadata.cardCount >= options.limit) break;
285:     }
286: 
287:     metadata.status =
288:       metadata.errors.length > 0 ? "completed_with_errors" : "success";
289: 
290:     if (logger) {
291:       await logger.logSyncResults({
292:         success: metadata.cardCount,
293:         failures: metadata.errors.length,
294:         groupId: options.groupId,
295:         type: options.dryRun ? "Manual" : "Scheduled",
296:       });
297:     }
298:   } catch (error) {
299:     const syncError =
300:       error instanceof SyncError ?
301:         error :
302:         error instanceof Error ?
303:           new SyncError(error.message, "SYNC_MAIN_ERROR") :
304:           new SyncError("Unknown sync error", "UNKNOWN_ERROR");
305: 
306:     metadata.status = "failed";
307:     metadata.errors.push(syncError.message);
308:     await logError(syncError.toGenericError(), "syncPrices:main");
309:   }
310: 
311:   metadata.lastSync = new Date();
312:   metadata.duration = Date.now() - startTime;
313: 
314:   if (!options.dryRun) {
315:     await db.collection(COLLECTION.SYNC_METADATA).add(metadata);
316:   }
317: 
318:   if (logger) await logger.finish();
319:   return metadata;
320: }
</file>

<file path="src/test/testEndpoints.ts">
 1: import axios, {isAxiosError} from "axios";
 2: 
 3: const FIREBASE_REGION = "us-central1";
 4: const PROJECT_ID = "fftcg-sync-service";
 5: const BASE_URL = `https://${FIREBASE_REGION}-${PROJECT_ID}.cloudfunctions.net`;
 6: 
 7: interface SyncResponse {
 8:   lastSync: Date;
 9:   status: string;
10:   cardCount: number;
11:   type: string;
12:   groupsProcessed: number;
13:   groupsUpdated: number;
14:   errors: string[];
15:   duration?: number;
16: }
17: 
18: async function testEndpoints() {
19:   try {
20:     // Test card sync
21:     console.log("\nTesting card sync...");
22:     const cardResponse = await axios.get<SyncResponse>(
23:       `${BASE_URL}/testCardSync`,
24:       {
25:         params: {
26:           limit: 5,
27:           dryRun: true,
28:           groupId: "23783",
29:           productId: 477236, // Added specific product ID
30:         },
31:       }
32:     );
33:     console.log(
34:       "Card sync results:",
35:       JSON.stringify(cardResponse.data, null, 2)
36:     );
37: 
38:     // Test price sync
39:     console.log("\nTesting price sync...");
40:     const priceResponse = await axios.get<SyncResponse>(
41:       `${BASE_URL}/testPriceSync`,
42:       {
43:         params: {
44:           groupId: "23783",
45:           dryRun: true,
46:           limit: 5,
47:           productId: 477236, // Added specific product ID
48:         },
49:       }
50:     );
51:     console.log(
52:       "Price sync results:",
53:       JSON.stringify(priceResponse.data, null, 2)
54:     );
55: 
56:     // Test health check
57:     console.log("\nTesting health check...");
58:     const healthResponse = await axios.get(`${BASE_URL}/healthCheck`);
59:     console.log(
60:       "Health check response:",
61:       JSON.stringify(healthResponse.data, null, 2)
62:     );
63:   } catch (error) {
64:     if (isAxiosError(error)) {
65:       console.error("Test failed:", error.response?.data || error.message);
66:       console.error("Status:", error.response?.status);
67:       console.error("Headers:", error.response?.headers);
68:     } else {
69:       console.error("Test failed:", error);
70:     }
71:     process.exit(1);
72:   }
73: }
74: 
75: // Execute tests
76: console.log("Starting endpoint tests...");
77: testEndpoints()
78:   .then(() => {
79:     console.log("All tests completed!");
80:   })
81:   .catch(console.error);
</file>

<file path="src/test/testImageHandler.ts">
  1: process.env.NODE_ENV = "test";
  2: process.env.FORCE_UPDATE = "true";
  3: 
  4: import {ImageHandler} from "../utils/imageHandler";
  5: 
  6: const TEST_CASES = [
  7:   {
  8:     imageUrl: "https://tcgplayer-cdn.tcgplayer.com/product/477236_200w.jpg",
  9:     groupId: "23783",
 10:     productId: 477236,
 11:     cardNumber: "1-001H",
 12:     description: "FFVII Boss Deck - Test Card",
 13:   },
 14:   // Add a second test case to verify consistency
 15:   {
 16:     imageUrl: "https://tcgplayer-cdn.tcgplayer.com/product/477237_200w.jpg",
 17:     groupId: "23783",
 18:     productId: 477237,
 19:     cardNumber: "1-002H",
 20:     description: "FFVII Boss Deck - Second Test Card",
 21:   },
 22: ];
 23: 
 24: async function testImageProcessing() {
 25:   try {
 26:     console.log("\n=== Testing Image Handler ===");
 27:     const imageHandler = new ImageHandler();
 28: 
 29:     for (const testCase of TEST_CASES) {
 30:       console.log(`\nProcessing: ${testCase.description}`);
 31: 
 32:       // Test URL generation
 33:       console.log("\nURL Structure Test:");
 34:       console.log(`Original (TCGPlayer): ${testCase.imageUrl}`);
 35:       console.log(
 36:         `Expected High-res: ${testCase.imageUrl.replace(
 37:           "_200w.jpg",
 38:           "_400w.jpg"
 39:         )}`
 40:       );
 41:       console.log(
 42:         `Expected Low-res: ${testCase.imageUrl.replace(".jpg", "_200w.jpg")}`
 43:       );
 44: 
 45:       // Test full image processing
 46:       console.log("\n=== Processing Test ===");
 47:       const result = await imageHandler.processImage(
 48:         testCase.imageUrl,
 49:         testCase.groupId,
 50:         testCase.productId,
 51:         testCase.cardNumber
 52:       );
 53: 
 54:       console.log("\nProcessing Results:");
 55:       console.log(`Status: ${result.updated ? "Updated" : "Unchanged"}`);
 56:       console.log("\nURL Structure:");
 57:       console.log(`Original URL: ${result.originalUrl}`);
 58:       console.log(`High-res URL: ${result.highResUrl}`);
 59:       console.log(`Low-res URL: ${result.lowResUrl}`);
 60: 
 61:       console.log("\nMetadata:");
 62:       console.log(`Content Type: ${result.metadata.contentType}`);
 63:       console.log(
 64:         `Original Size: ${(result.metadata.originalSize || 0) / 1024}KB`
 65:       );
 66:       console.log(
 67:         `High-res Size: ${(result.metadata.highResSize || 0) / 1024}KB`
 68:       );
 69:       console.log(
 70:         `Low-res Size: ${(result.metadata.lowResSize || 0) / 1024}KB`
 71:       );
 72:       console.log(`Last Updated: ${result.metadata.updated.toISOString()}`);
 73: 
 74:       // Verify URL accessibility
 75:       console.log("\nVerifying URL accessibility:");
 76:       const urlsToTest = [
 77:         {type: "High-res", url: result.highResUrl},
 78:         {type: "Low-res", url: result.lowResUrl},
 79:       ];
 80: 
 81:       for (const {type, url} of urlsToTest) {
 82:         if (url) {
 83:           try {
 84:             const response = await fetch(url, {method: "HEAD"});
 85:             console.log(
 86:               `${type} URL accessible: ${response.ok} (${response.status})`
 87:             );
 88:             if (response.ok) {
 89:               console.log(
 90:                 `Cache-Control: ${response.headers.get("cache-control")}`
 91:               );
 92:             }
 93:           } catch (error) {
 94:             console.error(`${type} URL not accessible:`, error);
 95:           }
 96:         } else {
 97:           console.log(`${type} URL not generated`);
 98:         }
 99:       }
100: 
101:       // Test metadata storage
102:       console.log("\nVerifying metadata structure:");
103:       console.log(
104:         "- No URLs in metadata:",
105:         !Object.keys(result.metadata).some((key) =>
106:           key.toLowerCase().includes("url")
107:         )
108:       );
109:       console.log(
110:         "- Has required fields:",
111:         result.metadata.contentType &&
112:           result.metadata.size !== undefined &&
113:           result.metadata.updated instanceof Date
114:       );
115:     }
116: 
117:     // Test cleanup (dry run)
118:     console.log("\n=== Cleanup Test (Dry Run) ===");
119:     await imageHandler.cleanup(true);
120:   } catch (error) {
121:     console.error("\nTest failed:", error);
122:     process.exit(1);
123:   }
124: }
125: 
126: async function runTests() {
127:   console.log("Starting Image Handler tests...");
128:   console.log("Testing new URL structure and public access...");
129: 
130:   try {
131:     await testImageProcessing();
132:     console.log("\nAll Image Handler tests completed successfully!");
133:   } catch (error) {
134:     console.error("\nTests failed:", error);
135:     process.exit(1);
136:   }
137: }
138: 
139: // Execute the tests
140: runTests().catch(console.error);
</file>

<file path="src/test/testSync.ts">
 1: // src/test/testSync.ts
 2: 
 3: // Force test mode and updates
 4: process.env.NODE_ENV = "test";
 5: process.env.FORCE_UPDATE = "true";
 6: 
 7: import {syncCards} from "../services/cardSync";
 8: 
 9: async function testSync() {
10:   console.log("\n=== Testing Card Sync ===");
11: 
12:   const testGroups = [
13:     {id: "23783", name: "Hidden Legends"},
14:     {id: "1939", name: "Opus I"},
15:     {id: "23568", name: "Hidden Trials"},
16:   ];
17: 
18:   for (const group of testGroups) {
19:     console.log(`\nTesting sync for ${group.name} (${group.id})`);
20: 
21:     try {
22:       const options = {
23:         groupId: group.id,
24:         limit: 5,
25:         dryRun: false, // Changed to false to actually process updates
26:         showAll: true,
27:         force: true,
28:         skipImages: false,
29:       };
30: 
31:       const result = await syncCards(options);
32: 
33:       console.log("\nSync Results:");
34:       console.log(`Status: ${result.status}`);
35:       console.log(`Cards Processed: ${result.cardCount}`);
36:       console.log(`Groups Updated: ${result.groupsUpdated}`);
37:       console.log(`Images Processed: ${result.imagesProcessed}`);
38:       console.log(`Images Updated: ${result.imagesUpdated}`);
39: 
40:       if (result.errors.length > 0) {
41:         console.log("\nErrors:");
42:         result.errors.forEach((error) => console.log(`- ${error}`));
43:       }
44:     } catch (error) {
45:       console.error(`Error syncing ${group.name}:`, error);
46:     }
47:   }
48: }
49: 
50: // Execute the test
51: console.log("Starting Card Sync tests...");
52: testSync()
53:   .then(() => console.log("\nAll Card Sync tests completed!"))
54:   .catch(console.error);
</file>

<file path="src/test/validateSync.ts">
  1: // src/test/validateSync.ts
  2: 
  3: import * as admin from "firebase-admin";
  4: import {Timestamp} from "firebase-admin/firestore";
  5: import {ServiceAccount} from "firebase-admin";
  6: import * as path from "path";
  7: import * as fs from "fs/promises";
  8: import {COLLECTION} from "../config/firebase";
  9: 
 10: interface ValidationResult {
 11:   collection: string;
 12:   documentsChecked: number;
 13:   documentsValid: number;
 14:   errors: string[];
 15:   details?: Record<string, any>;
 16: }
 17: 
 18: interface ValidationOptions {
 19:   limit?: number;
 20:   verbose?: boolean;
 21:   groupId?: string;
 22: }
 23: 
 24: async function initializeFirebase(): Promise<FirebaseFirestore.Firestore> {
 25:   try {
 26:     const serviceAccountPath = path.resolve(
 27:       __dirname,
 28:       "../../../service_account_key.json"
 29:     );
 30:     const serviceAccountData = await fs.readFile(serviceAccountPath, "utf8");
 31:     const serviceAccount = JSON.parse(serviceAccountData) as ServiceAccount;
 32: 
 33:     if (!admin.apps.length) {
 34:       admin.initializeApp({
 35:         credential: admin.credential.cert(serviceAccount),
 36:       });
 37:     }
 38: 
 39:     return admin.firestore();
 40:   } catch (error) {
 41:     console.error("Failed to initialize Firebase:", error);
 42:     throw error;
 43:   }
 44: }
 45: 
 46: async function validateCollection(
 47:   db: FirebaseFirestore.Firestore,
 48:   collectionName: string,
 49:   validator: (doc: FirebaseFirestore.DocumentData) => boolean,
 50:   options: ValidationOptions = {}
 51: ): Promise<ValidationResult> {
 52:   const result: ValidationResult = {
 53:     collection: collectionName,
 54:     documentsChecked: 0,
 55:     documentsValid: 0,
 56:     errors: [],
 57:     details: {},
 58:   };
 59: 
 60:   try {
 61:     let query = db.collection(collectionName).orderBy("lastUpdated", "desc");
 62: 
 63:     if (options.limit) {
 64:       query = query.limit(options.limit);
 65:     }
 66: 
 67:     if (options.groupId) {
 68:       if (
 69:         collectionName === COLLECTION.CARDS ||
 70:         collectionName === COLLECTION.PRICES
 71:       ) {
 72:         query = query.where("groupId", "==", options.groupId);
 73:       }
 74:     }
 75: 
 76:     const snapshot = await query.get();
 77:     result.documentsChecked = snapshot.size;
 78: 
 79:     snapshot.forEach((doc) => {
 80:       const data = doc.data();
 81:       try {
 82:         if (validator(data)) {
 83:           result.documentsValid++;
 84:           if (options.verbose) {
 85:             // For cards and prices, verify the document ID format
 86:             if (
 87:               collectionName === COLLECTION.CARDS ||
 88:               collectionName === COLLECTION.PRICES
 89:             ) {
 90:               const [productId, cardNumber] = doc.id.split("_");
 91:               if (!productId || !cardNumber) {
 92:                 result.errors.push(`Invalid document ID format for ${doc.id}`);
 93:                 return;
 94:               }
 95:               if (parseInt(productId) !== data.productId) {
 96:                 result.errors.push(
 97:                   `Document ID productId mismatch for ${doc.id}`
 98:                 );
 99:                 return;
100:               }
101:               const numberField = data.extendedData?.find(
102:                 (field: any) => field.name === "Number"
103:               );
104:               if (numberField && numberField.value !== cardNumber) {
105:                 result.errors.push(
106:                   `Document ID cardNumber mismatch for ${doc.id}`
107:                 );
108:                 return;
109:               }
110:             }
111:             result.details![doc.id] = data;
112:           }
113:         } else {
114:           result.errors.push(`Document ${doc.id} failed validation`);
115:         }
116:       } catch (error) {
117:         result.errors.push(`Error validating ${doc.id}: ${error}`);
118:       }
119:     });
120:   } catch (error) {
121:     result.errors.push(`Error accessing collection: ${error}`);
122:   }
123: 
124:   return result;
125: }
126: 
127: async function validateSync(options: ValidationOptions = {}) {
128:   console.log("Starting sync validation...");
129:   console.log("Options:", JSON.stringify(options, null, 2));
130: 
131:   try {
132:     const db = await initializeFirebase();
133: 
134:     // Validate cards
135:     const cardResult = await validateCollection(
136:       db,
137:       COLLECTION.CARDS,
138:       (data) => {
139:         return (
140:           typeof data.productId === "number" &&
141:           typeof data.name === "string" &&
142:           typeof data.lastUpdated === "object" &&
143:           data.lastUpdated instanceof Timestamp &&
144:           Array.isArray(data.extendedData) &&
145:           data.extendedData.some(
146:             (field: any) => field.name === "Number" && field.value
147:           )
148:         );
149:       },
150:       options
151:     );
152: 
153:     // Validate prices
154:     const priceResult = await validateCollection(
155:       db,
156:       COLLECTION.PRICES,
157:       (data) => {
158:         return (
159:           data.lastUpdated instanceof Timestamp &&
160:           (!data.normal || typeof data.normal.midPrice === "number") &&
161:           (!data.foil || typeof data.foil.midPrice === "number") &&
162:           typeof data.productId === "number" &&
163:           typeof data.cardNumber === "string"
164:         );
165:       },
166:       options
167:     );
168: 
169:     // Validate sync metadata
170:     const metadataResult = await validateCollection(
171:       db,
172:       COLLECTION.SYNC_METADATA,
173:       (data) => {
174:         return (
175:           data.lastSync instanceof Timestamp &&
176:           typeof data.status === "string" &&
177:           typeof data.cardCount === "number" &&
178:           Array.isArray(data.errors)
179:         );
180:       },
181:       options
182:     );
183: 
184:     // Print results
185:     console.log("\nValidation Results:");
186:     [cardResult, priceResult, metadataResult].forEach((result) => {
187:       console.log(`\n${result.collection}:`);
188:       console.log(`Documents Checked: ${result.documentsChecked}`);
189:       console.log(`Valid Documents: ${result.documentsValid}`);
190:       if (result.errors.length > 0) {
191:         console.log("Errors:");
192:         result.errors.forEach((error) => console.log(`- ${error}`));
193:       }
194:       if (options.verbose && result.details) {
195:         console.log("\nDetails:");
196:         console.log(JSON.stringify(result.details, null, 2));
197:       }
198:     });
199:   } catch (error) {
200:     console.error("Validation failed:", error);
201:     process.exit(1);
202:   }
203: }
204: 
205: // Execute validation with command line arguments
206: const args = process.argv.slice(2);
207: const options: ValidationOptions = {
208:   limit: args.includes("--limit") ?
209:     parseInt(args[args.indexOf("--limit") + 1]) :
210:     undefined,
211:   verbose: args.includes("--verbose"),
212:   groupId: args.includes("--groupId") ?
213:     args[args.indexOf("--groupId") + 1] :
214:     undefined,
215: };
216: 
217: validateSync(options)
218:   .then(() => {
219:     console.log("\nValidation completed!");
220:   })
221:   .catch(console.error);
</file>

<file path="src/types/index.ts">
  1: // src/types/index.ts
  2: 
  3: import type * as express from "express";
  4: 
  5: export {express};
  6: 
  7: export interface GenericError extends Error {
  8:   code?: string;
  9:   message: string;
 10:   stack?: string;
 11: }
 12: 
 13: export interface CardProduct {
 14:   productId: number;
 15:   name: string;
 16:   cleanName: string;
 17:   imageUrl?: string; // TCGPlayer URL (from API)
 18:   highResUrl: string; // Firebase Storage URL (_400w)
 19:   lowResUrl: string; // Firebase Storage URL (_200w)
 20:   categoryId: number;
 21:   groupId: number;
 22:   url: string;
 23:   modifiedOn: string;
 24:   imageCount: number;
 25:   imageMetadata?: ImageMetadata;
 26:   extendedData: Array<{
 27:     name: string;
 28:     displayName: string;
 29:     value: string;
 30:   }>;
 31: }
 32: 
 33: export interface CardPrice {
 34:   productId: number;
 35:   lowPrice: number;
 36:   midPrice: number;
 37:   highPrice: number;
 38:   marketPrice: number | null;
 39:   directLowPrice: number | null;
 40:   subTypeName: "Normal" | "Foil";
 41: }
 42: 
 43: export interface SyncOptions {
 44:   dryRun?: boolean;
 45:   limit?: number;
 46:   groupId?: string;
 47:   productId?: number;
 48:   showAll?: boolean;
 49:   skipImages?: boolean;
 50:   imagesOnly?: boolean; // New option
 51:   silent?: boolean;
 52:   force?: boolean;
 53: }
 54: 
 55: export interface SyncMetadata {
 56:   lastSync: Date;
 57:   status: "in_progress" | "success" | "failed" | "completed_with_errors";
 58:   cardCount: number;
 59:   type: "manual" | "scheduled";
 60:   groupsProcessed: number;
 61:   groupsUpdated: number;
 62:   errors: string[];
 63:   duration?: number;
 64:   imagesProcessed?: number;
 65:   imagesUpdated?: number;
 66: }
 67: 
 68: export type CacheType = "card" | "price" | "image";
 69: 
 70: export interface PriceData {
 71:   normal?: CardPrice;
 72:   foil?: CardPrice;
 73:   lastUpdated: Date;
 74:   productId: number;
 75:   cardNumber: string;
 76: }
 77: 
 78: export interface ImageMetadata {
 79:   contentType: string;
 80:   size: number;
 81:   updated: Date;
 82:   hash: string;
 83:   groupId?: string;
 84:   productId?: number;
 85:   cardNumber?: string;
 86:   lastUpdated?: Date;
 87:   originalSize?: number;
 88:   highResSize?: number;
 89:   lowResSize?: number;
 90: }
 91: 
 92: export interface ImageProcessingResult {
 93:   highResUrl: string; // Firebase Storage URL (_400w)
 94:   lowResUrl: string; // Firebase Storage URL (_200w)
 95:   metadata: ImageMetadata;
 96:   updated: boolean;
 97: }
 98: 
 99: export interface ImageSyncStats {
100:   processed: number;
101:   updated: number;
102:   failed: number;
103:   skipped: number;
104: }
105: 
106: export interface LogData {
107:   imageMetadata?: ImageMetadata;
108:   imageSyncStats?: ImageSyncStats;
109:   [key: string]: any;
110: }
111: 
112: export interface CacheOptions {
113:   max: number;
114:   ttl: number;
115: }
116: 
117: export interface CacheEntry<T> {
118:   data: T;
119:   timestamp: number;
120:   expires: number;
121: }
122: 
123: export interface ImageProcessingError extends GenericError {
124:   productId: number;
125:   groupId: string;
126:   originalUrl: string;
127:   type: "download" | "upload" | "metadata" | "unknown";
128: }
129: 
130: export type GenericObject = Record<string, any>;
131: 
132: export interface BatchProcessingStats {
133:   total: number;
134:   processed: number;
135:   successful: number;
136:   failed: number;
137:   skipped: number;
138: }
139: 
140: export interface BatchOptions {
141:   batchSize?: number;
142:   delayBetweenBatches?: number;
143:   onBatchComplete?: (stats: BatchProcessingStats) => Promise<void>;
144:   skipImages?: boolean;
145:   retryFailedImages?: boolean;
146: }
147: 
148: export interface BatchProgress {
149:   totalBatches: number;
150:   currentBatch: number;
151:   processedCount: number;
152:   totalItems: number;
153: }
154: 
155: export interface ImageLogEntry {
156:   timestamp: Date;
157:   level: "INFO" | "WARNING" | "ERROR";
158:   message: string;
159:   context?: string;
160:   metadata?: ImageMetadata;
161:   error?: ImageProcessingError;
162:   stats?: ImageSyncStats;
163: }
164: 
165: export interface StoragePaths {
166:   original: string;
167:   processed: string;
168: }
169: 
170: export interface StorageOptions {
171:   contentType: string;
172:   metadata?: Record<string, string>;
173:   cacheControl?: string;
174: }
175: 
176: export interface ImageProcessingProgress {
177:   total: number;
178:   current: number;
179:   updated: number;
180:   failed: number;
181:   startTime: number;
182:   estimatedTimeRemaining?: number;
183: }
184: 
185: export interface ImageValidationError {
186:   code: "FILE_TOO_LARGE" | "INVALID_FORMAT" | "VALIDATION_ERROR";
187:   message: string;
188: }
189: 
190: export interface SyncMode {
191:   type: "data" | "images" | "full";
192:   isForced: boolean;
193:   isDryRun: boolean;
194: }
195: 
196: export interface RefreshOptions {
197:   isDryRun: boolean;
198:   isVerbose: boolean;
199:   isForce: boolean;
200:   groupId?: string;
201:   skipImages: boolean;
202:   imagesOnly: boolean;
203: }
</file>

<file path="src/utils/backup.ts">
  1: // src/utils/backup.ts
  2: 
  3: import {db, COLLECTION} from "../config/firebase";
  4: import * as fs from "fs";
  5: import * as path from "path";
  6: 
  7: interface BackupMetadata {
  8:   timestamp: string;
  9:   collections: string[];
 10:   documentCounts: { [key: string]: number };
 11: }
 12: 
 13: export async function backup(): Promise<void> {
 14:   const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
 15:   const backupDir = path.join(__dirname, "..", "..", "backups");
 16:   const backupPath = path.join(backupDir, `backup_${timestamp}`);
 17: 
 18:   // Create backup directory if it doesn't exist
 19:   if (!fs.existsSync(backupDir)) {
 20:     fs.mkdirSync(backupDir, {recursive: true});
 21:   }
 22: 
 23:   const collections = [
 24:     COLLECTION.CARDS,
 25:     COLLECTION.PRICES,
 26:     COLLECTION.SYNC_METADATA,
 27:     COLLECTION.CARD_HASHES,
 28:     COLLECTION.PRICE_HASHES,
 29:     COLLECTION.IMAGE_METADATA,
 30:   ];
 31: 
 32:   const metadata: BackupMetadata = {
 33:     timestamp,
 34:     collections,
 35:     documentCounts: {},
 36:   };
 37: 
 38:   try {
 39:     console.log("Starting database backup...");
 40: 
 41:     for (const collectionName of collections) {
 42:       console.log(`Backing up collection: ${collectionName}`);
 43: 
 44:       const snapshot = await db.collection(collectionName).get();
 45:       const documents = snapshot.docs.map((doc) => ({
 46:         id: doc.id,
 47:         data: doc.data(),
 48:       }));
 49: 
 50:       metadata.documentCounts[collectionName] = documents.length;
 51: 
 52:       // Save collection to its own file
 53:       const collectionPath = `${backupPath}_${collectionName}.json`;
 54:       fs.writeFileSync(collectionPath, JSON.stringify(documents, null, 2));
 55: 
 56:       console.log(`- Backed up ${documents.length} documents`);
 57:     }
 58: 
 59:     // Save metadata
 60:     const metadataPath = `${backupPath}_metadata.json`;
 61:     fs.writeFileSync(metadataPath, JSON.stringify(metadata, null, 2));
 62: 
 63:     console.log("\nBackup completed successfully");
 64:     console.log(`Location: ${backupDir}`);
 65:     console.log("Files:");
 66:     collections.forEach((collection) => {
 67:       console.log(`- backup_${timestamp}_${collection}.json`);
 68:     });
 69:     console.log(`- backup_${timestamp}_metadata.json`);
 70:   } catch (error) {
 71:     console.error("Backup failed:", error);
 72:     throw error;
 73:   }
 74: }
 75: 
 76: export async function restore(timestamp: string): Promise<void> {
 77:   const backupDir = path.join(__dirname, "..", "..", "backups");
 78:   const metadataPath = path.join(
 79:     backupDir,
 80:     `backup_${timestamp}_metadata.json`
 81:   );
 82: 
 83:   if (!fs.existsSync(metadataPath)) {
 84:     throw new Error(`Backup metadata not found: ${metadataPath}`);
 85:   }
 86: 
 87:   const metadata: BackupMetadata = JSON.parse(
 88:     fs.readFileSync(metadataPath, "utf8")
 89:   );
 90: 
 91:   try {
 92:     console.log("Starting database restore...");
 93: 
 94:     for (const collectionName of metadata.collections) {
 95:       console.log(`Restoring collection: ${collectionName}`);
 96: 
 97:       const collectionPath = path.join(
 98:         backupDir,
 99:         `backup_${timestamp}_${collectionName}.json`
100:       );
101:       const documents = JSON.parse(fs.readFileSync(collectionPath, "utf8"));
102: 
103:       const batch = db.batch();
104:       let batchCount = 0;
105:       let totalRestored = 0;
106: 
107:       for (const doc of documents) {
108:         const ref = db.collection(collectionName).doc(doc.id);
109:         batch.set(ref, doc.data);
110:         batchCount++;
111: 
112:         if (batchCount >= 500) {
113:           // Firestore batch limit
114:           await batch.commit();
115:           totalRestored += batchCount;
116:           batchCount = 0;
117:         }
118:       }
119: 
120:       if (batchCount > 0) {
121:         await batch.commit();
122:         totalRestored += batchCount;
123:       }
124: 
125:       console.log(`- Restored ${totalRestored} documents`);
126:     }
127: 
128:     console.log("\nRestore completed successfully");
129:   } catch (error) {
130:     console.error("Restore failed:", error);
131:     throw error;
132:   }
133: }
134: 
135: // If run directly, perform backup
136: if (require.main === module) {
137:   backup()
138:     .then(() => process.exit(0))
139:     .catch((error) => {
140:       console.error("Fatal error:", error);
141:       process.exit(1);
142:     });
143: }
</file>

<file path="src/utils/cache.ts">
 1: import LRUCache from "lru-cache";
 2: import {CacheType, CardProduct} from "../types";
 3: 
 4: const options = {
 5:   max: 500,
 6:   ttl: 1000 * 60 * 60, // 1 hour
 7: };
 8: 
 9: export const cardCache = new LRUCache<string, CardProduct>(options);
10: 
11: export const getCacheKey = (
12:   type: CacheType,
13:   id: number,
14:   cardNumber?: string
15: ): string => {
16:   return cardNumber ? `${type}:${id}:${cardNumber}` : `${type}:${id}`;
17: };
</file>

<file path="src/utils/databaseBackup.ts">
 1: import {db, COLLECTION} from "../config/firebase";
 2: import * as fs from "fs/promises";
 3: import * as path from "path";
 4: 
 5: async function backupCollection(collectionName: string): Promise<void> {
 6:   console.log(`Backing up ${collectionName}...`);
 7:   const snapshot = await db.collection(collectionName).get();
 8:   const data = snapshot.docs.map((doc) => ({
 9:     id: doc.id,
10:     data: doc.data(),
11:   }));
12: 
13:   const backupDir = path.join(__dirname, "../../backups");
14:   await fs.mkdir(backupDir, {recursive: true});
15: 
16:   const timestamp = new Date().toISOString().replace(/[:]/g, "-");
17:   const filename = `${collectionName}_${timestamp}.json`;
18:   await fs.writeFile(
19:     path.join(backupDir, filename),
20:     JSON.stringify(data, null, 2)
21:   );
22: 
23:   console.log(`Backed up ${data.length} documents from ${collectionName}`);
24: }
25: 
26: export async function backupDatabase(): Promise<void> {
27:   try {
28:     console.log("Starting database backup...");
29: 
30:     await Promise.all([
31:       backupCollection(COLLECTION.CARDS),
32:       backupCollection(COLLECTION.PRICES),
33:       backupCollection(COLLECTION.SYNC_METADATA),
34:       backupCollection(COLLECTION.CARD_HASHES),
35:       backupCollection(COLLECTION.PRICE_HASHES),
36:       backupCollection(COLLECTION.IMAGE_METADATA),
37:     ]);
38: 
39:     console.log("Backup completed successfully!");
40:   } catch (error) {
41:     console.error("Backup failed:", error);
42:     throw error;
43:   }
44: }
</file>

<file path="src/utils/databaseCleanup.ts">
 1: import { db, COLLECTION } from "../config/firebase";
 2: import { logInfo } from "./logger";
 3: import { FieldValue } from "firebase-admin/firestore";
 4: 
 5: export async function cleanupImageUrls(): Promise<void> {
 6:   let count = 0;
 7:   let batchCount = 0;
 8:   let batch = db.batch(); // Initialize first batch
 9: 
10:   const snapshot = await db.collection(COLLECTION.CARDS).get();
11: 
12:   for (const doc of snapshot.docs) {
13:     const data = doc.data();
14: 
15:     if (data.imageUrl) {
16:       const updates: any = {
17:         originalUrl: data.imageUrl,
18:         lastUpdated: new Date(),
19:       };
20: 
21:       // Remove imageUrl field
22:       updates.imageUrl = FieldValue.delete();
23: 
24:       batch.update(doc.ref, updates);
25:       count++;
26:       batchCount++;
27: 
28:       if (batchCount >= 500) {
29:         // Firestore batch limit
30:         await batch.commit();
31:         await logInfo(`Processed ${count} documents`);
32:         // Create a new batch after commit
33:         batch = db.batch();
34:         batchCount = 0;
35:       }
36:     }
37:   }
38: 
39:   // Commit any remaining updates
40:   if (batchCount > 0) {
41:     await batch.commit();
42:     await logInfo(`Processed final batch of ${batchCount} documents`);
43:   }
44: 
45:   await logInfo(`Cleanup completed. Updated ${count} documents`);
46: }
47: 
48: // Execute if run directly
49: if (require.main === module) {
50:   cleanupImageUrls()
51:     .then(() => {
52:       console.log("Cleanup completed successfully!");
53:       process.exit(0);
54:     })
55:     .catch((error) => {
56:       console.error("Cleanup failed:", error);
57:       process.exit(1);
58:     });
59: }
</file>

<file path="src/utils/databaseRefresh.ts">
  1: // src/utils/databaseRefresh.ts
  2: 
  3: import {syncCards} from "../services/cardSync";
  4: import {syncPrices} from "../services/priceSync";
  5: import {backup} from "../utils/backup";
  6: import {logError} from "./logger";
  7: import {GenericError, SyncMode} from "../types";
  8: import {db, COLLECTION} from "../config/firebase";
  9: 
 10: interface RefreshSetSummary {
 11:   name: string;
 12:   cards: {
 13:     total: number;
 14:     toUpdate: number;
 15:     unchanged: number;
 16:   };
 17:   prices: {
 18:     total: number;
 19:     toUpdate: number;
 20:     unchanged: number;
 21:   };
 22:   images: {
 23:     total: number;
 24:     toUpdate: number;
 25:     unchanged: number;
 26:   };
 27: }
 28: 
 29: interface RefreshSummary {
 30:   sets: RefreshSetSummary[];
 31:   mode: SyncMode;
 32:   duration?: number;
 33: }
 34: 
 35: interface RefreshOptions {
 36:   isDryRun: boolean;
 37:   isVerbose: boolean;
 38:   isForce: boolean;
 39:   groupId?: string;
 40:   skipImages: boolean;
 41:   imagesOnly: boolean;
 42: }
 43: 
 44: async function parseCommandLineArgs(): Promise<RefreshOptions> {
 45:   const args = process.argv.slice(2);
 46:   return {
 47:     isDryRun: args.includes("--dry-run"),
 48:     isVerbose: args.includes("--verbose"),
 49:     isForce: args.includes("--force"),
 50:     groupId: args.includes("--group-id") ? 
 51:       args[args.indexOf("--group-id") + 1] : undefined,
 52:     skipImages: args.includes("--skip-images"),
 53:     imagesOnly: args.includes("--images-only"),
 54:   };
 55: }
 56: 
 57: async function resetDatabase(): Promise<void> {
 58:   await backup();
 59: }
 60: 
 61: async function clearHashes(): Promise<void> {
 62:   console.log("Clearing existing hashes...");
 63:   const batch = db.batch();
 64: 
 65:   const cardHashes = await db.collection(COLLECTION.CARD_HASHES).get();
 66:   cardHashes.docs.forEach((doc) => {
 67:     batch.delete(doc.ref);
 68:   });
 69: 
 70:   const priceHashes = await db.collection(COLLECTION.PRICE_HASHES).get();
 71:   priceHashes.docs.forEach((doc) => {
 72:     batch.delete(doc.ref);
 73:   });
 74: 
 75:   await batch.commit();
 76:   console.log("Hashes cleared");
 77: }
 78: 
 79: function validateOptions(options: RefreshOptions): void {
 80:   if (options.skipImages && options.imagesOnly) {
 81:     throw new Error("Cannot use both --skip-images and --images-only flags");
 82:   }
 83: }
 84: 
 85: function getSyncMode(options: RefreshOptions): SyncMode {
 86:   return {
 87:     type: options.imagesOnly ? 'images' : options.skipImages ? 'data' : 'full',
 88:     isForced: options.isForce,
 89:     isDryRun: options.isDryRun
 90:   };
 91: }
 92: 
 93: async function displayInitialSummary(options: RefreshOptions, mode: SyncMode): Promise<void> {
 94:   console.log(`\nFFTCG Database ${options.isDryRun ? "Analysis" : "Refresh"}`);
 95:   console.log("==========================");
 96:   console.log(`Mode: ${mode.type.toUpperCase()}`);
 97:   if (options.groupId) console.log(`Processing group: ${options.groupId}`);
 98:   console.log("Force mode:", options.isForce ? "enabled" : "disabled");
 99:   console.log("Verbose mode:", options.isVerbose ? "enabled" : "disabled");
100:   console.log("Dry run:", options.isDryRun ? "yes" : "no");
101:   console.log("\nStarting process...");
102: }
103: 
104: export async function refreshDatabase(): Promise<void> {
105:   const startTime = Date.now();
106:   const options = await parseCommandLineArgs();
107: 
108:   try {
109:     validateOptions(options);
110:     const mode = getSyncMode(options);
111:     await displayInitialSummary(options, mode);
112: 
113:     const summary: RefreshSummary = {
114:       sets: [],
115:       mode,
116:     };
117: 
118:     // Analysis Phase
119:     console.log("\nAnalyzing current state...");
120: 
121:     if (options.isForce && !options.isDryRun) {
122:       await clearHashes();
123:     }
124: 
125:     // Card/Image Sync Analysis
126:     const cardResult = await syncCards({
127:       dryRun: true,
128:       skipImages: options.skipImages,
129:       imagesOnly: options.imagesOnly,
130:       silent: !options.isVerbose,
131:       force: options.isForce,
132:       groupId: options.groupId,
133:     });
134: 
135:     // Price Sync Analysis (skip if images-only)
136:     const priceResult = !options.imagesOnly
137:       ? await syncPrices({
138:           dryRun: true,
139:           silent: !options.isVerbose,
140:           force: options.isForce,
141:           groupId: options.groupId,
142:         })
143:       : {
144:           cardCount: 0,
145:           groupsUpdated: 0,
146:           errors: [],
147:         };
148: 
149:     // Display Analysis Results
150:     console.log("\nAnalysis Results:");
151:     console.log("----------------");
152: 
153:     if (options.imagesOnly) {
154:       console.log("\nImage Processing:");
155:       console.log(`Images to Process: ${cardResult.imagesProcessed || 0}`);
156:       console.log(`Images to Update: ${cardResult.imagesUpdated || 0}`);
157:     } else if (options.skipImages) {
158:       console.log("\nData Processing:");
159:       console.log(`Cards to Update: ${cardResult.cardCount}`);
160:       console.log(`Prices to Update: ${priceResult.cardCount}`);
161:     } else {
162:       console.log("\nFull Sync Processing:");
163:       console.log(`Cards to Update: ${cardResult.cardCount}`);
164:       console.log(`Prices to Update: ${priceResult.cardCount}`);
165:       console.log(`Images to Process: ${cardResult.imagesProcessed || 0}`);
166:       console.log(`Images to Update: ${cardResult.imagesUpdated || 0}`);
167:     }
168: 
169:     // Perform Updates if not dry run
170:     if (!options.isDryRun) {
171:       console.log("\nPerforming Updates:");
172:       console.log("------------------");
173: 
174:       console.log("Creating backup...");
175:       await resetDatabase();
176: 
177:       // Perform Card/Image Updates
178:       const cardUpdateResult = await syncCards({
179:         dryRun: false,
180:         skipImages: options.skipImages,
181:         imagesOnly: options.imagesOnly,
182:         silent: !options.isVerbose,
183:         force: options.isForce,
184:         groupId: options.groupId,
185:       });
186: 
187:       // Perform Price Updates (skip if images-only)
188:       const priceUpdateResult = !options.imagesOnly
189:         ? await syncPrices({
190:             dryRun: false,
191:             silent: !options.isVerbose,
192:             force: options.isForce,
193:             groupId: options.groupId,
194:           })
195:         : {
196:             cardCount: 0,
197:             groupsUpdated: 0,
198:             errors: [],
199:           };
200: 
201:       // Display Update Results
202:       console.log("\nUpdate Results:");
203:       console.log("--------------");
204: 
205:       if (options.imagesOnly) {
206:         console.log(
207:           `Images Processed: ${cardUpdateResult.imagesProcessed || 0}`
208:         );
209:         console.log(`Images Updated: ${cardUpdateResult.imagesUpdated || 0}`);
210:       } else if (options.skipImages) {
211:         console.log(`Cards Updated: ${cardUpdateResult.cardCount}`);
212:         console.log(`Groups Updated: ${cardUpdateResult.groupsUpdated}`);
213:         console.log(`Price Records Updated: ${priceUpdateResult.cardCount}`);
214:       } else {
215:         console.log(`Cards Updated: ${cardUpdateResult.cardCount}`);
216:         console.log(`Groups Updated: ${cardUpdateResult.groupsUpdated}`);
217:         console.log(`Price Records Updated: ${priceUpdateResult.cardCount}`);
218:         console.log(
219:           `Images Processed: ${cardUpdateResult.imagesProcessed || 0}`
220:         );
221:         console.log(`Images Updated: ${cardUpdateResult.imagesUpdated || 0}`);
222:       }
223: 
224:       // Display any errors encountered
225:       if (
226:         cardUpdateResult.errors.length > 0 ||
227:         priceUpdateResult.errors.length > 0
228:       ) {
229:         console.log("\nErrors encountered:");
230:         [...cardUpdateResult.errors, ...priceUpdateResult.errors].forEach(
231:           (error) => {
232:             console.log(`- ${error}`);
233:           }
234:         );
235:       }
236:     } else {
237:       console.log("\nThis was a dry run - no changes were made");
238:       console.log("Run without --dry-run flag to perform updates");
239:     }
240: 
241:     // Calculate and display duration
242:     const duration = (Date.now() - startTime) / 1000;
243:     summary.duration = duration;
244: 
245:     console.log("\nOperation Summary:");
246:     console.log("-----------------");
247:     console.log(`Total Duration: ${duration.toFixed(2)} seconds`);
248:     console.log(`Mode: ${summary.mode.type.toUpperCase()}`);
249:     console.log(`Operation Type: ${options.isDryRun ? "Analysis" : "Update"}`);
250:     if (options.groupId) {
251:       console.log(`Processed Group: ${options.groupId}`);
252:     }
253:   } catch (error) {
254:     const genericError: GenericError = {
255:       message: error instanceof Error ? error.message : "Unknown error",
256:       name: error instanceof Error ? error.name : "UnknownError",
257:       code: error instanceof Error ? error.name : "UNKNOWN_ERROR",
258:       stack: error instanceof Error ? error.stack : undefined,
259:     };
260:     console.error("\nError:", genericError.message);
261:     await logError(genericError, "Database refresh failed");
262:     throw error;
263:   }
264: }
265: 
266: // Function to handle environment checks
267: function checkEnvironment(): void {
268:   if (!process.env.FUNCTIONS_EMULATOR && !process.env.NODE_ENV) {
269:     console.warn("\nWarning: Running in production environment");
270:     console.warn("Set NODE_ENV=development for local testing");
271:   }
272: 
273:   if (process.env.RESTRICT_BANDWIDTH === "true") {
274:     console.warn("\nWarning: Bandwidth restrictions are enabled");
275:     console.warn("Image processing may be limited");
276:   }
277: }
278: 
279: // Main execution
280: if (require.main === module) {
281:   checkEnvironment();
282:   refreshDatabase()
283:     .then(() => {
284:       console.log("\nOperation completed successfully!");
285:       process.exit(0);
286:     })
287:     .catch((error) => {
288:       console.error("\nFatal error:", error);
289:       process.exit(1);
290:     });
291: }
292: 
293: // Export additional utilities for testing and external use
294: export const utils = {
295:   parseCommandLineArgs,
296:   validateOptions,
297:   getSyncMode,
298:   checkEnvironment,
299: };
</file>

<file path="src/utils/databaseReset.ts">
 1: // src/utils/databaseReset.ts
 2: import {db, COLLECTION} from "../config/firebase";
 3: import {backupDatabase} from "./databaseBackup";
 4: import {logInfo, logError} from "./logger";
 5: import {GenericError} from "../types";
 6: 
 7: async function deleteCollection(collectionName: string): Promise<void> {
 8:   const batchSize = 500;
 9:   const query = db.collection(collectionName).limit(batchSize);
10:   let deletedCount = 0;
11:   let hasMore = true;
12: 
13:   try {
14:     while (hasMore) {
15:       const snapshot = await query.get();
16: 
17:       if (snapshot.empty) {
18:         hasMore = false;
19:         continue;
20:       }
21: 
22:       const batch = db.batch();
23:       snapshot.docs.forEach((doc) => {
24:         batch.delete(doc.ref);
25:         deletedCount++;
26:       });
27: 
28:       await batch.commit();
29:       await logInfo(`Deleted ${deletedCount} documents from ${collectionName}`);
30:     }
31: 
32:     await logInfo(`Finished deleting collection ${collectionName}`);
33:   } catch (error) {
34:     const genericError: GenericError = {
35:       message: error instanceof Error ? error.message : "Unknown error",
36:       name: error instanceof Error ? error.name : "UnknownError",
37:       code: error instanceof Error ? error.name : "UNKNOWN_ERROR",
38:       stack: error instanceof Error ? error.stack : undefined,
39:     };
40:     await logError(
41:       genericError,
42:       `Failed to delete collection ${collectionName}`
43:     );
44:     throw error;
45:   }
46: }
47: 
48: export async function resetDatabase(): Promise<void> {
49:   try {
50:     // First, create a backup
51:     await backupDatabase();
52: 
53:     // Then delete all collections
54:     await Promise.all([
55:       deleteCollection(COLLECTION.CARDS),
56:       deleteCollection(COLLECTION.PRICES),
57:       deleteCollection(COLLECTION.SYNC_METADATA),
58:       deleteCollection(COLLECTION.CARD_HASHES),
59:       deleteCollection(COLLECTION.PRICE_HASHES),
60:       deleteCollection(COLLECTION.IMAGE_METADATA),
61:     ]);
62: 
63:     await logInfo("Database reset completed successfully");
64:   } catch (error) {
65:     const genericError: GenericError = {
66:       message: error instanceof Error ? error.message : "Unknown error",
67:       name: error instanceof Error ? error.name : "UnknownError",
68:       code: error instanceof Error ? error.name : "UNKNOWN_ERROR",
69:       stack: error instanceof Error ? error.stack : undefined,
70:     };
71:     await logError(genericError, "Database reset failed");
72:     throw error;
73:   }
74: }
</file>

<file path="src/utils/error.ts">
 1: import {db, COLLECTION} from "../config/firebase";
 2: import {logError} from "./logger";
 3: 
 4: export interface ErrorReport {
 5:   timestamp: Date;
 6:   context: string;
 7:   error: string;
 8:   stackTrace?: string;
 9:   metadata?: Record<string, unknown>;
10:   severity: "ERROR" | "WARNING" | "CRITICAL";
11: }
12: 
13: export class DetailedError extends Error {
14:   constructor(
15:     message: string,
16:     public context: string,
17:     public metadata?: Record<string, unknown>,
18:     public severity: "ERROR" | "WARNING" | "CRITICAL" = "ERROR"
19:   ) {
20:     super(message);
21:     this.name = "DetailedError";
22:   }
23: }
24: 
25: export async function logDetailedError(
26:   error: Error,
27:   context: string,
28:   metadata?: Record<string, unknown>,
29:   severity: "ERROR" | "WARNING" | "CRITICAL" = "ERROR"
30: ): Promise<void> {
31:   const report: ErrorReport = {
32:     timestamp: new Date(),
33:     context,
34:     error: error.message,
35:     stackTrace: error.stack,
36:     metadata,
37:     severity,
38:   };
39: 
40:   // Log to Firestore
41:   await db.collection(COLLECTION.LOGS)
42:     .add(report);
43: 
44:   // Log using existing logger
45:   await logError(error, context);
46: }
</file>

<file path="src/utils/imageCache.ts">
  1: // src/utils/imageCache.ts
  2: 
  3: import LRUCache from "lru-cache";
  4: import {ImageMetadata} from "../types";
  5: import {logInfo} from "./logger";
  6: 
  7: interface CacheStats {
  8:   hits: number;
  9:   misses: number;
 10:   totalRequests: number;
 11: }
 12: 
 13: export class ImageCache {
 14:   private metadataCache: LRUCache<string, ImageMetadata>;
 15:   private bufferCache: LRUCache<string, Buffer>;
 16:   private existsCache: LRUCache<string, boolean>;
 17:   private stats: CacheStats = {
 18:     hits: 0,
 19:     misses: 0,
 20:     totalRequests: 0,
 21:   };
 22: 
 23:   constructor() {
 24:     this.metadataCache = new LRUCache<string, ImageMetadata>({
 25:       max: 1000,
 26:       ttl: 1000 * 60 * 60, // 1 hour
 27:       updateAgeOnGet: true,
 28:     });
 29: 
 30:     this.bufferCache = new LRUCache<string, Buffer>({
 31:       max: 100,
 32:       ttl: 1000 * 60 * 5, // 5 minutes
 33:       updateAgeOnGet: true,
 34:       maxSize: 50 * 1024 * 1024, // 50MB max cache size
 35:       sizeCalculation: (buffer) => buffer.length,
 36:     });
 37: 
 38:     this.existsCache = new LRUCache<string, boolean>({
 39:       max: 1000,
 40:       ttl: 1000 * 60 * 60, // 1 hour
 41:       updateAgeOnGet: true,
 42:     });
 43:   }
 44: 
 45:   getMetadataCacheKey(
 46:     groupId: string,
 47:     productId: number,
 48:     cardNumber: string,
 49:     isHighRes: boolean
 50:   ): string {
 51:     return `metadata:${groupId}:${productId}:${cardNumber}:${
 52:       isHighRes ? "high" : "original"
 53:     }`;
 54:   }
 55: 
 56:   getBufferCacheKey(url: string): string {
 57:     return `buffer:${url}`;
 58:   }
 59: 
 60:   getExistsCacheKey(
 61:     groupId: string,
 62:     productId: number,
 63:     cardNumber: string,
 64:     isHighRes: boolean
 65:   ): string {
 66:     return `exists:${groupId}:${productId}:${cardNumber}:${
 67:       isHighRes ? "high" : "original"
 68:     }`;
 69:   }
 70: 
 71:   async getMetadata(key: string): Promise<ImageMetadata | undefined> {
 72:     this.stats.totalRequests++;
 73:     const value = this.metadataCache.get(key);
 74:     if (value) {
 75:       this.stats.hits++;
 76:       await logInfo("Cache hit: metadata", {
 77:         key,
 78:         timestamp: new Date().toISOString(),
 79:       });
 80:     } else {
 81:       this.stats.misses++;
 82:     }
 83:     return value;
 84:   }
 85: 
 86:   async getBuffer(key: string): Promise<Buffer | undefined> {
 87:     this.stats.totalRequests++;
 88:     const value = this.bufferCache.get(key);
 89:     if (value) {
 90:       this.stats.hits++;
 91:       await logInfo("Cache hit: buffer", {
 92:         key,
 93:         size: value.length,
 94:         timestamp: new Date().toISOString(),
 95:       });
 96:     } else {
 97:       this.stats.misses++;
 98:     }
 99:     return value;
100:   }
101: 
102:   getExists(key: string): boolean | undefined {
103:     this.stats.totalRequests++;
104:     const value = this.existsCache.get(key);
105:     if (value !== undefined) {
106:       this.stats.hits++;
107:     } else {
108:       this.stats.misses++;
109:     }
110:     return value;
111:   }
112: 
113:   setMetadata(key: string, value: ImageMetadata): void {
114:     this.metadataCache.set(key, value);
115:   }
116: 
117:   setBuffer(key: string, value: Buffer): void {
118:     this.bufferCache.set(key, value);
119:   }
120: 
121:   setExists(key: string, value: boolean): void {
122:     this.existsCache.set(key, value);
123:   }
124: 
125:   clear(): void {
126:     this.metadataCache.clear();
127:     this.bufferCache.clear();
128:     this.existsCache.clear();
129:     this.stats = {
130:       hits: 0,
131:       misses: 0,
132:       totalRequests: 0,
133:     };
134:   }
135: 
136:   getStats(): CacheStats {
137:     return {...this.stats};
138:   }
139: }
140: 
141: export const imageCache = new ImageCache();
</file>

<file path="src/utils/imageCompressor.ts">
 1: // src/utils/imageCompressor.ts
 2: 
 3: import sharp from "sharp";
 4: import {logInfo} from "./logger";
 5: 
 6: export interface CompressionResult {
 7:   buffer: Buffer;
 8:   info: {
 9:     width: number;
10:     height: number;
11:     size: number;
12:     format: string;
13:     quality: number;
14:   };
15: }
16: 
17: export class ImageCompressor {
18:   private static readonly QUALITY = {
19:     HIGH_RES: 90,
20:     LOW_RES: 85,
21:   };
22: 
23:   private static readonly DIMENSIONS = {
24:     HIGH_RES: 400,
25:     LOW_RES: 200,
26:   };
27: 
28:   static async compress(
29:     buffer: Buffer,
30:     isHighRes: boolean = false
31:   ): Promise<CompressionResult> {
32:     try {
33:       const quality = isHighRes ? this.QUALITY.HIGH_RES : this.QUALITY.LOW_RES;
34:       const targetWidth = isHighRes ? this.DIMENSIONS.HIGH_RES : this.DIMENSIONS.LOW_RES;
35: 
36:       const originalInfo = await sharp(buffer).metadata();
37:       const originalSize = buffer.length;
38: 
39:       const image = sharp(buffer).jpeg({
40:         quality,
41:         progressive: true,
42:         mozjpeg: true,
43:       });
44: 
45:       if (originalInfo.width && originalInfo.width > targetWidth) {
46:         image.resize(targetWidth, null, {
47:           fit: "inside",
48:           withoutEnlargement: true,
49:         });
50:       }
51: 
52:       const compressedBuffer = await image.toBuffer();
53:       const compressedInfo = await sharp(compressedBuffer).metadata();
54: 
55:       await logInfo("Image compression complete", {
56:         originalSize,
57:         compressedSize: compressedBuffer.length,
58:         dimensions: `${compressedInfo.width}x${compressedInfo.height}`,
59:         quality,
60:         timestamp: new Date().toISOString(),
61:       });
62: 
63:       return {
64:         buffer: compressedBuffer,
65:         info: {
66:           width: compressedInfo.width || 0,
67:           height: compressedInfo.height || 0,
68:           size: compressedBuffer.length,
69:           format: compressedInfo.format || "jpeg",
70:           quality,
71:         },
72:       };
73:     } catch (error) {
74:       throw new Error(
75:         `Image compression failed: ${error instanceof Error ? error.message : "Unknown error"}`
76:       );
77:     }
78:   }
79: 
80:   static async isCompressible(buffer: Buffer): Promise<boolean> {
81:     try {
82:       const info = await sharp(buffer).metadata();
83:       return info.format === "jpeg" || info.format === "jpg";
84:     } catch {
85:       return false;
86:     }
87:   }
88: }
</file>

<file path="src/utils/imageHandler.ts">
  1: import axios, { AxiosError } from "axios";
  2: import { storage, STORAGE, COLLECTION, db } from "../config/firebase";
  3: import { logError, logInfo, logWarning } from "./logger";
  4: import * as crypto from "crypto";
  5: import { GenericError, ImageMetadata, ImageProcessingResult } from "../types";
  6: import { ImageValidator } from "./imageValidator";
  7: import { imageCache } from "./imageCache";
  8: import { ImageCompressor } from "./imageCompressor";
  9: 
 10: interface ImagePathOptions {
 11:   groupId: string;
 12:   productId: number;
 13:   cardNumber: string;
 14:   isHighRes?: boolean;
 15:   isLowRes?: boolean;
 16: }
 17: 
 18: export class ImageHandler {
 19:   private bucket = storage.bucket(STORAGE.BUCKETS.CARD_IMAGES);
 20:   private baseStorageUrl = `https://storage.googleapis.com/${STORAGE.BUCKETS.CARD_IMAGES}`;
 21: 
 22:   private sanitizeCardNumber(cardNumber: string): string {
 23:     // Replace forward slashes with underscores or another safe character
 24:     return cardNumber.replace(/\//g, "_");
 25:   }
 26: 
 27:   private getHighResUrl(imageUrl: string): string {
 28:     return imageUrl.replace(/_200w\.jpg$/, "_400w.jpg");
 29:   }
 30: 
 31:   private getStoragePath(options: ImagePathOptions): string {
 32:     let suffix = "_200w"; // default to low res
 33:     if (options.isHighRes) {
 34:       suffix = "_400w";
 35:     }
 36:     const sanitizedCardNumber = this.sanitizeCardNumber(options.cardNumber);
 37:     const fileName = `${options.productId}_${sanitizedCardNumber}${suffix}.jpg`;
 38:     return `${STORAGE.PATHS.IMAGES}/${options.groupId}/${fileName}`;
 39:   }
 40: 
 41:   private getPublicUrl(storagePath: string): string {
 42:     return `${this.baseStorageUrl}/${storagePath}`;
 43:   }
 44: 
 45:   private async getImageHash(imageBuffer: Buffer): Promise<string> {
 46:     return crypto.createHash("md5").update(imageBuffer).digest("hex");
 47:   }
 48: 
 49:   private async compressImage(
 50:     buffer: Buffer,
 51:     isHighRes: boolean
 52:   ): Promise<Buffer> {
 53:     try {
 54:       const result = await ImageCompressor.compress(buffer, isHighRes);
 55:       await logInfo("Image compression successful", {
 56:         originalSize: buffer.length,
 57:         compressedSize: result.buffer.length,
 58:         quality: result.info.quality,
 59:         dimensions: `${result.info.width}x${result.info.height}`,
 60:         timestamp: new Date().toISOString(),
 61:       });
 62:       return result.buffer;
 63:     } catch (error) {
 64:       await logWarning("Image compression skipped", {
 65:         error: error instanceof Error ? error.message : "Unknown error",
 66:         timestamp: new Date().toISOString(),
 67:       });
 68:       return buffer;
 69:     }
 70:   }
 71: 
 72:   private async downloadImage(url: string): Promise<Buffer> {
 73:     const cacheKey = imageCache.getBufferCacheKey(url);
 74:     const cachedBuffer = await imageCache.getBuffer(cacheKey);
 75: 
 76:     if (cachedBuffer) {
 77:       await logInfo("Using cached image", {
 78:         url,
 79:         size: cachedBuffer.length,
 80:         timestamp: new Date().toISOString(),
 81:       });
 82:       return cachedBuffer;
 83:     }
 84: 
 85:     try {
 86:       await logInfo("Attempting to download image", {
 87:         url,
 88:         timestamp: new Date().toISOString(),
 89:       });
 90: 
 91:       const response = await axios.get(url, {
 92:         responseType: "arraybuffer",
 93:         timeout: 30000,
 94:         headers: {
 95:           Accept: "image/jpeg",
 96:           "User-Agent": "FFTCG-Sync-Service/1.0",
 97:         },
 98:       });
 99: 
100:       const buffer = Buffer.from(response.data);
101:       const validationError = await ImageValidator.validateImage(buffer);
102: 
103:       if (validationError) {
104:         throw new Error(`Image validation failed: ${validationError.message}`);
105:       }
106: 
107:       imageCache.setBuffer(cacheKey, buffer);
108: 
109:       await logInfo("Successfully downloaded and validated image", {
110:         url,
111:         size: buffer.length,
112:         timestamp: new Date().toISOString(),
113:       });
114: 
115:       return buffer;
116:     } catch (error) {
117:       await logWarning("Failed to download or validate image", {
118:         url,
119:         error: error instanceof Error ? error.message : "Unknown error",
120:         timestamp: new Date().toISOString(),
121:       });
122:       throw error;
123:     }
124:   }
125: 
126:   private async shouldUpdateImage(
127:     options: ImagePathOptions,
128:     imageBuffer: Buffer
129:   ): Promise<boolean> {
130:     if (
131:       process.env.NODE_ENV === "test" ||
132:       process.env.FORCE_UPDATE === "true"
133:     ) {
134:       await logInfo("Force update enabled", {
135:         env: process.env.NODE_ENV,
136:         forceUpdate: process.env.FORCE_UPDATE,
137:         timestamp: new Date().toISOString(),
138:       });
139:       return true;
140:     }
141: 
142:     try {
143:       const storagePath = this.getStoragePath(options);
144:       const [fileExists] = await this.bucket.file(storagePath).exists();
145: 
146:       if (!fileExists) {
147:         await logInfo("Image does not exist in storage", {
148:           path: storagePath,
149:           timestamp: new Date().toISOString(),
150:         });
151:         return true;
152:       }
153: 
154:       const [metadata] = await this.bucket.file(storagePath).getMetadata();
155:       const currentHash = metadata.metadata?.hash;
156:       const newHash = await this.getImageHash(imageBuffer);
157: 
158:       await logInfo("Image hash comparison", {
159:         path: storagePath,
160:         currentHash,
161:         newHash,
162:         needsUpdate: currentHash !== newHash,
163:         timestamp: new Date().toISOString(),
164:       });
165: 
166:       return currentHash !== newHash;
167:     } catch (error) {
168:       await logWarning("Error checking image update status", {
169:         error: error instanceof Error ? error.message : "Unknown error",
170:         timestamp: new Date().toISOString(),
171:       });
172:       return true;
173:     }
174:   }
175: 
176:   private async saveToStorage(
177:     options: ImagePathOptions,
178:     buffer: Buffer,
179:     isHighRes: boolean
180:   ): Promise<string> {
181:     const storagePath = this.getStoragePath({
182:       ...options,
183:       isHighRes,
184:       isLowRes: !isHighRes,
185:     });
186: 
187:     const hash = await this.getImageHash(buffer);
188: 
189:     await logInfo(
190:       `Attempting to save ${isHighRes ? "high-res" : "low-res"} image`,
191:       {
192:         path: storagePath,
193:         size: buffer.length,
194:         hash,
195:         timestamp: new Date().toISOString(),
196:         metadata: {
197:           groupId: options.groupId,
198:           productId: options.productId,
199:           cardNumber: options.cardNumber,
200:         },
201:       }
202:     );
203: 
204:     await this.bucket.file(storagePath).save(buffer, {
205:       metadata: {
206:         contentType: "image/jpeg",
207:         metadata: {
208:           hash,
209:           type: isHighRes ? "highres" : "lowres",
210:           updatedAt: new Date().toISOString(),
211:         },
212:         cacheControl: "public, max-age=31536000",
213:       },
214:       public: true,
215:     });
216: 
217:     const [exists] = await this.bucket.file(storagePath).exists();
218:     const publicUrl = this.getPublicUrl(storagePath);
219: 
220:     await logInfo(
221:       `${isHighRes ? "High-res" : "Low-res"} image saved successfully`,
222:       {
223:         path: storagePath,
224:         size: buffer.length,
225:         hash,
226:         exists,
227:         publicUrl,
228:         timestamp: new Date().toISOString(),
229:       }
230:     );
231: 
232:     return publicUrl;
233:   }
234: 
235:   private async saveMetadata(
236:     options: ImagePathOptions,
237:     metadata: ImageMetadata
238:   ): Promise<void> {
239:     const sanitizedCardNumber = this.sanitizeCardNumber(options.cardNumber);
240: const docRef = db
241:   .collection(COLLECTION.IMAGE_METADATA)
242:   .doc(`${options.groupId}_${options.productId}_${sanitizedCardNumber}`);
243: 
244:     await docRef.set(
245:       {
246:         ...metadata,
247:         groupId: options.groupId,
248:         productId: options.productId,
249:         cardNumber: options.cardNumber, // Keep the original card number in the metadata
250:         sanitizedCardNumber, // Optionally store the sanitized version
251:         lastUpdated: new Date(),
252:       },
253:       { merge: true }
254:     );
255: 
256:     await logInfo("Saved image metadata", {
257:       groupId: options.groupId,
258:       productId: options.productId,
259:       cardNumber: options.cardNumber,
260:       sanitizedCardNumber,
261:       metadata,
262:       timestamp: new Date().toISOString(),
263:     });
264:   }
265: 
266:   async processImage(
267:     imageUrl: string,
268:     groupId: string,
269:     productId: number,
270:     cardNumber: string
271:   ): Promise<ImageProcessingResult> {
272:     const options: ImagePathOptions = {
273:       groupId,
274:       productId,
275:       cardNumber,
276:     };
277: 
278:     try {
279:       await logInfo("Starting image processing", {
280:         imageUrl,
281:         groupId,
282:         productId,
283:         cardNumber,
284:         timestamp: new Date().toISOString(),
285:       });
286: 
287:       const highResUrl = this.getHighResUrl(imageUrl);
288:       let highResBuffer: Buffer | null = null;
289:       let lowResBuffer: Buffer | null = null;
290:       let updated = false;
291:       let lowResStorageUrl = "";
292:       let highResStorageUrl = "";
293: 
294:       // Process low-res image
295:       try {
296:         await logInfo("Downloading low-res image", {
297:           url: imageUrl,
298:           timestamp: new Date().toISOString(),
299:         });
300: 
301:         lowResBuffer = await this.downloadImage(imageUrl);
302:         if (lowResBuffer) {
303:           await logInfo("Compressing low-res image", {
304:             originalSize: lowResBuffer.length,
305:             timestamp: new Date().toISOString(),
306:           });
307: 
308:           lowResBuffer = await this.compressImage(lowResBuffer, false);
309:           if (
310:             await this.shouldUpdateImage(
311:               { ...options, isLowRes: true },
312:               lowResBuffer
313:             )
314:           ) {
315:             lowResStorageUrl = await this.saveToStorage(
316:               options,
317:               lowResBuffer,
318:               false
319:             );
320:             updated = true;
321: 
322:             await logInfo("Low-res image updated", {
323:               url: lowResStorageUrl,
324:               size: lowResBuffer.length,
325:               timestamp: new Date().toISOString(),
326:             });
327:           } else {
328:             await logInfo("Low-res image unchanged", {
329:               timestamp: new Date().toISOString(),
330:             });
331:           }
332:         }
333:       } catch (error) {
334:         await logWarning("Low-res image processing failed", {
335:           productId,
336:           url: imageUrl,
337:           error: error instanceof Error ? error.message : "Unknown error",
338:           timestamp: new Date().toISOString(),
339:         });
340:       }
341: 
342:       // Process high-res image
343:       try {
344:         await logInfo("Downloading high-res image", {
345:           url: highResUrl,
346:           timestamp: new Date().toISOString(),
347:         });
348: 
349:         highResBuffer = await this.downloadImage(highResUrl);
350:         if (highResBuffer) {
351:           await logInfo("Compressing high-res image", {
352:             originalSize: highResBuffer.length,
353:             timestamp: new Date().toISOString(),
354:           });
355: 
356:           highResBuffer = await this.compressImage(highResBuffer, true);
357:           if (
358:             await this.shouldUpdateImage(
359:               { ...options, isHighRes: true },
360:               highResBuffer
361:             )
362:           ) {
363:             highResStorageUrl = await this.saveToStorage(
364:               options,
365:               highResBuffer,
366:               true
367:             );
368:             updated = true;
369: 
370:             await logInfo("High-res image updated", {
371:               url: highResStorageUrl,
372:               size: highResBuffer.length,
373:               timestamp: new Date().toISOString(),
374:             });
375:           } else {
376:             await logInfo("High-res image unchanged", {
377:               timestamp: new Date().toISOString(),
378:             });
379:           }
380:         }
381:       } catch (error) {
382:         await logWarning("High-res image processing failed", {
383:           productId,
384:           url: highResUrl,
385:           error: error instanceof Error ? error.message : "Unknown error",
386:           timestamp: new Date().toISOString(),
387:         });
388:       }
389: 
390:       // Set storage URLs if not generated
391:       if (!lowResStorageUrl) {
392:         lowResStorageUrl = this.getPublicUrl(
393:           this.getStoragePath({ ...options, isLowRes: true })
394:         );
395:       }
396:       if (!highResStorageUrl) {
397:         highResStorageUrl = this.getPublicUrl(
398:           this.getStoragePath({ ...options, isHighRes: true })
399:         );
400:       }
401: 
402:       const metadata: ImageMetadata = {
403:         contentType: "image/jpeg",
404:         size: lowResBuffer?.length || 0,
405:         updated: new Date(),
406:         hash: lowResBuffer ? await this.getImageHash(lowResBuffer) : "",
407:         highResSize: highResBuffer?.length,
408:         lowResSize: lowResBuffer?.length,
409:       };
410: 
411:       await this.saveMetadata(options, metadata);
412: 
413:       await logInfo("Image processing completed", {
414:         productId,
415:         groupId,
416:         updated,
417:         highResUrl: highResStorageUrl,
418:         lowResUrl: lowResStorageUrl,
419:         sizes: {
420:           highRes: highResBuffer?.length,
421:           lowRes: lowResBuffer?.length,
422:         },
423:         timestamp: new Date().toISOString(),
424:       });
425: 
426:       return {
427:         highResUrl: highResStorageUrl,
428:         lowResUrl: lowResStorageUrl,
429:         metadata,
430:         updated,
431:       };
432:     } catch (error) {
433:       const genericError: GenericError = {
434:         message: error instanceof Error ? error.message : "Unknown error",
435:         name: error instanceof Error ? error.name : "UnknownError",
436:         code: error instanceof AxiosError ? error.code : undefined,
437:         stack: error instanceof Error ? error.stack : undefined,
438:       };
439:       await logError(genericError, "processImage");
440:       return {
441:         highResUrl: "",
442:         lowResUrl: "",
443:         metadata: {
444:           contentType: "image/jpeg",
445:           size: 0,
446:           updated: new Date(),
447:           hash: "",
448:           highResSize: 0,
449:           lowResSize: 0,
450:         },
451:         updated: false,
452:       };
453:     }
454:   }
455: }
456: 
457: export const imageHandler = new ImageHandler();
</file>

<file path="src/utils/imageValidator.ts">
 1: import {ImageValidationError} from "../types";
 2: 
 3: export class ImageValidator {
 4:   private static readonly MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB
 5: 
 6:   static async validateImage(buffer: Buffer): Promise<ImageValidationError | null> {
 7:     try {
 8:       // Check file size
 9:       if (buffer.length > this.MAX_FILE_SIZE) {
10:         return {
11:           code: "FILE_TOO_LARGE",
12:           message: `Image exceeds maximum size of ${this.MAX_FILE_SIZE / 1024 / 1024}MB`,
13:         };
14:       }
15: 
16:       // Check file signature (magic numbers for JPEG)
17:       if (!this.isJpeg(buffer)) {
18:         return {
19:           code: "INVALID_FORMAT",
20:           message: "Image must be in JPEG format",
21:         };
22:       }
23: 
24:       return null;
25:     } catch (error) {
26:       return {
27:         code: "VALIDATION_ERROR",
28:         message: error instanceof Error ? error.message : "Unknown validation error",
29:       };
30:     }
31:   }
32: 
33:   private static isJpeg(buffer: Buffer): boolean {
34:     return (
35:       buffer[0] === 0xFF &&
36:       buffer[1] === 0xD8 &&
37:       buffer[buffer.length - 2] === 0xFF &&
38:       buffer[buffer.length - 1] === 0xD9
39:     );
40:   }
41: }
</file>

<file path="src/utils/logger.ts">
 1: import * as functions from "firebase-functions";
 2: import {db, COLLECTION} from "../config/firebase";
 3: import {GenericError, LogData, GenericObject} from "../types";
 4: 
 5: export const logger = functions.logger;
 6: 
 7: interface LogEntry {
 8:   timestamp: Date;
 9:   level: "INFO" | "WARNING" | "ERROR";
10:   message: string;
11:   context?: string;
12:   data?: Record<string, unknown>;
13: }
14: 
15: function cleanLogData(data: Record<string, unknown>): Record<string, unknown> {
16:   return Object.entries(data).reduce((acc, [key, value]) => {
17:     // Skip undefined and null values
18:     if (value !== undefined && value !== null) {
19:       if (value && typeof value === "object") {
20:         const cleaned = cleanLogData(value as Record<string, unknown>);
21:         // Only add non-empty objects
22:         if (Object.keys(cleaned).length > 0) {
23:           acc[key] = cleaned;
24:         }
25:       } else {
26:         // Convert any specialized types to plain values
27:         acc[key] = value instanceof Date ? value.toISOString() : value;
28:       }
29:     }
30:     return acc;
31:   }, {} as Record<string, unknown>);
32: }
33: 
34: async function saveLogEntry(entry: LogEntry): Promise<void> {
35:   const cleanEntry = {
36:     timestamp: entry.timestamp,
37:     level: entry.level,
38:     message: entry.message,
39:     ...(entry.context && {context: entry.context}),
40:     ...(entry.data && {data: cleanLogData(entry.data)}),
41:   };
42: 
43:   await db.collection(COLLECTION.LOGS).add(cleanEntry);
44: }
45: 
46: export const logError = async (error: GenericError | GenericObject, context: string) => {
47:   const errorData = cleanLogData({
48:     stack: error.stack,
49:     code: error.code,
50:     ...(error as GenericObject),
51:     timestamp: new Date().toISOString(),
52:   });
53: 
54:   const entry: LogEntry = {
55:     timestamp: new Date(),
56:     level: "ERROR",
57:     message: error.message || "Unknown error",
58:     context,
59:     data: errorData,
60:   };
61: 
62:   logger.error(entry.message, errorData);
63:   await saveLogEntry(entry);
64: };
65: 
66: export const logInfo = async (message: string, data?: LogData) => {
67:   const cleanedData = data ? cleanLogData({
68:     ...data,
69:     timestamp: new Date().toISOString(),
70:   }) : undefined;
71: 
72:   const entry: LogEntry = {
73:     timestamp: new Date(),
74:     level: "INFO",
75:     message,
76:     ...(cleanedData && Object.keys(cleanedData).length > 0 && {data: cleanedData}),
77:   };
78: 
79:   logger.info(message, cleanedData);
80:   await saveLogEntry(entry);
81: };
82: 
83: export const logWarning = async (message: string, data?: LogData) => {
84:   const cleanedData = data ? cleanLogData({
85:     ...data,
86:     timestamp: new Date().toISOString(),
87:   }) : undefined;
88: 
89:   const entry: LogEntry = {
90:     timestamp: new Date(),
91:     level: "WARNING",
92:     message,
93:     ...(cleanedData && Object.keys(cleanedData).length > 0 && {data: cleanedData}),
94:   };
95: 
96:   logger.warn(message, cleanedData);
97:   await saveLogEntry(entry);
98: };
</file>

<file path="src/utils/progress.ts">
 1: // src/utils/progress.ts
 2: 
 3: import {logInfo} from "./logger";
 4: 
 5: export interface ProgressStats {
 6:   current: number;
 7:   total: number;
 8:   percent: number;
 9:   elapsed: number;
10:   rate: number;
11:   remaining: number;
12:   eta: number;
13: }
14: 
15: export class EnhancedProgressTracker {
16:   private startTime: number;
17:   private current: number;
18:   private estimates: number[] = [];
19:   private lastUpdate: number;
20:   private updateInterval: number;
21: 
22:   constructor(
23:     private total: number,
24:     private description: string,
25:     options: { updateInterval?: number } = {}
26:   ) {
27:     this.startTime = Date.now();
28:     this.current = 0;
29:     this.lastUpdate = Date.now();
30:     this.updateInterval = options.updateInterval || 1000; // Default 1 second
31:   }
32: 
33:   private calculateStats(): ProgressStats {
34:     const now = Date.now();
35:     const elapsed = (now - this.startTime) / 1000;
36:     const percent = (this.current / this.total) * 100;
37:     const rate = this.current / elapsed;
38:     const remaining = this.total - this.current;
39:     const eta = remaining / rate;
40: 
41:     return {
42:       current: this.current,
43:       total: this.total,
44:       percent,
45:       elapsed,
46:       rate,
47:       remaining,
48:       eta,
49:     };
50:   }
51: 
52:   update(amount = 1): void {
53:     const now = Date.now();
54:     this.current += amount;
55: 
56:     // Only update log if enough time has passed
57:     if (now - this.lastUpdate >= this.updateInterval) {
58:       const stats = this.calculateStats();
59:       this.estimates.push(stats.eta);
60: 
61:       // Keep only last 10 estimates for averaging
62:       if (this.estimates.length > 10) {
63:         this.estimates.shift();
64:       }
65: 
66:       const avgEta = this.estimates.reduce((a, b) => a + b, 0) / this.estimates.length;
67: 
68:       logInfo(
69:         `${this.description}: ${stats.current}/${stats.total} ` +
70:         `(${stats.percent.toFixed(1)}%) - ${stats.remaining} remaining - ` +
71:         `ETA: ${avgEta.toFixed(1)}s - Rate: ${stats.rate.toFixed(1)}/s`
72:       );
73: 
74:       this.lastUpdate = now;
75:     }
76:   }
77: 
78:   getProgress(): ProgressStats {
79:     return this.calculateStats();
80:   }
81: }
</file>

<file path="src/utils/syncLogger.ts">
  1: interface CardDetails {
  2:   id: number;
  3:   name: string;
  4:   groupId: string;
  5:   cardNumber: string;
  6:   normalPrice?: number;
  7:   foilPrice?: number;
  8:   rawPrices: Array<{
  9:     type: string;
 10:     price: number;
 11:     groupId: string;
 12:   }>;
 13:   highResUrl?: string;
 14:   lowResUrl?: string;
 15: }
 16: 
 17: interface SyncLoggerOptions {
 18:   type: "manual" | "scheduled" | "both";
 19:   limit?: number;
 20:   dryRun?: boolean;
 21:   groupId?: string;
 22:   batchSize?: number;
 23: }
 24: 
 25: interface SyncResults {
 26:   success: number;
 27:   failures: number;
 28:   groupId?: string;
 29:   type: string;
 30:   imagesProcessed?: number;
 31:   imagesUpdated?: number;
 32: }
 33: 
 34: export class SyncLogger {
 35:   private startTime: number;
 36:   private cards: CardDetails[] = [];
 37:   private groups: Map<string, { products: number; prices: number }> = new Map();
 38: 
 39:   constructor(private options: SyncLoggerOptions) {
 40:     this.startTime = Date.now();
 41:   }
 42: 
 43:   async start(): Promise<void> {
 44:     console.log("\nStarting sync operation...");
 45:     console.log(`Type: ${this.options.type}`);
 46:     if (this.options.limit) console.log(`Limit: ${this.options.limit} cards`);
 47:     if (this.options.groupId) console.log(`Group ID: ${this.options.groupId}`);
 48:     console.log(`Dry Run: ${this.options.dryRun ? "Yes" : "No"}`);
 49:     console.log("\n=== Processing Data ===");
 50:   }
 51: 
 52:   async logGroupFound(totalGroups: number): Promise<void> {
 53:     if (this.options.groupId) {
 54:       console.log(`Processing group ${this.options.groupId}`);
 55:     } else {
 56:       console.log(`Found ${totalGroups} groups to process`);
 57:     }
 58:   }
 59: 
 60:   async logGroupDetails(
 61:     groupId: string,
 62:     products: number,
 63:     prices: number
 64:   ): Promise<void> {
 65:     if (!this.options.groupId || this.options.groupId === groupId) {
 66:       this.groups.set(groupId, { products, prices });
 67:       console.log(`Group ${groupId}: ${products} products, ${prices} prices`);
 68:     }
 69:   }
 70: 
 71:   async logCardDetails(details: CardDetails): Promise<void> {
 72:     if (!this.options.groupId || this.options.groupId === details.groupId) {
 73:       this.cards.push(details);
 74:       if (this.cards.length === 1) {
 75:         console.log("\n=== Card Details ===");
 76:       }
 77: 
 78:       console.log(`\nCard: ${details.name}`);
 79:       console.log(`ID: ${details.id}`);
 80:       if (details.cardNumber) console.log(`Number: ${details.cardNumber}`);
 81:       console.log(`Group: ${details.groupId}`);
 82: 
 83:       if (details.rawPrices.length > 0) {
 84:         console.log("Prices:");
 85:         details.rawPrices.forEach((price) => {
 86:           console.log(`  ${price.type}: $${price.price.toFixed(2)}`);
 87:         });
 88:       }
 89: 
 90:       if (details.highResUrl || details.lowResUrl) {
 91:         console.log("Images:");
 92:         if (details.highResUrl) {
 93:           console.log(`  High Res: ${details.highResUrl}`);
 94:         }
 95:         if (details.lowResUrl) {
 96:           console.log(`  Low Res: ${details.lowResUrl}`);
 97:         }
 98:       }
 99:     }
100:   }
101: 
102:   async logManualSyncStart(): Promise<void> {
103:     console.log("\n=== Starting Manual Sync ===");
104:     if (this.options.groupId) {
105:       console.log(`Filtering for group: ${this.options.groupId}`);
106:     }
107:     if (this.options.dryRun) {
108:       console.log("DRY RUN MODE - No data will be modified");
109:     }
110:     if (this.options.limit) {
111:       console.log(`Limited to ${this.options.limit} cards`);
112:     }
113:     if (this.options.batchSize) {
114:       console.log(`Batch size: ${this.options.batchSize}`);
115:     }
116:     console.log();
117:   }
118: 
119:   async logSyncResults(results: SyncResults): Promise<void> {
120:     const duration = (Date.now() - this.startTime) / 1000;
121: 
122:     console.log("\n=== Sync Results ===");
123:     console.log(`Operation: ${results.type}`);
124:     if (results.groupId) {
125:       console.log(`Group: ${results.groupId}`);
126:     }
127:     console.log(`Duration: ${duration.toFixed(1)} seconds`);
128:     console.log(`Successful Operations: ${results.success}`);
129:     console.log(`Failed Operations: ${results.failures}`);
130: 
131:     if (typeof results.imagesProcessed === "number") {
132:       console.log("\nImage Processing:");
133:       console.log(`Total Processed: ${results.imagesProcessed}`);
134:       console.log(`Updated: ${results.imagesUpdated || 0}`);
135:       console.log(
136:         `Unchanged: ${results.imagesProcessed - (results.imagesUpdated || 0)}`
137:       );
138:     }
139: 
140:     if (this.cards.length > 0) {
141:       console.log(`\nProcessed Cards: ${this.cards.length}`);
142:       const withImages = this.cards.filter(
143:         (card) => card.highResUrl || card.lowResUrl
144:       ).length;
145:       console.log(`Cards with Images: ${withImages}`);
146:       console.log(`Cards without Images: ${this.cards.length - withImages}`);
147:     }
148:   }
149: 
150:   async finish(): Promise<void> {
151:     const totalDuration = (Date.now() - this.startTime) / 1000;
152:     console.log("\n=== Operation Complete ===");
153:     console.log(`Total Duration: ${totalDuration.toFixed(1)} seconds`);
154: 
155:     if (this.options.dryRun) {
156:       console.log("\nThis was a dry run - no changes were made");
157:       console.log("Remove --dry-run flag to perform actual updates");
158:     }
159:   }
160: }
</file>

<file path="src/utils/syncUtils.ts">
 1: import axios, {AxiosError} from "axios";
 2: import {logWarning} from "./logger";
 3: import {BatchProcessingStats} from "../types";
 4: 
 5: export const MAX_RETRIES = 3;
 6: export const BASE_DELAY = 1000;
 7: 
 8: export interface RequestOptions {
 9:   retryCount?: number;
10:   customDelay?: number;
11:   metadata?: Record<string, unknown>;
12: }
13: 
14: export function sanitizeDocumentId(productId: number | string, cardNumber: string): string {
15:   const sanitizedCardNumber = cardNumber.replace(/\//g, "_");
16:   return `${productId}_${sanitizedCardNumber}`;
17: }
18: 
19: export async function makeRequest<T>(
20:   endpoint: string,
21:   baseUrl: string,
22:   options: RequestOptions = {}
23: ): Promise<T> {
24:   const {retryCount = 0, customDelay = BASE_DELAY} = options;
25: 
26:   try {
27:     await new Promise((resolve) => setTimeout(resolve, customDelay));
28:     const url = `${baseUrl}/${endpoint}`;
29:     const response = await axios.get<T>(url, {
30:       timeout: 30000,
31:       headers: {
32:         "Accept": "application/json",
33:         "User-Agent": "FFTCG-Sync-Service/1.0",
34:       },
35:     });
36: 
37:     return response.data;
38:   } catch (error) {
39:     if (retryCount < MAX_RETRIES - 1 && error instanceof AxiosError) {
40:       const delay = Math.pow(2, retryCount) * BASE_DELAY;
41:       await logWarning(`Request failed, retrying in ${delay}ms...`, {
42:         url: `${baseUrl}/${endpoint}`,
43:         attempt: retryCount + 1,
44:         maxRetries: MAX_RETRIES,
45:         error: error.message,
46:         ...options.metadata,
47:       });
48: 
49:       return makeRequest<T>(endpoint, baseUrl, {
50:         ...options,
51:         retryCount: retryCount + 1,
52:         customDelay: delay,
53:       });
54:     }
55:     throw error;
56:   }
57: }
58: 
59: export interface BatchOptions {
60:   batchSize?: number;
61:   onBatchComplete?: (stats: BatchProcessingStats) => Promise<void>;
62: }
63: 
64: export async function processBatch<T>(
65:   items: T[],
66:   processor: (batch: T[]) => Promise<void>,
67:   options: BatchOptions = {}
68: ): Promise<void> {
69:   const {batchSize = 500, onBatchComplete} = options;
70: 
71:   let processedCount = 0;
72:   const totalBatches = Math.ceil(items.length / batchSize);
73: 
74:   for (let i = 0; i < items.length; i += batchSize) {
75:     const batch = items.slice(i, i + batchSize);
76:     const currentBatch = Math.floor(i / batchSize) + 1;
77: 
78:     await processor(batch);
79:     processedCount += batch.length;
80: 
81:     if (onBatchComplete) {
82:       await onBatchComplete({
83:         total: items.length,
84:         processed: processedCount,
85:         successful: processedCount,
86:         failed: 0,
87:         skipped: 0,
88:       });
89:     }
90: 
91:     console.log(
92:       `Processing batch ${currentBatch}/${totalBatches} (${processedCount}/${items.length} items)`
93:     );
94: 
95:     if (i + batchSize < items.length) {
96:       await new Promise((resolve) => setTimeout(resolve, 100));
97:     }
98:   }
99: }
</file>

<file path="tsconfig.dev.json">
1: {
2:   "extends": "./tsconfig.json",
3:   "include": [
4:     ".eslintrc.js",
5:     ".eslintrc.fix.js",
6:     ".eslintrc.base.cjs"
7:   ]
8: }
</file>

<file path="tsconfig.json">
 1: {
 2:   "compilerOptions": {
 3:     "module": "commonjs",
 4:     "noImplicitReturns": true,
 5:     "noUnusedLocals": true,
 6:     "outDir": "lib",
 7:     "sourceMap": true,
 8:     "strict": true,
 9:     "target": "es2017",
10:     "esModuleInterop": true,
11:     "skipLibCheck": true,
12:     "types": ["node", "express"],
13:     "baseUrl": "./src",
14:     "lib": ["es2017", "dom"],
15:     "typeRoots": [
16:       "./node_modules/@types",
17:       "./src/types"
18:     ]
19:   },
20:   "compileOnSave": true,
21:   "include": [
22:     "src/**/*",
23:     ".eslintrc.js",
24:     ".eslintrc.fix.js",
25:     ".eslintrc.base.cjs"
26:   ],
27:   "exclude": [
28:     "node_modules",
29:     "lib"
30:   ]
31: }
</file>

</repository_files>
