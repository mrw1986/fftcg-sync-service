This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-31T21:48:39.541Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

- Line numbers have been added to the beginning of each line.
</notes>

<additional_info>

For more information about Repomix, visit: https://github.com/yamadashy/repomix
</additional_info>

</file_summary>

<repository_structure>
.eslintignore
.eslintrc.base.cjs
.eslintrc.fix.js
.eslintrc.js
package.json
src/config/firebase.ts
src/config/r2.ts
src/index.ts
src/services/cardSync.ts
src/services/priceSync.ts
src/services/r2Storage.ts
src/test/testEndpoints.ts
src/test/testImageHandler.ts
src/test/testSync.ts
src/test/validateSync.ts
src/test/verifyMigration.ts
src/types/index.ts
src/utils/backup.ts
src/utils/cache.ts
src/utils/databaseBackup.ts
src/utils/databaseCleanup.ts
src/utils/databaseMigration.ts
src/utils/databaseRefresh.ts
src/utils/databaseReset.ts
src/utils/error.ts
src/utils/imageAccessibilityChecker.ts
src/utils/imageCache.ts
src/utils/imageCompressor.ts
src/utils/imageHandler.ts
src/utils/imageValidator.ts
src/utils/logger.ts
src/utils/progress.ts
src/utils/syncLogger.ts
src/utils/syncUtils.ts
tsconfig.dev.json
tsconfig.json
</repository_structure>

<repository_files>
This section contains the contents of the repository's files.

<file path=".eslintignore">
1: node_modules/
2: lib/
3: coverage/
4: *.d.ts
5: *.cjs
</file>

<file path=".eslintrc.base.cjs">
1: module.exports = {
2:     rules: {
3:       "valid-jsdoc": "off",
4:       "require-jsdoc": "off"
5:     }
6:   };
</file>

<file path=".eslintrc.fix.js">
 1: module.exports = {
 2:   extends: "./.eslintrc.js",
 3:   rules: {
 4:     "max-len": ["error", {"code": 120}],
 5:     "valid-jsdoc": 0,
 6:     "require-jsdoc": 0,
 7:     "@typescript-eslint/no-explicit-any": 0,
 8:     "@typescript-eslint/explicit-function-return-type": 0,
 9:     "@typescript-eslint/explicit-module-boundary-types": 0,
10:     "@typescript-eslint/no-unused-vars": ["error", {
11:       "argsIgnorePattern": "^_",
12:       "varsIgnorePattern": "^_",
13:     }],
14:     // Add these additional rules to be extra sure
15:     "jsdoc/require-jsdoc": 0,
16:     "jsdoc/valid-jsdoc": 0,
17:     "jsdoc/require-param-type": 0,
18:     "jsdoc/require-returns": 0,
19:   },
20: };
</file>

<file path=".eslintrc.js">
 1: module.exports = {
 2:   root: true,
 3:   env: {
 4:     es6: true,
 5:     node: true,
 6:   },
 7:   extends: [
 8:     "eslint:recommended",
 9:     "plugin:import/errors",
10:     "plugin:import/warnings",
11:     "plugin:import/typescript",
12:     "google",
13:     "plugin:@typescript-eslint/recommended",
14:   ],
15:   parser: "@typescript-eslint/parser",
16:   parserOptions: {
17:     project: ["tsconfig.json", "tsconfig.dev.json"],
18:     tsconfigRootDir: __dirname,
19:     sourceType: "module",
20:     createDefaultProgram: true,
21:   },
22:   ignorePatterns: [
23:     "/lib/**/*",
24:     "/generated/**/*",
25:     "node_modules/",
26:     "*.cjs",
27:   ],
28:   plugins: [
29:     "@typescript-eslint",
30:     "import",
31:   ],
32:   rules: {
33:     "quotes": ["error", "double"],
34:     "import/no-unresolved": 0,
35:     "indent": ["error", 2],
36:     "max-len": ["error", {"code": 120}],
37:     "@typescript-eslint/no-explicit-any": "off",
38:     "@typescript-eslint/no-unused-vars": ["error", {
39:       "argsIgnorePattern": "^_",
40:       "varsIgnorePattern": "^_",
41:     }],
42:     "valid-jsdoc": 0,
43:     "require-jsdoc": 0,
44:   },
45:   overrides: [
46:     {
47:       files: ["*.js", "*.cjs"],
48:       rules: {
49:         "@typescript-eslint/no-var-requires": "off",
50:       },
51:     },
52:   ],
53: };
</file>

<file path="package.json">
 1: {
 2:   "name": "functions",
 3:   "scripts": {
 4:     "clean": "rimraf lib",
 5:     "lint": "eslint --ext .js,.ts .",
 6:     "lint:fix": "eslint --ext .js,.ts . --fix",
 7:     "build": "npm run clean && tsc",
 8:     "build:watch": "tsc --watch",
 9:     "serve": "npm run build && firebase emulators:start --only functions,firestore,storage",
10:     "shell": "npm run build && firebase functions:shell",
11:     "start": "npm run shell",
12:     "deploy": "npm run lint:fix && firebase deploy --only functions",
13:     "logs": "firebase functions:log",
14:     "lint:fix:force": "eslint . --ext .js,.ts --fix --config .eslintrc.fix.js",
15:     "test:images": "ts-node src/test/testImageHandler.ts",
16:     "test:sync": "ts-node src/test/testSync.ts",
17:     "test:all": "npm run test:images && npm run test:sync",
18:     "backup-db": "ts-node src/utils/databaseBackup.ts",
19:     "clear-db": "ts-node src/utils/databaseReset.ts",
20:     "sync:data": "ts-node src/utils/databaseRefresh.ts --skip-images",
21:     "sync:data:force": "ts-node src/utils/databaseRefresh.ts --skip-images --force",
22:     "sync:data:dry": "ts-node src/utils/databaseRefresh.ts --skip-images --dry-run",
23:     "sync:data:verbose": "ts-node src/utils/databaseRefresh.ts --skip-images --verbose",
24:     "sync:images": "ts-node src/utils/databaseRefresh.ts --images-only",
25:     "sync:images:force": "ts-node src/utils/databaseRefresh.ts --images-only --force",
26:     "sync:images:dry": "ts-node src/utils/databaseRefresh.ts --images-only --dry-run",
27:     "sync:images:verbose": "ts-node src/utils/databaseRefresh.ts --images-only --verbose",
28:     "sync:full": "ts-node src/utils/databaseRefresh.ts",
29:     "sync:full:force": "ts-node src/utils/databaseRefresh.ts --force",
30:     "sync:full:dry": "ts-node src/utils/databaseRefresh.ts --dry-run",
31:     "sync:full:verbose": "ts-node src/utils/databaseRefresh.ts --verbose",
32:     "sync:group": "ts-node src/utils/databaseRefresh.ts --group-id",
33:     "sync:group:images": "ts-node src/utils/databaseRefresh.ts --group-id --images-only",
34:     "sync:group:data": "ts-node src/utils/databaseRefresh.ts --group-id --skip-images",
35:     "cleanup:images": "ts-node src/utils/databaseCleanup.ts",
36:     "migrate:images": "ts-node src/utils/databaseMigration.ts",
37:     "migrate:images:dry": "ts-node src/utils/databaseMigration.ts --dry-run",
38:     "migrate:images:test": "ts-node src/utils/databaseMigration.ts --dry-run --limit 5",
39:     "migrate:images:group": "ts-node src/utils/databaseMigration.ts --group-id",
40:     "verify:migration": "ts-node src/test/verifyMigration.ts",
41:     "verify:migration:group": "ts-node src/test/verifyMigration.ts --group-id",
42:     "verify:migration:test": "ts-node src/test/verifyMigration.ts --limit 5"
43:   },
44:   "engines": {
45:     "node": "18"
46:   },
47:   "main": "lib/index.js",
48:   "dependencies": {
49:     "@aws-sdk/client-s3": "^3.485.0",
50:     "@aws-sdk/s3-request-presigner": "^3.485.0",
51:     "axios": "^1.7.7",
52:     "cors": "^2.8.5",
53:     "dotenv": "^16.4.7",
54:     "firebase-admin": "^12.0.0",
55:     "firebase-functions": "^6.2.0",
56:     "lru-cache": "^7.14.1",
57:     "refresh-db": "ts-node src/utils/databaseRefresh.ts",
58:     "sharp": "^0.33.1"
59:   },
60:   "devDependencies": {
61:     "@types/cors": "^2.8.17",
62:     "@types/express": "^4.17.21",
63:     "@types/node": "^18.19.64",
64:     "@typescript-eslint/eslint-plugin": "^6.0.0",
65:     "@typescript-eslint/parser": "^6.0.0",
66:     "eslint": "^8.0.0",
67:     "eslint-config-google": "^0.14.0",
68:     "eslint-plugin-import": "^2.25.4",
69:     "firebase-functions-test": "^3.1.0",
70:     "rimraf": "^5.0.0",
71:     "typescript": "^4.9.5"
72:   },
73:   "private": true
74: }
</file>

<file path="src/config/firebase.ts">
 1: // functions/src/config/firebase.ts
 2: 
 3: import * as admin from "firebase-admin";
 4: 
 5: const app = !admin.apps.length ? admin.initializeApp() : admin.app();
 6: const db = admin.firestore(app);
 7: 
 8: // Enable ignoreUndefinedProperties and other settings
 9: db.settings({
10:   ignoreUndefinedProperties: true,
11:   timestampsInSnapshots: true,
12: });
13: 
14: export {db};
15: 
16: export const COLLECTION = {
17:   CARDS: "cards",
18:   PRICES: "prices",
19:   SYNC_METADATA: "syncMetadata",
20:   LOGS: "logs",
21:   CARD_HASHES: "cardHashes",
22:   PRICE_HASHES: "priceHashes",
23:   IMAGE_METADATA: "imageMetadata",
24: };
25: 
26: export const BASE_URL = "https://tcgcsv.com/tcgplayer";
27: export const FFTCG_CATEGORY_ID = "24";
28: 
29: export const runtimeOpts = {
30:   timeoutSeconds: 540,
31:   memory: "1GiB",
32: } as const;
</file>

<file path="src/config/r2.ts">
 1: // src/config/r2.ts
 2: 
 3: import * as dotenv from "dotenv";
 4: dotenv.config();
 5: 
 6: export const R2_CONFIG = {
 7:   ACCOUNT_ID: process.env.R2_ACCOUNT_ID || "",
 8:   ACCESS_KEY_ID: process.env.R2_ACCESS_KEY_ID || "",
 9:   SECRET_ACCESS_KEY: process.env.R2_SECRET_ACCESS_KEY || "",
10:   BUCKET_NAME: process.env.R2_BUCKET_NAME || "",
11:   STORAGE_PATH: process.env.R2_STORAGE_PATH || "",
12:   CUSTOM_DOMAIN: process.env.R2_CUSTOM_DOMAIN || "",
13: } as const;
14: 
15: if (!R2_CONFIG.ACCOUNT_ID) {
16:   console.warn("Missing R2_ACCOUNT_ID in .env file");
17: }
18: if (!R2_CONFIG.ACCESS_KEY_ID) {
19:   console.warn("Missing R2_ACCESS_KEY_ID in .env file");
20: }
21: if (!R2_CONFIG.SECRET_ACCESS_KEY) {
22:   console.warn("Missing R2_SECRET_ACCESS_KEY in .env file");
23: }
24: if (!R2_CONFIG.BUCKET_NAME) {
25:   console.warn("Missing R2_BUCKET_NAME in .env file");
26: }
27: if (!R2_CONFIG.STORAGE_PATH) {
28:   console.warn("Missing R2_STORAGE_PATH in .env file");
29: }
30: if (!R2_CONFIG.CUSTOM_DOMAIN) {
31:   console.warn("Missing R2_CUSTOM_DOMAIN in .env file");
32: }
33: 
34: console.log("R2 Config:", R2_CONFIG);
</file>

<file path="src/index.ts">
  1: // src/index.ts
  2: 
  3: import {onRequest} from "firebase-functions/v2/https";
  4: import {onSchedule} from "firebase-functions/v2/scheduler";
  5: import {Request, Response} from "express";
  6: import {syncCards} from "./services/cardSync";
  7: import {syncPrices} from "./services/priceSync";
  8: import {runtimeOpts} from "./config/firebase";
  9: import {SyncOptions} from "./types";
 10: import cors = require("cors");
 11: import * as dotenv from "dotenv";
 12: dotenv.config();
 13: 
 14: // Initialize CORS middleware with appropriate typing
 15: const corsMiddleware = cors({
 16:   origin: true,
 17:   methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
 18:   allowedHeaders: ["Content-Type", "Authorization"],
 19:   credentials: true,
 20: });
 21: 
 22: // Wrap async function with CORS and error handling
 23: const withCorsAndErrors = (
 24:   handler: (req: Request, res: Response) => Promise<void>
 25: ) => {
 26:   return async (req: Request, res: Response): Promise<void> => {
 27:     // Handle CORS preflight requests
 28:     if (req.method === "OPTIONS") {
 29:       return new Promise((resolve) => {
 30:         corsMiddleware(req, res, () => {
 31:           res.status(204).send("");
 32:           resolve();
 33:         });
 34:       });
 35:     }
 36: 
 37:     // Handle actual request with CORS
 38:     return new Promise((resolve, reject) => {
 39:       corsMiddleware(req, res, async () => {
 40:         try {
 41:           await handler(req, res);
 42:           resolve();
 43:         } catch (error) {
 44:           console.error("Function error:", error);
 45:           res.status(500).json({
 46:             error:
 47:               error instanceof Error ? error.message : "Internal server error",
 48:             timestamp: new Date().toISOString(),
 49:           });
 50:           reject(error);
 51:         }
 52:       });
 53:     });
 54:   };
 55: };
 56: 
 57: export const scheduledCardSync = onSchedule(
 58:   {
 59:     schedule: "0 21 * * *", // Daily at 21:00 UTC
 60:     timeZone: "UTC",
 61:     memory: runtimeOpts.memory,
 62:     timeoutSeconds: runtimeOpts.timeoutSeconds,
 63:     retryCount: 3,
 64:   },
 65:   async (_context) => {
 66:     await syncCards();
 67:   }
 68: );
 69: 
 70: export const testCardSync = onRequest(
 71:   {
 72:     timeoutSeconds: runtimeOpts.timeoutSeconds,
 73:     memory: runtimeOpts.memory,
 74:     maxInstances: 1,
 75:   },
 76:   withCorsAndErrors(async (req: Request, res: Response): Promise<void> => {
 77:     const options: SyncOptions = {
 78:       dryRun: req.query.dryRun !== "false", // default to true
 79:       limit: req.query.limit ? parseInt(req.query.limit as string) : 5,
 80:       groupId: req.query.groupId as string,
 81:     };
 82: 
 83:     const result = await syncCards(options);
 84:     res.json(result);
 85:   })
 86: );
 87: 
 88: export const manualCardSync = onRequest(
 89:   {
 90:     timeoutSeconds: runtimeOpts.timeoutSeconds,
 91:     memory: runtimeOpts.memory,
 92:     maxInstances: 1,
 93:   },
 94:   withCorsAndErrors(async (_req: Request, res: Response): Promise<void> => {
 95:     const result = await syncCards({dryRun: false});
 96:     res.json(result);
 97:   })
 98: );
 99: 
100: export const scheduledPriceSync = onSchedule(
101:   {
102:     schedule: "30 21 * * *", // Daily at 21:30 UTC
103:     timeZone: "UTC",
104:     memory: runtimeOpts.memory,
105:     timeoutSeconds: runtimeOpts.timeoutSeconds,
106:     retryCount: 3,
107:   },
108:   async (_context) => {
109:     await syncPrices();
110:   }
111: );
112: 
113: export const testPriceSync = onRequest(
114:   {
115:     timeoutSeconds: runtimeOpts.timeoutSeconds,
116:     memory: runtimeOpts.memory,
117:     maxInstances: 1,
118:   },
119:   withCorsAndErrors(async (req: Request, res: Response): Promise<void> => {
120:     const options: SyncOptions = {
121:       dryRun: req.query.dryRun === "true",
122:       limit: req.query.limit ? parseInt(req.query.limit as string) : undefined,
123:       groupId: req.query.groupId as string,
124:       productId: req.query.productId ?
125:         parseInt(req.query.productId as string) :
126:         undefined,
127:       showAll: req.query.showAll === "true",
128:     };
129: 
130:     const result = await syncPrices(options);
131:     res.json(result);
132:   })
133: );
134: 
135: export const manualPriceSync = onRequest(
136:   {
137:     timeoutSeconds: runtimeOpts.timeoutSeconds,
138:     memory: runtimeOpts.memory,
139:     maxInstances: 1,
140:   },
141:   withCorsAndErrors(async (_req: Request, res: Response): Promise<void> => {
142:     const result = await syncPrices();
143:     res.json(result);
144:   })
145: );
146: 
147: export const healthCheck = onRequest(
148:   {
149:     timeoutSeconds: 10,
150:     memory: "128MiB",
151:   },
152:   withCorsAndErrors(async (_req: Request, res: Response): Promise<void> => {
153:     res.json({
154:       status: "healthy",
155:       timestamp: new Date().toISOString(),
156:       version: "1.0.0",
157:     });
158:   })
159: );
</file>

<file path="src/services/cardSync.ts">
  1: import {
  2:   constructTCGCSVPath,
  3:   makeRequest,
  4:   validateAndFixDocumentId,
  5: } from "../utils/syncUtils";
  6: import {db, COLLECTION} from "../config/firebase";
  7: import {
  8:   CardProduct,
  9:   SyncOptions,
 10:   SyncMetadata,
 11:   GenericError,
 12:   GenericObject,
 13: } from "../types";
 14: import {logInfo, logError} from "../utils/logger";
 15: 
 16: /**
 17:  * Fetch products for a specific group.
 18:  */
 19: async function fetchProductsForGroup(groupId: string): Promise<CardProduct[]> {
 20:   const endpoint = `/${COLLECTION.CARDS}/${groupId}/products`;
 21:   const productsResponse = await makeRequest<{ results: CardProduct[] }>(
 22:     constructTCGCSVPath(endpoint)
 23:   );
 24:   logInfo("Fetched products for group", {
 25:     groupId,
 26:     count: productsResponse.results.length,
 27:   });
 28:   return productsResponse.results;
 29: }
 30: 
 31: /**
 32:  * Generate a document ID for a product.
 33:  */
 34: function getDocumentId(product: CardProduct): string {
 35:   const cardNumber = getCardNumber(product);
 36:   return validateAndFixDocumentId(product.productId, cardNumber);
 37: }
 38: 
 39: /**
 40:  * Extract card number from a product.
 41:  */
 42: function getCardNumber(product: CardProduct): string {
 43:   const numberField = product.extendedData.find(
 44:     (data) => data.name === "Number"
 45:   );
 46:   if (!numberField) {
 47:     throw new Error(`Missing card number for productId: ${product.productId}`);
 48:   }
 49:   return numberField.value;
 50: }
 51: 
 52: /**
 53:  * Handle promo cards to ensure proper document ID generation.
 54:  */
 55: function getPromoDocumentId(product: CardProduct): string {
 56:   const extNumber = product.extendedData.find(
 57:     (data) => data.name === "extNumber"
 58:   );
 59:   if (!extNumber) {
 60:     throw new Error(
 61:       `Missing extNumber for promo productId: ${product.productId}`
 62:     );
 63:   }
 64: 
 65:   const [promoCardNumber] = extNumber.value.split("/");
 66:   return validateAndFixDocumentId(product.productId, promoCardNumber);
 67: }
 68: 
 69: /**
 70:  * Main function to sync cards.
 71:  */
 72: export async function syncCards(
 73:   options: SyncOptions = {}
 74: ): Promise<SyncMetadata> {
 75:   const metadata: SyncMetadata = {
 76:     lastSync: new Date(),
 77:     status: "in_progress",
 78:     cardCount: 0,
 79:     type: options.dryRun ? "manual" : "scheduled",
 80:     groupsProcessed: 0,
 81:     groupsUpdated: 0,
 82:     errors: [],
 83:   };
 84: 
 85:   logInfo("Starting card sync", {options});
 86: 
 87:   try {
 88:     const groups = await fetchProductsForGroup(options.groupId || "");
 89:     const writeBatch = db.batch();
 90: 
 91:     for (const group of groups) {
 92:       const documentId = group.extendedData.some(
 93:         (data) => data.name === "extNumber"
 94:       ) ?
 95:         getPromoDocumentId(group) :
 96:         getDocumentId(group);
 97: 
 98:       logInfo("Processing card", {
 99:         productId: group.productId,
100:         documentId,
101:         groupId: group.groupId,
102:       });
103: 
104:       writeBatch.set(db.collection(COLLECTION.CARDS).doc(documentId), group);
105:       metadata.cardCount++;
106:     }
107: 
108:     await writeBatch.commit();
109: 
110:     metadata.status = "success";
111:     logInfo("Card sync completed successfully", {metadata});
112:   } catch (error) {
113:     metadata.status = "failed";
114:     metadata.errors.push(
115:       error instanceof Error ? error.message : "Unknown error"
116:     );
117:     logError(error as GenericError | GenericObject, "syncCards");
118:   }
119: 
120:   return metadata;
121: }
</file>

<file path="src/services/priceSync.ts">
 1: import {
 2:   constructTCGCSVPath,
 3:   makeRequest,
 4:   validateAndFixDocumentId,
 5: } from "../utils/syncUtils";
 6: import {db, COLLECTION} from "../config/firebase";
 7: import {
 8:   CardPrice,
 9:   SyncOptions,
10:   SyncMetadata,
11:   GenericError,
12:   GenericObject,
13: } from "../types";
14: import {logInfo, logError} from "../utils/logger";
15: 
16: /**
17:  * Fetch prices for a specific group.
18:  */
19: async function fetchPricesForGroup(groupId: string): Promise<CardPrice[]> {
20:   const endpoint = `/${COLLECTION.CARDS}/${groupId}/prices`;
21:   const pricesResponse = await makeRequest<{ results: CardPrice[] }>(
22:     constructTCGCSVPath(endpoint)
23:   );
24:   logInfo("Fetched prices for group", {
25:     groupId,
26:     count: pricesResponse.results.length,
27:   });
28:   return pricesResponse.results;
29: }
30: 
31: /**
32:  * Generate a document ID for price data.
33:  */
34: function getDocumentIdForPrice(productId: number, cardNumber: string): string {
35:   return validateAndFixDocumentId(productId, cardNumber);
36: }
37: 
38: /**
39:  * Main function to sync prices.
40:  */
41: export async function syncPrices(
42:   options: SyncOptions = {}
43: ): Promise<SyncMetadata> {
44:   const metadata: SyncMetadata = {
45:     lastSync: new Date(),
46:     status: "in_progress",
47:     cardCount: 0,
48:     type: options.dryRun ? "manual" : "scheduled",
49:     groupsProcessed: 0,
50:     groupsUpdated: 0,
51:     errors: [],
52:   };
53: 
54:   logInfo("Starting price sync", {options});
55: 
56:   try {
57:     const prices = await fetchPricesForGroup(options.groupId || "");
58:     const writeBatch = db.batch();
59: 
60:     for (const price of prices) {
61:       const cardNumber = (price as any).cardNumber || "unknown"; // Using fallback if cardNumber is missing
62:       const documentId = getDocumentIdForPrice(price.productId, cardNumber);
63: 
64:       logInfo("Processing price", {
65:         productId: price.productId,
66:         cardNumber,
67:         documentId,
68:       });
69: 
70:       writeBatch.set(db.collection(COLLECTION.PRICES).doc(documentId), price);
71:       metadata.cardCount++;
72:     }
73: 
74:     await writeBatch.commit();
75: 
76:     metadata.status = "success";
77:     logInfo("Price sync completed successfully", {metadata});
78:   } catch (error) {
79:     metadata.status = "failed";
80:     metadata.errors.push(
81:       error instanceof Error ? error.message : "Unknown error"
82:     );
83:     logError(error as GenericError | GenericObject, "syncPrices");
84:   }
85: 
86:   return metadata;
87: }
</file>

<file path="src/services/r2Storage.ts">
  1: import {
  2:   S3Client,
  3:   PutObjectCommand,
  4:   HeadObjectCommand,
  5:   DeleteObjectCommand,
  6: } from "@aws-sdk/client-s3";
  7: import {R2_CONFIG} from "../config/r2"; // Import the R2 configuration
  8: import {logInfo, logWarning} from "../utils/logger";
  9: import {ImagePathOptions} from "../utils/imageHandler";
 10: 
 11: // Define RollbackInfo type
 12: interface RollbackInfo {
 13:   path: string;
 14:   metadata: Record<string, string>;
 15: }
 16: 
 17: export class R2Storage {
 18:   private client: S3Client;
 19:   private bucket: string;
 20:   private storagePath: string;
 21:   private customDomain: string;
 22:   private rollbackQueue: RollbackInfo[] = []; // Rollback queue
 23: 
 24:   constructor() {
 25:     this.client = new S3Client({
 26:       region: "auto",
 27:       endpoint: `https://${R2_CONFIG.ACCOUNT_ID}.r2.cloudflarestorage.com`,
 28:       credentials: {
 29:         accessKeyId: R2_CONFIG.ACCESS_KEY_ID,
 30:         secretAccessKey: R2_CONFIG.SECRET_ACCESS_KEY,
 31:       },
 32:     });
 33:     this.bucket = R2_CONFIG.BUCKET_NAME;
 34:     this.storagePath = R2_CONFIG.STORAGE_PATH;
 35:     this.customDomain = R2_CONFIG.CUSTOM_DOMAIN;
 36:   }
 37: 
 38:   private getFullPath(path: string): string {
 39:     return `${this.storagePath}/${path}`;
 40:   }
 41: 
 42:   sanitizeCardNumber(cardNumber: string | undefined): string {
 43:     if (!cardNumber) {
 44:       throw new Error("Card number is required");
 45:     }
 46:     return cardNumber.replace(/\//g, "_");
 47:   }
 48: 
 49:   getStoragePath(options: ImagePathOptions): string {
 50:     let suffix = "_200w"; // default to low res
 51:     if (options.isHighRes) {
 52:       suffix = "_400w";
 53:     }
 54:     const sanitizedCardNumber = this.sanitizeCardNumber(options.cardNumber);
 55:     const fileName = `${options.productId}_${sanitizedCardNumber}${suffix}.jpg`;
 56:     return `${options.groupId}/${fileName}`;
 57:   }
 58: 
 59:   async uploadImage(
 60:     path: string,
 61:     buffer: Buffer,
 62:     metadata: Record<string, string>
 63:   ): Promise<string> {
 64:     const fullPath = this.getFullPath(path);
 65: 
 66:     try {
 67:       // Pre-upload validation
 68:       await logInfo("Validating image upload", {
 69:         path: fullPath,
 70:         size: buffer.length,
 71:         metadata,
 72:       });
 73: 
 74:       if (!buffer || buffer.length === 0) {
 75:         throw new Error("Empty buffer provided for upload");
 76:       }
 77: 
 78:       // Store current metadata for potential rollback
 79:       const existingMetadata = await this.getImageMetadata(path);
 80:       if (existingMetadata) {
 81:         this.addToRollback(path, existingMetadata); // Add to rollback queue
 82:       }
 83: 
 84:       // Upload to R2
 85:       await this.client.send(
 86:         new PutObjectCommand({
 87:           Bucket: this.bucket,
 88:           Key: fullPath,
 89:           Body: buffer,
 90:           ContentType: "image/jpeg",
 91:           ContentLength: buffer.length,
 92:           Metadata: metadata,
 93:           CacheControl: "public, max-age=31536000",
 94:         })
 95:       );
 96: 
 97:       // Verify upload
 98:       const uploadedMetadata = await this.getImageMetadata(path);
 99:       if (!uploadedMetadata) {
100:         throw new Error("Upload verification failed - metadata not found");
101:       }
102: 
103:       // Verify metadata matches
104:       const metadataMatch = await this.compareMetadata(path, metadata);
105:       if (!metadataMatch) {
106:         throw new Error("Upload verification failed - metadata mismatch");
107:       }
108: 
109:       const publicUrl = this.getPublicUrl(fullPath);
110: 
111:       await logInfo("Image upload successful", {
112:         path: fullPath,
113:         size: buffer.length,
114:         url: publicUrl,
115:         metadata: uploadedMetadata,
116:       });
117: 
118:       return publicUrl;
119:     } catch (error) {
120:       await logWarning("Image upload failed", {
121:         path: fullPath,
122:         error: error instanceof Error ? error.message : "Unknown error",
123:       });
124:       throw error;
125:     }
126:   }
127: 
128:   async getImageMetadata(path: string): Promise<Record<string, string> | null> {
129:     const fullPath = this.getFullPath(path);
130:     try {
131:       const response = await this.client.send(
132:         new HeadObjectCommand({
133:           Bucket: this.bucket,
134:           Key: fullPath,
135:         })
136:       );
137: 
138:       await logInfo("Retrieved image metadata", {
139:         path: fullPath,
140:         metadata: response.Metadata,
141:         contentLength: response.ContentLength,
142:         lastModified: response.LastModified,
143:       });
144: 
145:       return response.Metadata || null;
146:     } catch (error) {
147:       if ((error as any).name === "NotFound") {
148:         await logInfo("Image metadata not found", {path: fullPath});
149:         return null;
150:       }
151:       await logWarning("Failed to retrieve image metadata", {
152:         path: fullPath,
153:         error: error instanceof Error ? error.message : "Unknown error",
154:       });
155:       throw error;
156:     }
157:   }
158: 
159:   async fileExists(path: string): Promise<boolean> {
160:     const fullPath = this.getFullPath(path);
161:     try {
162:       await this.client.send(
163:         new HeadObjectCommand({
164:           Bucket: this.bucket,
165:           Key: fullPath,
166:         })
167:       );
168: 
169:       await logInfo("Image file exists", {path: fullPath});
170:       return true;
171:     } catch (error) {
172:       if ((error as any).name === "NotFound") {
173:         await logInfo("Image file does not exist", {path: fullPath});
174:         return false;
175:       }
176:       await logWarning("Error checking file existence", {
177:         path: fullPath,
178:         error: error instanceof Error ? error.message : "Unknown error",
179:       });
180:       throw error;
181:     }
182:   }
183: 
184:   async validateUpload(path: string, expectedSize: number): Promise<boolean> {
185:     try {
186:       const response = await this.client.send(
187:         new HeadObjectCommand({
188:           Bucket: this.bucket,
189:           Key: this.getFullPath(path),
190:         })
191:       );
192: 
193:       const actualSize = response.ContentLength || 0;
194:       const isValid = actualSize === expectedSize;
195: 
196:       await logInfo("Validating uploaded image", {
197:         path,
198:         expectedSize,
199:         actualSize,
200:         isValid,
201:         metadata: response.Metadata,
202:       });
203: 
204:       return isValid;
205:     } catch (error) {
206:       await logWarning("Image validation failed", {
207:         path,
208:         expectedSize,
209:         error: error instanceof Error ? error.message : "Unknown error",
210:       });
211:       return false;
212:     }
213:   }
214: 
215:   async compareMetadata(
216:     path: string,
217:     expectedMetadata: Record<string, string>
218:   ): Promise<boolean> {
219:     const storedMetadata = await this.getImageMetadata(path);
220:     if (!storedMetadata) return false;
221: 
222:     const relevantFields = ["hash", "type", "size"]; // Compare only relevant fields
223:     const matches = relevantFields.every(
224:       (field) => storedMetadata[field] === expectedMetadata[field]
225:     );
226: 
227:     await logInfo("Metadata comparison result", {
228:       path,
229:       matches,
230:       stored: storedMetadata,
231:       expected: expectedMetadata,
232:     });
233: 
234:     return matches;
235:   }
236: 
237:   async rollback(): Promise<void> {
238:     await logInfo("Starting rollback", {
239:       queueLength: this.rollbackQueue.length,
240:     });
241: 
242:     for (const {path, metadata} of this.rollbackQueue.reverse()) {
243:       try {
244:         await this.client.send(
245:           new PutObjectCommand({
246:             Bucket: this.bucket,
247:             Key: this.getFullPath(path),
248:             Metadata: metadata,
249:           })
250:         );
251: 
252:         await logInfo("Rollback successful for path", {
253:           path,
254:           metadata,
255:         });
256:       } catch (rollbackError) {
257:         await logWarning("Rollback failed for path", {
258:           path,
259:           metadata,
260:           error:
261:             rollbackError instanceof Error ?
262:               rollbackError.message :
263:               "Unknown error",
264:         });
265:       }
266:     }
267: 
268:     this.rollbackQueue = [];
269:     await logInfo("Rollback complete", {
270:       timestamp: new Date().toISOString(),
271:     });
272:   }
273: 
274:   async deleteFile(path: string): Promise<void> {
275:     const fullPath = this.getFullPath(path);
276:     try {
277:       await this.client.send(
278:         new DeleteObjectCommand({
279:           Bucket: this.bucket,
280:           Key: fullPath,
281:         })
282:       );
283: 
284:       await logInfo("File deleted successfully", {path: fullPath});
285:     } catch (error) {
286:       await logWarning("File deletion failed", {
287:         path: fullPath,
288:         error: error instanceof Error ? error.message : "Unknown error",
289:       });
290:       throw error;
291:     }
292:   }
293: 
294:   getPublicUrl(path: string): string {
295:     return `${this.customDomain}/${this.getFullPath(path)}`;
296:   }
297: 
298:   // Add the 'addToRollback' method
299:   private addToRollback(path: string, metadata: Record<string, string>): void {
300:     this.rollbackQueue.push({path, metadata});
301:   }
302: }
303: 
304: export const r2Storage = new R2Storage();
</file>

<file path="src/test/testEndpoints.ts">
 1: import axios, {isAxiosError} from "axios";
 2: 
 3: const FIREBASE_REGION = "us-central1";
 4: const PROJECT_ID = "fftcg-sync-service";
 5: const BASE_URL = `https://${FIREBASE_REGION}-${PROJECT_ID}.cloudfunctions.net`;
 6: 
 7: interface SyncResponse {
 8:   lastSync: Date;
 9:   status: string;
10:   cardCount: number;
11:   type: string;
12:   groupsProcessed: number;
13:   groupsUpdated: number;
14:   errors: string[];
15:   duration?: number;
16: }
17: 
18: async function testEndpoints() {
19:   try {
20:     // Test card sync
21:     console.log("\nTesting card sync...");
22:     const cardResponse = await axios.get<SyncResponse>(
23:       `${BASE_URL}/testCardSync`,
24:       {
25:         params: {
26:           limit: 5,
27:           dryRun: true,
28:           groupId: "23783",
29:           productId: 477236, // Added specific product ID
30:         },
31:       }
32:     );
33:     console.log(
34:       "Card sync results:",
35:       JSON.stringify(cardResponse.data, null, 2)
36:     );
37: 
38:     // Test price sync
39:     console.log("\nTesting price sync...");
40:     const priceResponse = await axios.get<SyncResponse>(
41:       `${BASE_URL}/testPriceSync`,
42:       {
43:         params: {
44:           groupId: "23783",
45:           dryRun: true,
46:           limit: 5,
47:           productId: 477236, // Added specific product ID
48:         },
49:       }
50:     );
51:     console.log(
52:       "Price sync results:",
53:       JSON.stringify(priceResponse.data, null, 2)
54:     );
55: 
56:     // Test health check
57:     console.log("\nTesting health check...");
58:     const healthResponse = await axios.get(`${BASE_URL}/healthCheck`);
59:     console.log(
60:       "Health check response:",
61:       JSON.stringify(healthResponse.data, null, 2)
62:     );
63:   } catch (error) {
64:     if (isAxiosError(error)) {
65:       console.error("Test failed:", error.response?.data || error.message);
66:       console.error("Status:", error.response?.status);
67:       console.error("Headers:", error.response?.headers);
68:     } else {
69:       console.error("Test failed:", error);
70:     }
71:     process.exit(1);
72:   }
73: }
74: 
75: // Execute tests
76: console.log("Starting endpoint tests...");
77: testEndpoints()
78:   .then(() => {
79:     console.log("All tests completed!");
80:   })
81:   .catch(console.error);
</file>

<file path="src/test/testImageHandler.ts">
  1: process.env.NODE_ENV = "test";
  2: process.env.FORCE_UPDATE = "true";
  3: 
  4: import {ImageHandler} from "../utils/imageHandler";
  5: 
  6: const TEST_CASES = [
  7:   {
  8:     imageUrl: "https://tcgplayer-cdn.tcgplayer.com/product/477236_200w.jpg",
  9:     groupId: "23783",
 10:     productId: 477236,
 11:     cardNumber: "1-001H",
 12:     description: "FFVII Boss Deck - Test Card",
 13:   },
 14:   // Add a second test case to verify consistency
 15:   {
 16:     imageUrl: "https://tcgplayer-cdn.tcgplayer.com/product/477237_200w.jpg",
 17:     groupId: "23783",
 18:     productId: 477237,
 19:     cardNumber: "1-002H",
 20:     description: "FFVII Boss Deck - Second Test Card",
 21:   },
 22: ];
 23: 
 24: async function testImageProcessing() {
 25:   try {
 26:     console.log("\n=== Testing Image Handler ===");
 27:     const imageHandler = new ImageHandler();
 28: 
 29:     for (const testCase of TEST_CASES) {
 30:       console.log(`\nProcessing: ${testCase.description}`);
 31: 
 32:       // Test URL generation
 33:       console.log("\nURL Structure Test:");
 34:       console.log(`Original (TCGPlayer): ${testCase.imageUrl}`);
 35:       console.log(
 36:         `Expected High-res: ${testCase.imageUrl.replace(
 37:           "_200w.jpg",
 38:           "_400w.jpg"
 39:         )}`
 40:       );
 41:       console.log(
 42:         `Expected Low-res: ${testCase.imageUrl.replace(".jpg", "_200w.jpg")}`
 43:       );
 44: 
 45:       // Test full image processing
 46:       console.log("\n=== Processing Test ===");
 47:       const result = await imageHandler.processImage(
 48:         testCase.imageUrl,
 49:         testCase.groupId,
 50:         testCase.productId,
 51:         testCase.cardNumber
 52:       );
 53: 
 54:       console.log("\nProcessing Results:");
 55:       console.log(`Status: ${result.updated ? "Updated" : "Unchanged"}`);
 56:       console.log("\nURL Structure:");
 57:       console.log(`High-res URL: ${result.highResUrl}`);
 58:       console.log(`Low-res URL: ${result.lowResUrl}`);
 59: 
 60:       console.log("\nMetadata:");
 61:       console.log(`Content Type: ${result.metadata.contentType}`);
 62:       console.log(
 63:         `Original Size: ${(result.metadata.originalSize || 0) / 1024}KB`
 64:       );
 65:       console.log(
 66:         `High-res Size: ${(result.metadata.highResSize || 0) / 1024}KB`
 67:       );
 68:       console.log(
 69:         `Low-res Size: ${(result.metadata.lowResSize || 0) / 1024}KB`
 70:       );
 71:       console.log(`Last Updated: ${result.metadata.updated.toISOString()}`);
 72: 
 73:       // Verify URL accessibility
 74:       console.log("\nVerifying URL accessibility:");
 75:       const urlsToTest = [
 76:         {type: "High-res", url: result.highResUrl},
 77:         {type: "Low-res", url: result.lowResUrl},
 78:       ];
 79: 
 80:       for (const {type, url} of urlsToTest) {
 81:         if (url) {
 82:           try {
 83:             const response = await fetch(url, {method: "HEAD"});
 84:             console.log(
 85:               `${type} URL accessible: ${response.ok} (${response.status})`
 86:             );
 87:             if (response.ok) {
 88:               console.log(
 89:                 `Cache-Control: ${response.headers.get("cache-control")}`
 90:               );
 91:             }
 92:           } catch (error) {
 93:             console.error(`${type} URL not accessible:`, error);
 94:           }
 95:         } else {
 96:           console.log(`${type} URL not generated`);
 97:         }
 98:       }
 99: 
100:       // Test metadata storage
101:       console.log("\nVerifying metadata structure:");
102:       console.log(
103:         "- No URLs in metadata:",
104:         !Object.keys(result.metadata).some((key) =>
105:           key.toLowerCase().includes("url")
106:         )
107:       );
108:       console.log(
109:         "- Has required fields:",
110:         result.metadata.contentType &&
111:           result.metadata.size !== undefined &&
112:           result.metadata.updated instanceof Date
113:       );
114:     }
115: 
116:     // Test cleanup (dry run)
117:     console.log("\n=== Cleanup Test (Dry Run) ===");
118:   } catch (error) {
119:     console.error("\nTest failed:", error);
120:     process.exit(1);
121:   }
122: }
123: 
124: async function runTests() {
125:   console.log("Starting Image Handler tests...");
126:   console.log("Testing new URL structure and public access...");
127: 
128:   try {
129:     await testImageProcessing();
130:     console.log("\nAll Image Handler tests completed successfully!");
131:   } catch (error) {
132:     console.error("\nTests failed:", error);
133:     process.exit(1);
134:   }
135: }
136: 
137: // Execute the tests
138: runTests().catch(console.error);
</file>

<file path="src/test/testSync.ts">
 1: // src/test/testSync.ts
 2: 
 3: // Force test mode and updates
 4: process.env.NODE_ENV = "test";
 5: process.env.FORCE_UPDATE = "true";
 6: 
 7: import {syncCards} from "../services/cardSync";
 8: 
 9: async function testSync() {
10:   console.log("\n=== Testing Card Sync ===");
11: 
12:   const testGroups = [
13:     {id: "23783", name: "Hidden Legends"},
14:     {id: "1939", name: "Opus I"},
15:     {id: "23568", name: "Hidden Trials"},
16:   ];
17: 
18:   for (const group of testGroups) {
19:     console.log(`\nTesting sync for ${group.name} (${group.id})`);
20: 
21:     try {
22:       const options = {
23:         groupId: group.id,
24:         limit: 5,
25:         dryRun: false, // Changed to false to actually process updates
26:         showAll: true,
27:         force: true,
28:         skipImages: false,
29:       };
30: 
31:       const result = await syncCards(options);
32: 
33:       console.log("\nSync Results:");
34:       console.log(`Status: ${result.status}`);
35:       console.log(`Cards Processed: ${result.cardCount}`);
36:       console.log(`Groups Updated: ${result.groupsUpdated}`);
37:       console.log(`Images Processed: ${result.imagesProcessed}`);
38:       console.log(`Images Updated: ${result.imagesUpdated}`);
39: 
40:       if (result.errors.length > 0) {
41:         console.log("\nErrors:");
42:         result.errors.forEach((error) => console.log(`- ${error}`));
43:       }
44:     } catch (error) {
45:       console.error(`Error syncing ${group.name}:`, error);
46:     }
47:   }
48: }
49: 
50: // Execute the test
51: console.log("Starting Card Sync tests...");
52: testSync()
53:   .then(() => console.log("\nAll Card Sync tests completed!"))
54:   .catch(console.error);
</file>

<file path="src/test/validateSync.ts">
  1: // src/test/validateSync.ts
  2: 
  3: import * as admin from "firebase-admin";
  4: import {Timestamp} from "firebase-admin/firestore";
  5: import {ServiceAccount} from "firebase-admin";
  6: import * as path from "path";
  7: import * as fs from "fs/promises";
  8: import {COLLECTION} from "../config/firebase";
  9: 
 10: interface ValidationResult {
 11:   collection: string;
 12:   documentsChecked: number;
 13:   documentsValid: number;
 14:   errors: string[];
 15:   details?: Record<string, any>;
 16: }
 17: 
 18: interface ValidationOptions {
 19:   limit?: number;
 20:   verbose?: boolean;
 21:   groupId?: string;
 22: }
 23: 
 24: async function initializeFirebase(): Promise<FirebaseFirestore.Firestore> {
 25:   try {
 26:     const serviceAccountPath = path.resolve(
 27:       __dirname,
 28:       "../../../service_account_key.json"
 29:     );
 30:     const serviceAccountData = await fs.readFile(serviceAccountPath, "utf8");
 31:     const serviceAccount = JSON.parse(serviceAccountData) as ServiceAccount;
 32: 
 33:     if (!admin.apps.length) {
 34:       admin.initializeApp({
 35:         credential: admin.credential.cert(serviceAccount),
 36:       });
 37:     }
 38: 
 39:     return admin.firestore();
 40:   } catch (error) {
 41:     console.error("Failed to initialize Firebase:", error);
 42:     throw error;
 43:   }
 44: }
 45: 
 46: async function validateCollection(
 47:   db: FirebaseFirestore.Firestore,
 48:   collectionName: string,
 49:   validator: (doc: FirebaseFirestore.DocumentData) => boolean,
 50:   options: ValidationOptions = {}
 51: ): Promise<ValidationResult> {
 52:   const result: ValidationResult = {
 53:     collection: collectionName,
 54:     documentsChecked: 0,
 55:     documentsValid: 0,
 56:     errors: [],
 57:     details: {},
 58:   };
 59: 
 60:   try {
 61:     let query = db.collection(collectionName).orderBy("lastUpdated", "desc");
 62: 
 63:     if (options.limit) {
 64:       query = query.limit(options.limit);
 65:     }
 66: 
 67:     if (options.groupId) {
 68:       if (
 69:         collectionName === COLLECTION.CARDS ||
 70:         collectionName === COLLECTION.PRICES
 71:       ) {
 72:         query = query.where("groupId", "==", options.groupId);
 73:       }
 74:     }
 75: 
 76:     const snapshot = await query.get();
 77:     result.documentsChecked = snapshot.size;
 78: 
 79:     snapshot.forEach((doc) => {
 80:       const data = doc.data();
 81:       try {
 82:         if (validator(data)) {
 83:           result.documentsValid++;
 84:           if (options.verbose) {
 85:             // For cards and prices, verify the document ID format
 86:             if (
 87:               collectionName === COLLECTION.CARDS ||
 88:               collectionName === COLLECTION.PRICES
 89:             ) {
 90:               const [productId, cardNumber] = doc.id.split("_");
 91:               if (!productId || !cardNumber) {
 92:                 result.errors.push(`Invalid document ID format for ${doc.id}`);
 93:                 return;
 94:               }
 95:               if (parseInt(productId) !== data.productId) {
 96:                 result.errors.push(
 97:                   `Document ID productId mismatch for ${doc.id}`
 98:                 );
 99:                 return;
100:               }
101:               const numberField = data.extendedData?.find(
102:                 (field: any) => field.name === "Number"
103:               );
104:               if (numberField && numberField.value !== cardNumber) {
105:                 result.errors.push(
106:                   `Document ID cardNumber mismatch for ${doc.id}`
107:                 );
108:                 return;
109:               }
110:             }
111:             result.details![doc.id] = data;
112:           }
113:         } else {
114:           result.errors.push(`Document ${doc.id} failed validation`);
115:         }
116:       } catch (error) {
117:         result.errors.push(`Error validating ${doc.id}: ${error}`);
118:       }
119:     });
120:   } catch (error) {
121:     result.errors.push(`Error accessing collection: ${error}`);
122:   }
123: 
124:   return result;
125: }
126: 
127: async function validateSync(options: ValidationOptions = {}) {
128:   console.log("Starting sync validation...");
129:   console.log("Options:", JSON.stringify(options, null, 2));
130: 
131:   try {
132:     const db = await initializeFirebase();
133: 
134:     // Validate cards
135:     const cardResult = await validateCollection(
136:       db,
137:       COLLECTION.CARDS,
138:       (data) => {
139:         return (
140:           typeof data.productId === "number" &&
141:           typeof data.name === "string" &&
142:           typeof data.lastUpdated === "object" &&
143:           data.lastUpdated instanceof Timestamp &&
144:           Array.isArray(data.extendedData) &&
145:           data.extendedData.some(
146:             (field: any) => field.name === "Number" && field.value
147:           )
148:         );
149:       },
150:       options
151:     );
152: 
153:     // Validate prices
154:     const priceResult = await validateCollection(
155:       db,
156:       COLLECTION.PRICES,
157:       (data) => {
158:         return (
159:           data.lastUpdated instanceof Timestamp &&
160:           (!data.normal || typeof data.normal.midPrice === "number") &&
161:           (!data.foil || typeof data.foil.midPrice === "number") &&
162:           typeof data.productId === "number" &&
163:           typeof data.cardNumber === "string"
164:         );
165:       },
166:       options
167:     );
168: 
169:     // Validate sync metadata
170:     const metadataResult = await validateCollection(
171:       db,
172:       COLLECTION.SYNC_METADATA,
173:       (data) => {
174:         return (
175:           data.lastSync instanceof Timestamp &&
176:           typeof data.status === "string" &&
177:           typeof data.cardCount === "number" &&
178:           Array.isArray(data.errors)
179:         );
180:       },
181:       options
182:     );
183: 
184:     // Print results
185:     console.log("\nValidation Results:");
186:     [cardResult, priceResult, metadataResult].forEach((result) => {
187:       console.log(`\n${result.collection}:`);
188:       console.log(`Documents Checked: ${result.documentsChecked}`);
189:       console.log(`Valid Documents: ${result.documentsValid}`);
190:       if (result.errors.length > 0) {
191:         console.log("Errors:");
192:         result.errors.forEach((error) => console.log(`- ${error}`));
193:       }
194:       if (options.verbose && result.details) {
195:         console.log("\nDetails:");
196:         console.log(JSON.stringify(result.details, null, 2));
197:       }
198:     });
199:   } catch (error) {
200:     console.error("Validation failed:", error);
201:     process.exit(1);
202:   }
203: }
204: 
205: // Execute validation with command line arguments
206: const args = process.argv.slice(2);
207: const options: ValidationOptions = {
208:   limit: args.includes("--limit") ?
209:     parseInt(args[args.indexOf("--limit") + 1]) :
210:     undefined,
211:   verbose: args.includes("--verbose"),
212:   groupId: args.includes("--groupId") ?
213:     args[args.indexOf("--groupId") + 1] :
214:     undefined,
215: };
216: 
217: validateSync(options)
218:   .then(() => {
219:     console.log("\nValidation completed!");
220:   })
221:   .catch(console.error);
</file>

<file path="src/test/verifyMigration.ts">
  1: // src/test/verifyMigration.ts
  2: 
  3: import {db, COLLECTION} from "../config/firebase";
  4: import {r2Storage} from "../services/r2Storage";
  5: import {logInfo} from "../utils/logger";
  6: import type {
  7:   Query,
  8:   DocumentData,
  9:   CollectionReference,
 10: } from "@google-cloud/firestore";
 11: 
 12: interface VerificationStats {
 13:   total: number;
 14:   withHighRes: number;
 15:   withLowRes: number;
 16:   withOldImageUrl: number;
 17:   withValidR2Urls: number;
 18:   errors: string[];
 19: }
 20: 
 21: interface ExtendedData {
 22:   name: string;
 23:   value: string;
 24: }
 25: 
 26: async function verifyMigration(groupId?: string, limit?: number) {
 27:   const stats: VerificationStats = {
 28:     total: 0,
 29:     withHighRes: 0,
 30:     withLowRes: 0,
 31:     withOldImageUrl: 0,
 32:     withValidR2Urls: 0,
 33:     errors: [],
 34:   };
 35: 
 36:   try {
 37:     console.log("\nStarting migration verification...");
 38: 
 39:     const cardsCollection = db.collection(
 40:       COLLECTION.CARDS
 41:     ) as CollectionReference<DocumentData>;
 42:     let query: Query<DocumentData> = cardsCollection;
 43: 
 44:     if (groupId) {
 45:       query = query.where("groupId", "==", groupId);
 46:     }
 47:     if (limit) {
 48:       query = query.limit(limit);
 49:     }
 50: 
 51:     const snapshot = await query.get();
 52:     stats.total = snapshot.size;
 53: 
 54:     console.log(`Found ${stats.total} cards to verify`);
 55: 
 56:     for (const doc of snapshot.docs) {
 57:       const data = doc.data();
 58:       const extendedData = data.extendedData as ExtendedData[];
 59:       const cardNumber = extendedData?.find(
 60:         (field) => field.name === "Number"
 61:       )?.value;
 62:       const cardName = data.name || "Unknown Card";
 63:       const cardId = cardNumber ?
 64:         `${data.productId}_${cardNumber}` :
 65:         `${data.productId}`;
 66: 
 67:       console.log(`\nVerifying card: ${cardName} (${cardId})`);
 68:       console.log(`Group ID: ${data.groupId}`);
 69:       console.log(`Card Number: ${cardNumber || "Not found"}`);
 70: 
 71:       // Check URLs
 72:       if (data.highResUrl) {
 73:         stats.withHighRes++;
 74:         console.log(`High-res URL: ${data.highResUrl}`);
 75:       }
 76:       if (data.lowResUrl) {
 77:         stats.withLowRes++;
 78:         console.log(`Low-res URL: ${data.lowResUrl}`);
 79:       }
 80:       if (data.imageUrl) {
 81:         stats.withOldImageUrl++;
 82:         console.log(`Old image URL found: ${data.imageUrl}`);
 83:       }
 84: 
 85:       if (!cardNumber) {
 86:         stats.errors.push(
 87:           `Missing card number for ${cardName} (${data.productId})`
 88:         );
 89:         continue;
 90:       }
 91: 
 92:       // Verify R2 files exist
 93:       if (data.highResUrl && data.lowResUrl) {
 94:         try {
 95:           const sanitizedCardNumber = cardNumber.replace(/\//g, "_");
 96:           const highResPath = `${data.groupId}/${data.productId}_${sanitizedCardNumber}_400w.jpg`;
 97:           const lowResPath = `${data.groupId}/${data.productId}_${sanitizedCardNumber}_200w.jpg`;
 98: 
 99:           console.log("Checking R2 paths:");
100:           console.log(`High-res: ${highResPath}`);
101:           console.log(`Low-res: ${lowResPath}`);
102: 
103:           const [highResExists, lowResExists] = await Promise.all([
104:             r2Storage.fileExists(highResPath),
105:             r2Storage.fileExists(lowResPath),
106:           ]);
107: 
108:           if (highResExists && lowResExists) {
109:             stats.withValidR2Urls++;
110:             console.log(" R2 files verified successfully");
111:           } else {
112:             stats.errors.push(
113:               `Missing R2 files for ${cardName} (${cardId}): ` +
114:                 `High-res: ${highResExists}, Low-res: ${lowResExists}`
115:             );
116:             console.log(" R2 files verification failed");
117:           }
118: 
119:           // Verify URLs are accessible
120:           const [highResResponse, lowResResponse] = await Promise.all([
121:             fetch(data.highResUrl, {method: "HEAD"}),
122:             fetch(data.lowResUrl, {method: "HEAD"}),
123:           ]);
124: 
125:           console.log("URL Accessibility:");
126:           console.log(
127:             `High-res (${highResResponse.status}): ${
128:               highResResponse.ok ? "" : ""
129:             }`
130:           );
131:           console.log(
132:             `Low-res (${lowResResponse.status}): ${
133:               lowResResponse.ok ? "" : ""
134:             }`
135:           );
136: 
137:           if (!highResResponse.ok || !lowResResponse.ok) {
138:             stats.errors.push(
139:               `Invalid URLs for ${cardName} (${cardId}): ` +
140:                 `High-res: ${highResResponse.status}, ` +
141:                 `Low-res: ${lowResResponse.status}`
142:             );
143:           }
144:         } catch (error) {
145:           const errorMessage =
146:             error instanceof Error ? error.message : "Unknown error";
147:           stats.errors.push(
148:             `Error verifying ${cardName} (${cardId}): ${errorMessage}`
149:           );
150:           console.log(` Verification error: ${errorMessage}`);
151:         }
152:       } else {
153:         console.log(" Missing image URLs");
154:         if (!data.highResUrl) {
155:           stats.errors.push(`Missing high-res URL for ${cardName} (${cardId})`);
156:         }
157:         if (!data.lowResUrl) {
158:           stats.errors.push(`Missing low-res URL for ${cardName} (${cardId})`);
159:         }
160:       }
161:     }
162: 
163:     // Print summary
164:     console.log("\n=== Verification Summary ===");
165:     console.log(`Total cards checked: ${stats.total}`);
166:     console.log(`Cards with high-res URLs: ${stats.withHighRes}`);
167:     console.log(`Cards with low-res URLs: ${stats.withLowRes}`);
168:     console.log(`Cards with old image URLs: ${stats.withOldImageUrl}`);
169:     console.log(`Cards with verified R2 URLs: ${stats.withValidR2Urls}`);
170: 
171:     if (stats.errors.length > 0) {
172:       console.log("\nErrors found:");
173:       stats.errors.forEach((error) => console.log(`- ${error}`));
174:     }
175: 
176:     await logInfo("Migration verification completed", {stats});
177:   } catch (error) {
178:     console.error("Verification failed:", error);
179:     throw error;
180:   }
181: }
182: 
183: // Execute if run directly
184: if (require.main === module) {
185:   const args = process.argv.slice(2);
186:   const options = {
187:     groupId: args.includes("--group-id") ?
188:       args[args.indexOf("--group-id") + 1] :
189:       undefined,
190:     limit: args.includes("--limit") ?
191:       parseInt(args[args.indexOf("--limit") + 1]) :
192:       undefined,
193:   };
194: 
195:   verifyMigration(options.groupId, options.limit)
196:     .then(() => {
197:       console.log("\nVerification completed!");
198:       process.exit(0);
199:     })
200:     .catch((error) => {
201:       console.error("Verification failed:", error);
202:       process.exit(1);
203:     });
204: }
</file>

<file path="src/types/index.ts">
  1: // src/types/index.ts
  2: 
  3: import type * as express from "express";
  4: 
  5: export {express};
  6: 
  7: export interface GenericError extends Error {
  8:   code?: string;
  9:   message: string;
 10:   stack?: string;
 11: }
 12: 
 13: export interface CardProduct {
 14:   productId: number;
 15:   name: string;
 16:   cleanName: string;
 17:   imageUrl?: string; // TCGPlayer URL (from API)
 18:   highResUrl: string; // Firebase Storage URL (_400w)
 19:   lowResUrl: string; // Firebase Storage URL (_200w)
 20:   categoryId: number;
 21:   groupId: number;
 22:   url: string;
 23:   modifiedOn: string;
 24:   imageCount: number;
 25:   imageMetadata?: ImageMetadata;
 26:   extendedData: Array<{
 27:     name: string;
 28:     displayName: string;
 29:     value: string;
 30:   }>;
 31: }
 32: 
 33: export interface CardPrice {
 34:   productId: number;
 35:   lowPrice: number;
 36:   midPrice: number;
 37:   highPrice: number;
 38:   marketPrice: number | null;
 39:   directLowPrice: number | null;
 40:   subTypeName: "Normal" | "Foil";
 41:   cardNumber?: string; // Add this if cardNumber exists
 42: }
 43: 
 44: export interface SyncOptions {
 45:   dryRun?: boolean;
 46:   limit?: number;
 47:   groupId?: string;
 48:   productId?: number;
 49:   showAll?: boolean;
 50:   skipImages?: boolean;
 51:   imagesOnly?: boolean; // New option
 52:   silent?: boolean;
 53:   force?: boolean;
 54: }
 55: 
 56: export interface SyncMetadata {
 57:   lastSync: Date;
 58:   status: "in_progress" | "success" | "failed" | "completed_with_errors";
 59:   cardCount: number;
 60:   type: "manual" | "scheduled";
 61:   groupsProcessed: number;
 62:   groupsUpdated: number;
 63:   errors: string[];
 64:   duration?: number;
 65:   imagesProcessed?: number;
 66:   imagesUpdated?: number;
 67: }
 68: 
 69: export type CacheType = "card" | "price" | "image";
 70: 
 71: export interface PriceData {
 72:   normal?: CardPrice;
 73:   foil?: CardPrice;
 74:   lastUpdated: Date;
 75:   productId: number;
 76:   cardNumber: string;
 77: }
 78: 
 79: export interface ImageMetadata {
 80:   contentType: string;
 81:   size: number;
 82:   updated: Date;
 83:   hash: string;
 84:   groupId?: string;
 85:   productId?: number;
 86:   cardNumber?: string;
 87:   lastUpdated?: Date;
 88:   originalSize?: number;
 89:   highResSize?: number;
 90:   lowResSize?: number;
 91: }
 92: 
 93: export interface ImageProcessingResult {
 94:   highResUrl: string; // Firebase Storage URL (_400w)
 95:   lowResUrl: string; // Firebase Storage URL (_200w)
 96:   metadata: ImageMetadata;
 97:   updated: boolean;
 98: }
 99: 
100: export interface ImageSyncStats {
101:   processed: number;
102:   updated: number;
103:   failed: number;
104:   skipped: number;
105: }
106: 
107: export interface LogData {
108:   imageMetadata?: ImageMetadata;
109:   imageSyncStats?: ImageSyncStats;
110:   [key: string]: any;
111: }
112: 
113: export interface CacheOptions {
114:   max: number;
115:   ttl: number;
116: }
117: 
118: export interface CacheEntry<T> {
119:   data: T;
120:   timestamp: number;
121:   expires: number;
122: }
123: 
124: export interface ImageProcessingError extends GenericError {
125:   productId: number;
126:   groupId: string;
127:   originalUrl: string;
128:   type: "download" | "upload" | "metadata" | "unknown";
129: }
130: 
131: export type GenericObject = Record<string, any>;
132: 
133: export interface BatchProcessingStats {
134:   total: number;
135:   processed: number;
136:   successful: number;
137:   failed: number;
138:   skipped: number;
139: }
140: 
141: export interface BatchOptions {
142:   batchSize?: number;
143:   delayBetweenBatches?: number;
144:   onBatchComplete?: (stats: BatchProcessingStats) => Promise<void>;
145:   skipImages?: boolean;
146:   retryFailedImages?: boolean;
147: }
148: 
149: export interface BatchProgress {
150:   totalBatches: number;
151:   currentBatch: number;
152:   processedCount: number;
153:   totalItems: number;
154: }
155: 
156: export interface ImageLogEntry {
157:   timestamp: Date;
158:   level: "INFO" | "WARNING" | "ERROR";
159:   message: string;
160:   context?: string;
161:   metadata?: ImageMetadata;
162:   error?: ImageProcessingError;
163:   stats?: ImageSyncStats;
164: }
165: 
166: export interface StoragePaths {
167:   original: string;
168:   processed: string;
169: }
170: 
171: export interface StorageOptions {
172:   contentType: string;
173:   metadata?: Record<string, string>;
174:   cacheControl?: string;
175: }
176: 
177: export interface ImageProcessingProgress {
178:   total: number;
179:   current: number;
180:   updated: number;
181:   failed: number;
182:   startTime: number;
183:   estimatedTimeRemaining?: number;
184: }
185: 
186: export interface ImageValidationError {
187:   code: "FILE_TOO_LARGE" | "INVALID_FORMAT" | "VALIDATION_ERROR";
188:   message: string;
189: }
190: 
191: export interface SyncMode {
192:   type: "data" | "images" | "full";
193:   isForced: boolean;
194:   isDryRun: boolean;
195: }
196: 
197: export interface RefreshOptions {
198:   isDryRun: boolean;
199:   isVerbose: boolean;
200:   isForce: boolean;
201:   groupId?: string;
202:   skipImages: boolean;
203:   imagesOnly: boolean;
204: }
</file>

<file path="src/utils/backup.ts">
  1: // src/utils/backup.ts
  2: 
  3: import {db, COLLECTION} from "../config/firebase";
  4: import * as fs from "fs";
  5: import * as path from "path";
  6: 
  7: interface BackupMetadata {
  8:   timestamp: string;
  9:   collections: string[];
 10:   documentCounts: { [key: string]: number };
 11: }
 12: 
 13: export async function backup(): Promise<void> {
 14:   const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
 15:   const backupDir = path.join(__dirname, "..", "..", "backups");
 16:   const backupPath = path.join(backupDir, `backup_${timestamp}`);
 17: 
 18:   // Create backup directory if it doesn't exist
 19:   if (!fs.existsSync(backupDir)) {
 20:     fs.mkdirSync(backupDir, {recursive: true});
 21:   }
 22: 
 23:   const collections = [
 24:     COLLECTION.CARDS,
 25:     COLLECTION.PRICES,
 26:     COLLECTION.SYNC_METADATA,
 27:     COLLECTION.CARD_HASHES,
 28:     COLLECTION.PRICE_HASHES,
 29:     COLLECTION.IMAGE_METADATA,
 30:   ];
 31: 
 32:   const metadata: BackupMetadata = {
 33:     timestamp,
 34:     collections,
 35:     documentCounts: {},
 36:   };
 37: 
 38:   try {
 39:     console.log("Starting database backup...");
 40: 
 41:     for (const collectionName of collections) {
 42:       console.log(`Backing up collection: ${collectionName}`);
 43: 
 44:       const snapshot = await db.collection(collectionName).get();
 45:       const documents = snapshot.docs.map((doc) => ({
 46:         id: doc.id,
 47:         data: doc.data(),
 48:       }));
 49: 
 50:       metadata.documentCounts[collectionName] = documents.length;
 51: 
 52:       // Save collection to its own file
 53:       const collectionPath = `${backupPath}_${collectionName}.json`;
 54:       fs.writeFileSync(collectionPath, JSON.stringify(documents, null, 2));
 55: 
 56:       console.log(`- Backed up ${documents.length} documents`);
 57:     }
 58: 
 59:     // Save metadata
 60:     const metadataPath = `${backupPath}_metadata.json`;
 61:     fs.writeFileSync(metadataPath, JSON.stringify(metadata, null, 2));
 62: 
 63:     console.log("\nBackup completed successfully");
 64:     console.log(`Location: ${backupDir}`);
 65:     console.log("Files:");
 66:     collections.forEach((collection) => {
 67:       console.log(`- backup_${timestamp}_${collection}.json`);
 68:     });
 69:     console.log(`- backup_${timestamp}_metadata.json`);
 70:   } catch (error) {
 71:     console.error("Backup failed:", error);
 72:     throw error;
 73:   }
 74: }
 75: 
 76: export async function restore(timestamp: string): Promise<void> {
 77:   const backupDir = path.join(__dirname, "..", "..", "backups");
 78:   const metadataPath = path.join(
 79:     backupDir,
 80:     `backup_${timestamp}_metadata.json`
 81:   );
 82: 
 83:   if (!fs.existsSync(metadataPath)) {
 84:     throw new Error(`Backup metadata not found: ${metadataPath}`);
 85:   }
 86: 
 87:   const metadata: BackupMetadata = JSON.parse(
 88:     fs.readFileSync(metadataPath, "utf8")
 89:   );
 90: 
 91:   try {
 92:     console.log("Starting database restore...");
 93: 
 94:     for (const collectionName of metadata.collections) {
 95:       console.log(`Restoring collection: ${collectionName}`);
 96: 
 97:       const collectionPath = path.join(
 98:         backupDir,
 99:         `backup_${timestamp}_${collectionName}.json`
100:       );
101:       const documents = JSON.parse(fs.readFileSync(collectionPath, "utf8"));
102: 
103:       const batch = db.batch();
104:       let batchCount = 0;
105:       let totalRestored = 0;
106: 
107:       for (const doc of documents) {
108:         const ref = db.collection(collectionName).doc(doc.id);
109:         batch.set(ref, doc.data);
110:         batchCount++;
111: 
112:         if (batchCount >= 500) {
113:           // Firestore batch limit
114:           await batch.commit();
115:           totalRestored += batchCount;
116:           batchCount = 0;
117:         }
118:       }
119: 
120:       if (batchCount > 0) {
121:         await batch.commit();
122:         totalRestored += batchCount;
123:       }
124: 
125:       console.log(`- Restored ${totalRestored} documents`);
126:     }
127: 
128:     console.log("\nRestore completed successfully");
129:   } catch (error) {
130:     console.error("Restore failed:", error);
131:     throw error;
132:   }
133: }
134: 
135: // If run directly, perform backup
136: if (require.main === module) {
137:   backup()
138:     .then(() => process.exit(0))
139:     .catch((error) => {
140:       console.error("Fatal error:", error);
141:       process.exit(1);
142:     });
143: }
</file>

<file path="src/utils/cache.ts">
 1: import LRUCache from "lru-cache";
 2: import {CacheType, CardProduct} from "../types";
 3: 
 4: const options = {
 5:   max: 500,
 6:   ttl: 1000 * 60 * 60, // 1 hour
 7: };
 8: 
 9: export const cardCache = new LRUCache<string, CardProduct>(options);
10: 
11: export const getCacheKey = (
12:   type: CacheType,
13:   id: number,
14:   cardNumber?: string
15: ): string => {
16:   return cardNumber ? `${type}:${id}:${cardNumber}` : `${type}:${id}`;
17: };
</file>

<file path="src/utils/databaseBackup.ts">
 1: import {db, COLLECTION} from "../config/firebase";
 2: import * as fs from "fs/promises";
 3: import * as path from "path";
 4: 
 5: async function backupCollection(collectionName: string): Promise<void> {
 6:   console.log(`Backing up ${collectionName}...`);
 7:   const snapshot = await db.collection(collectionName).get();
 8:   const data = snapshot.docs.map((doc) => ({
 9:     id: doc.id,
10:     data: doc.data(),
11:   }));
12: 
13:   const backupDir = path.join(__dirname, "../../backups");
14:   await fs.mkdir(backupDir, {recursive: true});
15: 
16:   const timestamp = new Date().toISOString().replace(/[:]/g, "-");
17:   const filename = `${collectionName}_${timestamp}.json`;
18:   await fs.writeFile(
19:     path.join(backupDir, filename),
20:     JSON.stringify(data, null, 2)
21:   );
22: 
23:   console.log(`Backed up ${data.length} documents from ${collectionName}`);
24: }
25: 
26: export async function backupDatabase(): Promise<void> {
27:   try {
28:     console.log("Starting database backup...");
29: 
30:     await Promise.all([
31:       backupCollection(COLLECTION.CARDS),
32:       backupCollection(COLLECTION.PRICES),
33:       backupCollection(COLLECTION.SYNC_METADATA),
34:       backupCollection(COLLECTION.CARD_HASHES),
35:       backupCollection(COLLECTION.PRICE_HASHES),
36:       backupCollection(COLLECTION.IMAGE_METADATA),
37:     ]);
38: 
39:     console.log("Backup completed successfully!");
40:   } catch (error) {
41:     console.error("Backup failed:", error);
42:     throw error;
43:   }
44: }
</file>

<file path="src/utils/databaseCleanup.ts">
 1: import {db, COLLECTION} from "../config/firebase";
 2: import {logInfo} from "./logger";
 3: import {FieldValue} from "firebase-admin/firestore";
 4: 
 5: export async function cleanupImageUrls(): Promise<void> {
 6:   let count = 0;
 7:   let batchCount = 0;
 8:   let batch = db.batch(); // Initialize first batch
 9: 
10:   const snapshot = await db.collection(COLLECTION.CARDS).get();
11: 
12:   for (const doc of snapshot.docs) {
13:     const data = doc.data();
14: 
15:     if (data.imageUrl) {
16:       const updates: any = {
17:         originalUrl: data.imageUrl,
18:         lastUpdated: new Date(),
19:       };
20: 
21:       // Remove imageUrl field
22:       updates.imageUrl = FieldValue.delete();
23: 
24:       batch.update(doc.ref, updates);
25:       count++;
26:       batchCount++;
27: 
28:       if (batchCount >= 500) {
29:         // Firestore batch limit
30:         await batch.commit();
31:         await logInfo(`Processed ${count} documents`);
32:         // Create a new batch after commit
33:         batch = db.batch();
34:         batchCount = 0;
35:       }
36:     }
37:   }
38: 
39:   // Commit any remaining updates
40:   if (batchCount > 0) {
41:     await batch.commit();
42:     await logInfo(`Processed final batch of ${batchCount} documents`);
43:   }
44: 
45:   await logInfo(`Cleanup completed. Updated ${count} documents`);
46: }
47: 
48: // Execute if run directly
49: if (require.main === module) {
50:   cleanupImageUrls()
51:     .then(() => {
52:       console.log("Cleanup completed successfully!");
53:       process.exit(0);
54:     })
55:     .catch((error) => {
56:       console.error("Cleanup failed:", error);
57:       process.exit(1);
58:     });
59: }
</file>

<file path="src/utils/databaseMigration.ts">
 1: import {db, COLLECTION} from "../config/firebase";
 2: import {processBatch} from "./syncUtils";
 3: import {FieldValue} from "firebase-admin/firestore";
 4: import type {QueryDocumentSnapshot} from "@google-cloud/firestore";
 5: 
 6: interface BatchStats {
 7:   processed: number;
 8:   total: number;
 9: }
10: 
11: /**
12:  * Migrates image URLs by processing documents in batches.
13:  * Removes the `imageUrl` field from documents and updates high-res and low-res URLs.
14:  */
15: export async function migrateImageUrls(
16:   _options: { dryRun?: boolean; limit?: number; groupId?: string } = {}
17: ): Promise<void> {
18:   // Query the cards collection
19:   const query = db.collection(COLLECTION.CARDS);
20:   const snapshot = await query.get();
21: 
22:   console.log(`Found ${snapshot.size} documents to process.`);
23: 
24:   // Process documents in batches
25:   await processBatch<QueryDocumentSnapshot>(
26:     snapshot.docs,
27:     async (batch: QueryDocumentSnapshot[]) => {
28:       const writeBatch = db.batch();
29: 
30:       for (const doc of batch) {
31:         const data = doc.data();
32:         const updates: any = {lastUpdated: new Date()};
33: 
34:         // Remove the `imageUrl` field if it exists
35:         if (data.imageUrl) {
36:           updates.imageUrl = FieldValue.delete();
37:         }
38: 
39:         // Update the document in Firestore
40:         writeBatch.update(doc.ref, updates);
41:         console.log(`Prepared updates for document: ${doc.id}`);
42:       }
43: 
44:       // Commit the batch
45:       if (batch.length > 0) {
46:         await writeBatch.commit();
47:         console.log(`Committed batch of ${batch.length} documents.`);
48:       }
49:     },
50:     {
51:       batchSize: 500, // Firestore supports up to 500 operations per batch
52:       onBatchComplete: async (batchStats: BatchStats) => {
53:         console.log(
54:           `Processed ${batchStats.processed} out of ${batchStats.total} documents.`
55:         );
56:       },
57:     }
58:   );
59: 
60:   console.log("Migration completed successfully.");
61: }
62: 
63: // If run directly, execute the migration
64: if (require.main === module) {
65:   const args = process.argv.slice(2);
66: 
67:   const options: {
68:     dryRun?: boolean;
69:     limit?: number;
70:     groupId?: string;
71:   } = {
72:     dryRun: args.includes("--dry-run"),
73:     limit: args.includes("--limit") ?
74:       parseInt(args[args.indexOf("--limit") + 1]) :
75:       undefined,
76:     groupId: args.includes("--group-id") ?
77:       args[args.indexOf("--group-id") + 1] :
78:       undefined,
79:   };
80: 
81:   migrateImageUrls(options)
82:     .then(() => {
83:       console.log("Image URL migration completed!");
84:       process.exit(0);
85:     })
86:     .catch((error) => {
87:       console.error("Migration failed:", error);
88:       process.exit(1);
89:     });
90: }
</file>

<file path="src/utils/databaseRefresh.ts">
  1: // src/utils/databaseRefresh.ts
  2: 
  3: import {syncCards} from "../services/cardSync";
  4: import {syncPrices} from "../services/priceSync";
  5: import {backup} from "../utils/backup";
  6: import {logError} from "./logger";
  7: import {GenericError, SyncMode} from "../types";
  8: import {db, COLLECTION} from "../config/firebase";
  9: 
 10: interface RefreshSetSummary {
 11:   name: string;
 12:   cards: {
 13:     total: number;
 14:     toUpdate: number;
 15:     unchanged: number;
 16:   };
 17:   prices: {
 18:     total: number;
 19:     toUpdate: number;
 20:     unchanged: number;
 21:   };
 22:   images: {
 23:     total: number;
 24:     toUpdate: number;
 25:     unchanged: number;
 26:   };
 27: }
 28: 
 29: interface RefreshSummary {
 30:   sets: RefreshSetSummary[];
 31:   mode: SyncMode;
 32:   duration?: number;
 33: }
 34: 
 35: interface RefreshOptions {
 36:   isDryRun: boolean;
 37:   isVerbose: boolean;
 38:   isForce: boolean;
 39:   groupId?: string;
 40:   skipImages: boolean;
 41:   imagesOnly: boolean;
 42:   limit?: number; // Add this line
 43: }
 44: 
 45: async function parseCommandLineArgs(): Promise<RefreshOptions> {
 46:   const args = process.argv.slice(2);
 47:   console.log("Raw command line arguments:", args);
 48: 
 49:   const options: RefreshOptions = {
 50:     isDryRun: false,
 51:     isVerbose: false,
 52:     isForce: false,
 53:     skipImages: false,
 54:     imagesOnly: false,
 55:     limit: undefined,
 56:     groupId: undefined,
 57:   };
 58: 
 59:   for (let i = 0; i < args.length; i++) {
 60:     const arg = args[i];
 61:     const nextArg = args[i + 1];
 62: 
 63:     switch (arg) {
 64:     case "--dry-run":
 65:       options.isDryRun = true;
 66:       break;
 67:     case "--verbose":
 68:       options.isVerbose = true;
 69:       break;
 70:     case "--force":
 71:       options.isForce = true;
 72:       break;
 73:     case "--skip-images":
 74:       options.skipImages = true;
 75:       break;
 76:     case "--images-only":
 77:       options.imagesOnly = true;
 78:       break;
 79:     case "--group-id":
 80:       if (nextArg && !nextArg.startsWith("--")) {
 81:         options.groupId = nextArg;
 82:         i++; // Skip next argument since we used it
 83:       }
 84:       break;
 85:     case "--limit":
 86:       if (nextArg && !nextArg.startsWith("--")) {
 87:         options.limit = parseInt(nextArg, 10);
 88:         i++; // Skip next argument since we used it
 89:       }
 90:       break;
 91:     }
 92:   }
 93: 
 94:   return options;
 95: }
 96: 
 97: async function resetDatabase(): Promise<void> {
 98:   await backup();
 99: }
100: 
101: async function clearHashes(): Promise<void> {
102:   console.log("Clearing existing hashes...");
103:   const batch = db.batch();
104: 
105:   const cardHashes = await db.collection(COLLECTION.CARD_HASHES).get();
106:   cardHashes.docs.forEach((doc) => {
107:     batch.delete(doc.ref);
108:   });
109: 
110:   const priceHashes = await db.collection(COLLECTION.PRICE_HASHES).get();
111:   priceHashes.docs.forEach((doc) => {
112:     batch.delete(doc.ref);
113:   });
114: 
115:   await batch.commit();
116:   console.log("Hashes cleared");
117: }
118: 
119: function validateOptions(options: RefreshOptions): void {
120:   if (options.skipImages && options.imagesOnly) {
121:     throw new Error("Cannot use both --skip-images and --images-only flags");
122:   }
123: }
124: 
125: function getSyncMode(options: RefreshOptions): SyncMode {
126:   return {
127:     type: options.imagesOnly ? "images" : options.skipImages ? "data" : "full",
128:     isForced: options.isForce,
129:     isDryRun: options.isDryRun,
130:   };
131: }
132: 
133: async function displayInitialSummary(
134:   options: RefreshOptions,
135:   mode: SyncMode
136: ): Promise<void> {
137:   console.log(`\nFFTCG Database ${options.isDryRun ? "Analysis" : "Refresh"}`);
138:   console.log("==========================");
139:   console.log(`Mode: ${mode.type.toUpperCase()}`);
140:   if (options.groupId) console.log(`Processing group: ${options.groupId}`);
141:   if (options.limit) console.log(`Limit: ${options.limit} items`); // Add this line
142:   console.log("Force mode:", options.isForce ? "enabled" : "disabled");
143:   console.log("Verbose mode:", options.isVerbose ? "enabled" : "disabled");
144:   console.log("Dry run:", options.isDryRun ? "yes" : "no");
145:   console.log("\nStarting process...");
146: }
147: 
148: export async function refreshDatabase(): Promise<void> {
149:   const startTime = Date.now();
150:   const options = await parseCommandLineArgs();
151: 
152:   try {
153:     validateOptions(options);
154:     const mode = getSyncMode(options);
155: 
156:     // Add detailed options logging
157:     console.log("\nParsed Options:");
158:     console.log("==============");
159:     console.log({
160:       isDryRun: options.isDryRun,
161:       isVerbose: options.isVerbose,
162:       isForce: options.isForce,
163:       groupId: options.groupId,
164:       skipImages: options.skipImages,
165:       imagesOnly: options.imagesOnly,
166:       limit: options.limit,
167:     });
168:     console.log(); // Add blank line for readability
169: 
170:     await displayInitialSummary(options, mode);
171: 
172:     const summary: RefreshSummary = {
173:       sets: [],
174:       mode,
175:     };
176: 
177:     // Analysis Phase
178:     console.log("\nAnalyzing current state...");
179:     console.log("Applied query parameters:");
180:     console.log("- Group ID:", options.groupId || "all groups");
181:     console.log("- Limit:", options.limit || "no limit");
182:     console.log("- Images Only:", options.imagesOnly);
183:     console.log(); // Add blank line for readability
184: 
185:     if (options.isForce && !options.isDryRun) {
186:       await clearHashes();
187:     }
188: 
189:     // Card/Image Sync Analysis
190:     const cardResult = await syncCards({
191:       dryRun: true,
192:       skipImages: options.skipImages,
193:       imagesOnly: options.imagesOnly,
194:       silent: !options.isVerbose,
195:       force: options.isForce,
196:       groupId: options.groupId,
197:       limit: options.limit,
198:     });
199: 
200:     // Log the results of the card sync
201:     console.log("\nCard Sync Configuration:");
202:     console.log("======================");
203:     console.log({
204:       dryRun: true,
205:       skipImages: options.skipImages,
206:       imagesOnly: options.imagesOnly,
207:       silent: !options.isVerbose,
208:       force: options.isForce,
209:       groupId: options.groupId,
210:       limit: options.limit,
211:       cardsFound: cardResult.cardCount,
212:     });
213:     console.log(); // Add blank line for readability
214: 
215:     // Price Sync Analysis (skip if images-only)
216:     const priceResult = !options.imagesOnly ?
217:       await syncPrices({
218:         dryRun: true,
219:         silent: !options.isVerbose,
220:         force: options.isForce,
221:         groupId: options.groupId,
222:       }) :
223:       {
224:         cardCount: 0,
225:         groupsUpdated: 0,
226:         errors: [],
227:       };
228: 
229:     // Display Analysis Results
230:     console.log("\nAnalysis Results:");
231:     console.log("----------------");
232: 
233:     if (options.imagesOnly) {
234:       console.log("\nImage Processing:");
235:       console.log(`Images to Process: ${cardResult.imagesProcessed || 0}`);
236:       console.log(`Images to Update: ${cardResult.imagesUpdated || 0}`);
237:     } else if (options.skipImages) {
238:       console.log("\nData Processing:");
239:       console.log(`Cards to Update: ${cardResult.cardCount}`);
240:       console.log(`Prices to Update: ${priceResult.cardCount}`);
241:     } else {
242:       console.log("\nFull Sync Processing:");
243:       console.log(`Cards to Update: ${cardResult.cardCount}`);
244:       console.log(`Prices to Update: ${priceResult.cardCount}`);
245:       console.log(`Images to Process: ${cardResult.imagesProcessed || 0}`);
246:       console.log(`Images to Update: ${cardResult.imagesUpdated || 0}`);
247:     }
248: 
249:     // Perform Updates if not dry run
250:     if (!options.isDryRun) {
251:       console.log("\nPerforming Updates:");
252:       console.log("------------------");
253: 
254:       console.log("Creating backup...");
255:       await resetDatabase();
256: 
257:       // Perform Card/Image Updates
258:       const cardUpdateResult = await syncCards({
259:         dryRun: false,
260:         skipImages: options.skipImages,
261:         imagesOnly: options.imagesOnly,
262:         silent: !options.isVerbose,
263:         force: options.isForce,
264:         groupId: options.groupId,
265:       });
266: 
267:       // Perform Price Updates (skip if images-only)
268:       const priceUpdateResult = !options.imagesOnly ?
269:         await syncPrices({
270:           dryRun: false,
271:           silent: !options.isVerbose,
272:           force: options.isForce,
273:           groupId: options.groupId,
274:         }) :
275:         {
276:           cardCount: 0,
277:           groupsUpdated: 0,
278:           errors: [],
279:         };
280: 
281:       // Display Update Results
282:       console.log("\nUpdate Results:");
283:       console.log("--------------");
284: 
285:       if (options.imagesOnly) {
286:         console.log(
287:           `Images Processed: ${cardUpdateResult.imagesProcessed || 0}`
288:         );
289:         console.log(`Images Updated: ${cardUpdateResult.imagesUpdated || 0}`);
290:       } else if (options.skipImages) {
291:         console.log(`Cards Updated: ${cardUpdateResult.cardCount}`);
292:         console.log(`Groups Updated: ${cardUpdateResult.groupsUpdated}`);
293:         console.log(`Price Records Updated: ${priceUpdateResult.cardCount}`);
294:       } else {
295:         console.log(`Cards Updated: ${cardUpdateResult.cardCount}`);
296:         console.log(`Groups Updated: ${cardUpdateResult.groupsUpdated}`);
297:         console.log(`Price Records Updated: ${priceUpdateResult.cardCount}`);
298:         console.log(
299:           `Images Processed: ${cardUpdateResult.imagesProcessed || 0}`
300:         );
301:         console.log(`Images Updated: ${cardUpdateResult.imagesUpdated || 0}`);
302:       }
303: 
304:       // Display any errors encountered
305:       if (
306:         cardUpdateResult.errors.length > 0 ||
307:         priceUpdateResult.errors.length > 0
308:       ) {
309:         console.log("\nErrors encountered:");
310:         [...cardUpdateResult.errors, ...priceUpdateResult.errors].forEach(
311:           (error) => {
312:             console.log(`- ${error}`);
313:           }
314:         );
315:       }
316:     } else {
317:       console.log("\nThis was a dry run - no changes were made");
318:       console.log("Run without --dry-run flag to perform updates");
319:     }
320: 
321:     // Calculate and display duration
322:     const duration = (Date.now() - startTime) / 1000;
323:     console.log("\nOperation Summary:");
324:     console.log("-----------------");
325:     console.log(`Total Duration: ${duration.toFixed(2)} seconds`);
326:     console.log(`Mode: ${summary.mode.type.toUpperCase()}`);
327:     console.log(`Operation Type: ${options.isDryRun ? "Analysis" : "Update"}`);
328:     if (options.groupId) {
329:       console.log(`Processed Group: ${options.groupId}`);
330:     }
331:     if (options.limit) {
332:       console.log(`Limit Applied: ${options.limit}`);
333:     }
334:     console.log(`Total Cards Processed: ${cardResult.cardCount}`);
335:     if (cardResult.imagesProcessed) {
336:       console.log(`Images Processed: ${cardResult.imagesProcessed}`);
337:       console.log(`Images Updated: ${cardResult.imagesUpdated || 0}`);
338:     }
339:   } catch (error) {
340:     const genericError: GenericError = {
341:       message: error instanceof Error ? error.message : "Unknown error",
342:       name: error instanceof Error ? error.name : "UnknownError",
343:       code: error instanceof Error ? error.name : "UNKNOWN_ERROR",
344:       stack: error instanceof Error ? error.stack : undefined,
345:     };
346:     console.error("\nError:", genericError.message);
347:     await logError(genericError, "Database refresh failed");
348:     throw error;
349:   }
350: }
351: 
352: // Function to handle environment checks
353: function checkEnvironment(): void {
354:   if (!process.env.FUNCTIONS_EMULATOR && !process.env.NODE_ENV) {
355:     console.warn("\nWarning: Running in production environment");
356:     console.warn("Set NODE_ENV=development for local testing");
357:   }
358: 
359:   if (process.env.RESTRICT_BANDWIDTH === "true") {
360:     console.warn("\nWarning: Bandwidth restrictions are enabled");
361:     console.warn("Image processing may be limited");
362:   }
363: }
364: 
365: // Main execution
366: if (require.main === module) {
367:   checkEnvironment();
368:   refreshDatabase()
369:     .then(() => {
370:       console.log("\nOperation completed successfully!");
371:       process.exit(0);
372:     })
373:     .catch((error) => {
374:       console.error("\nFatal error:", error);
375:       process.exit(1);
376:     });
377: }
378: 
379: // Export additional utilities for testing and external use
380: export const utils = {
381:   parseCommandLineArgs,
382:   validateOptions,
383:   getSyncMode,
384:   checkEnvironment,
385: };
</file>

<file path="src/utils/databaseReset.ts">
 1: // src/utils/databaseReset.ts
 2: import {db, COLLECTION} from "../config/firebase";
 3: import {backupDatabase} from "./databaseBackup";
 4: import {logInfo, logError} from "./logger";
 5: import {GenericError} from "../types";
 6: 
 7: async function deleteCollection(collectionName: string): Promise<void> {
 8:   const batchSize = 500;
 9:   const query = db.collection(collectionName).limit(batchSize);
10:   let deletedCount = 0;
11:   let hasMore = true;
12: 
13:   try {
14:     while (hasMore) {
15:       const snapshot = await query.get();
16: 
17:       if (snapshot.empty) {
18:         hasMore = false;
19:         continue;
20:       }
21: 
22:       const batch = db.batch();
23:       snapshot.docs.forEach((doc) => {
24:         batch.delete(doc.ref);
25:         deletedCount++;
26:       });
27: 
28:       await batch.commit();
29:       await logInfo(`Deleted ${deletedCount} documents from ${collectionName}`);
30:     }
31: 
32:     await logInfo(`Finished deleting collection ${collectionName}`);
33:   } catch (error) {
34:     const genericError: GenericError = {
35:       message: error instanceof Error ? error.message : "Unknown error",
36:       name: error instanceof Error ? error.name : "UnknownError",
37:       code: error instanceof Error ? error.name : "UNKNOWN_ERROR",
38:       stack: error instanceof Error ? error.stack : undefined,
39:     };
40:     await logError(
41:       genericError,
42:       `Failed to delete collection ${collectionName}`
43:     );
44:     throw error;
45:   }
46: }
47: 
48: export async function resetDatabase(): Promise<void> {
49:   try {
50:     // First, create a backup
51:     await backupDatabase();
52: 
53:     // Then delete all collections
54:     await Promise.all([
55:       deleteCollection(COLLECTION.CARDS),
56:       deleteCollection(COLLECTION.PRICES),
57:       deleteCollection(COLLECTION.SYNC_METADATA),
58:       deleteCollection(COLLECTION.CARD_HASHES),
59:       deleteCollection(COLLECTION.PRICE_HASHES),
60:       deleteCollection(COLLECTION.IMAGE_METADATA),
61:     ]);
62: 
63:     await logInfo("Database reset completed successfully");
64:   } catch (error) {
65:     const genericError: GenericError = {
66:       message: error instanceof Error ? error.message : "Unknown error",
67:       name: error instanceof Error ? error.name : "UnknownError",
68:       code: error instanceof Error ? error.name : "UNKNOWN_ERROR",
69:       stack: error instanceof Error ? error.stack : undefined,
70:     };
71:     await logError(genericError, "Database reset failed");
72:     throw error;
73:   }
74: }
</file>

<file path="src/utils/error.ts">
 1: import {db, COLLECTION} from "../config/firebase";
 2: import {logError} from "./logger";
 3: 
 4: export interface ErrorReport {
 5:   timestamp: Date;
 6:   context: string;
 7:   error: string;
 8:   stackTrace?: string;
 9:   metadata?: Record<string, unknown>;
10:   severity: "ERROR" | "WARNING" | "CRITICAL";
11: }
12: 
13: export class DetailedError extends Error {
14:   constructor(
15:     message: string,
16:     public context: string,
17:     public metadata?: Record<string, unknown>,
18:     public severity: "ERROR" | "WARNING" | "CRITICAL" = "ERROR"
19:   ) {
20:     super(message);
21:     this.name = "DetailedError";
22:   }
23: }
24: 
25: export async function logDetailedError(
26:   error: Error,
27:   context: string,
28:   metadata?: Record<string, unknown>,
29:   severity: "ERROR" | "WARNING" | "CRITICAL" = "ERROR"
30: ): Promise<void> {
31:   const report: ErrorReport = {
32:     timestamp: new Date(),
33:     context,
34:     error: error.message,
35:     stackTrace: error.stack,
36:     metadata,
37:     severity,
38:   };
39: 
40:   // Log to Firestore
41:   await db.collection(COLLECTION.LOGS)
42:     .add(report);
43: 
44:   // Log using existing logger
45:   await logError(error, context);
46: }
</file>

<file path="src/utils/imageAccessibilityChecker.ts">
 1: // src/utils/imageAccessibilityChecker.ts
 2: import axios from "axios";
 3: import {logInfo, logWarning} from "./logger";
 4: 
 5: export interface AccessibilityResult {
 6:   isAccessible: boolean;
 7:   statusCode?: number;
 8:   error?: string;
 9:   headers?: Record<string, string>;
10: }
11: 
12: export class ImageAccessibilityChecker {
13:   static async checkUrl(url: string): Promise<AccessibilityResult> {
14:     try {
15:       const response = await axios.head(url, {
16:         timeout: 5000,
17:         validateStatus: () => true, // Don't throw on any status
18:       });
19: 
20:       const isAccessible = response.status === 200;
21:       const result: AccessibilityResult = {
22:         isAccessible,
23:         statusCode: response.status,
24:         headers: response.headers as Record<string, string>,
25:       };
26: 
27:       if (isAccessible) {
28:         await logInfo("URL accessibility check passed", {
29:           url,
30:           status: response.status,
31:           contentType: response.headers["content-type"],
32:           contentLength: response.headers["content-length"],
33:         });
34:       } else {
35:         await logWarning("URL accessibility check failed", {
36:           url,
37:           status: response.status,
38:         });
39:       }
40: 
41:       return result;
42:     } catch (error) {
43:       await logWarning("URL accessibility check error", {
44:         url,
45:         error: error instanceof Error ? error.message : "Unknown error",
46:       });
47: 
48:       return {
49:         isAccessible: false,
50:         error: error instanceof Error ? error.message : "Unknown error",
51:       };
52:     }
53:   }
54: }
</file>

<file path="src/utils/imageCache.ts">
  1: // src/utils/imageCache.ts
  2: 
  3: import LRUCache from "lru-cache";
  4: import {ImageMetadata} from "../types";
  5: import {logInfo} from "./logger";
  6: 
  7: interface CacheStats {
  8:   hits: number;
  9:   misses: number;
 10:   totalRequests: number;
 11: }
 12: 
 13: export class ImageCache {
 14:   private metadataCache: LRUCache<string, ImageMetadata>;
 15:   private bufferCache: LRUCache<string, Buffer>;
 16:   private existsCache: LRUCache<string, boolean>;
 17:   private stats: CacheStats = {
 18:     hits: 0,
 19:     misses: 0,
 20:     totalRequests: 0,
 21:   };
 22: 
 23:   constructor() {
 24:     this.metadataCache = new LRUCache<string, ImageMetadata>({
 25:       max: 1000,
 26:       ttl: 1000 * 60 * 60, // 1 hour
 27:       updateAgeOnGet: true,
 28:     });
 29: 
 30:     this.bufferCache = new LRUCache<string, Buffer>({
 31:       max: 100,
 32:       ttl: 1000 * 60 * 5, // 5 minutes
 33:       updateAgeOnGet: true,
 34:       maxSize: 50 * 1024 * 1024, // 50MB max cache size
 35:       sizeCalculation: (buffer) => buffer.length,
 36:     });
 37: 
 38:     this.existsCache = new LRUCache<string, boolean>({
 39:       max: 1000,
 40:       ttl: 1000 * 60 * 60, // 1 hour
 41:       updateAgeOnGet: true,
 42:     });
 43:   }
 44: 
 45:   getMetadataCacheKey(
 46:     groupId: string,
 47:     productId: number,
 48:     cardNumber: string,
 49:     isHighRes: boolean
 50:   ): string {
 51:     return `metadata:${groupId}:${productId}:${cardNumber}:${
 52:       isHighRes ? "high" : "original"
 53:     }`;
 54:   }
 55: 
 56:   getBufferCacheKey(url: string): string {
 57:     return `buffer:${url}`;
 58:   }
 59: 
 60:   getExistsCacheKey(
 61:     groupId: string,
 62:     productId: number,
 63:     cardNumber: string,
 64:     isHighRes: boolean
 65:   ): string {
 66:     return `exists:${groupId}:${productId}:${cardNumber}:${
 67:       isHighRes ? "high" : "original"
 68:     }`;
 69:   }
 70: 
 71:   async getMetadata(key: string): Promise<ImageMetadata | undefined> {
 72:     this.stats.totalRequests++;
 73:     const value = this.metadataCache.get(key);
 74:     if (value) {
 75:       this.stats.hits++;
 76:       await logInfo("Cache hit: metadata", {
 77:         key,
 78:         timestamp: new Date().toISOString(),
 79:       });
 80:     } else {
 81:       this.stats.misses++;
 82:     }
 83:     return value;
 84:   }
 85: 
 86:   async getBuffer(key: string): Promise<Buffer | undefined> {
 87:     this.stats.totalRequests++;
 88:     const value = this.bufferCache.get(key);
 89:     if (value) {
 90:       this.stats.hits++;
 91:       await logInfo("Cache hit: buffer", {
 92:         key,
 93:         size: value.length,
 94:         timestamp: new Date().toISOString(),
 95:       });
 96:     } else {
 97:       this.stats.misses++;
 98:     }
 99:     return value;
100:   }
101: 
102:   getExists(key: string): boolean | undefined {
103:     this.stats.totalRequests++;
104:     const value = this.existsCache.get(key);
105:     if (value !== undefined) {
106:       this.stats.hits++;
107:     } else {
108:       this.stats.misses++;
109:     }
110:     return value;
111:   }
112: 
113:   setMetadata(key: string, value: ImageMetadata): void {
114:     this.metadataCache.set(key, value);
115:   }
116: 
117:   setBuffer(key: string, value: Buffer): void {
118:     this.bufferCache.set(key, value);
119:   }
120: 
121:   setExists(key: string, value: boolean): void {
122:     this.existsCache.set(key, value);
123:   }
124: 
125:   clear(): void {
126:     this.metadataCache.clear();
127:     this.bufferCache.clear();
128:     this.existsCache.clear();
129:     this.stats = {
130:       hits: 0,
131:       misses: 0,
132:       totalRequests: 0,
133:     };
134:   }
135: 
136:   getStats(): CacheStats {
137:     return {...this.stats};
138:   }
139: }
140: 
141: export const imageCache = new ImageCache();
</file>

<file path="src/utils/imageCompressor.ts">
 1: // src/utils/imageCompressor.ts
 2: 
 3: import sharp from "sharp";
 4: import {logInfo} from "./logger";
 5: 
 6: export interface CompressionResult {
 7:   buffer: Buffer;
 8:   info: {
 9:     width: number;
10:     height: number;
11:     size: number;
12:     format: string;
13:     quality: number;
14:   };
15: }
16: 
17: export class ImageCompressor {
18:   private static readonly QUALITY = {
19:     HIGH_RES: 90,
20:     LOW_RES: 85,
21:   };
22: 
23:   private static readonly DIMENSIONS = {
24:     HIGH_RES: 400,
25:     LOW_RES: 200,
26:   };
27: 
28:   static async compress(
29:     buffer: Buffer,
30:     isHighRes: boolean = false
31:   ): Promise<CompressionResult> {
32:     try {
33:       const quality = isHighRes ? this.QUALITY.HIGH_RES : this.QUALITY.LOW_RES;
34:       const targetWidth = isHighRes ? this.DIMENSIONS.HIGH_RES : this.DIMENSIONS.LOW_RES;
35: 
36:       const originalInfo = await sharp(buffer).metadata();
37:       const originalSize = buffer.length;
38: 
39:       const image = sharp(buffer).jpeg({
40:         quality,
41:         progressive: true,
42:         mozjpeg: true,
43:       });
44: 
45:       if (originalInfo.width && originalInfo.width > targetWidth) {
46:         image.resize(targetWidth, null, {
47:           fit: "inside",
48:           withoutEnlargement: true,
49:         });
50:       }
51: 
52:       const compressedBuffer = await image.toBuffer();
53:       const compressedInfo = await sharp(compressedBuffer).metadata();
54: 
55:       await logInfo("Image compression complete", {
56:         originalSize,
57:         compressedSize: compressedBuffer.length,
58:         dimensions: `${compressedInfo.width}x${compressedInfo.height}`,
59:         quality,
60:         timestamp: new Date().toISOString(),
61:       });
62: 
63:       return {
64:         buffer: compressedBuffer,
65:         info: {
66:           width: compressedInfo.width || 0,
67:           height: compressedInfo.height || 0,
68:           size: compressedBuffer.length,
69:           format: compressedInfo.format || "jpeg",
70:           quality,
71:         },
72:       };
73:     } catch (error) {
74:       throw new Error(
75:         `Image compression failed: ${error instanceof Error ? error.message : "Unknown error"}`
76:       );
77:     }
78:   }
79: 
80:   static async isCompressible(buffer: Buffer): Promise<boolean> {
81:     try {
82:       const info = await sharp(buffer).metadata();
83:       return info.format === "jpeg" || info.format === "jpg";
84:     } catch {
85:       return false;
86:     }
87:   }
88: }
</file>

<file path="src/utils/imageHandler.ts">
  1: // src/utils/imageHandler.ts
  2: 
  3: import axios, {AxiosError} from "axios";
  4: import {COLLECTION, db} from "../config/firebase";
  5: import {logError, logInfo, logWarning} from "./logger";
  6: import * as crypto from "crypto";
  7: import {GenericError, ImageMetadata, ImageProcessingResult} from "../types";
  8: import {ImageValidator} from "./imageValidator";
  9: import {imageCache} from "./imageCache";
 10: import {ImageCompressor} from "./imageCompressor";
 11: import {r2Storage} from "../services/r2Storage";
 12: 
 13: export interface ImagePathOptions {
 14:   groupId: string;
 15:   productId: number;
 16:   cardNumber: string;
 17:   isHighRes?: boolean;
 18:   isLowRes?: boolean;
 19: }
 20: 
 21: export class ImageHandler {
 22:   private sanitizeCardNumber(cardNumber: string | undefined): string {
 23:     if (!cardNumber) {
 24:       throw new Error("Card number is required");
 25:     }
 26:     return cardNumber.replace(/\//g, "_");
 27:   }
 28: 
 29:   private getHighResUrl(imageUrl: string): string {
 30:     return imageUrl.replace(/_200w\.jpg$/, "_400w.jpg");
 31:   }
 32: 
 33:   private getPublicUrl(path: string): string {
 34:     return r2Storage.getPublicUrl(path);
 35:   }
 36: 
 37:   private getStoragePath(options: ImagePathOptions): string {
 38:     let suffix = "_200w"; // default to low res
 39:     if (options.isHighRes) {
 40:       suffix = "_400w";
 41:     }
 42:     const sanitizedCardNumber = this.sanitizeCardNumber(options.cardNumber);
 43:     const fileName = `${options.productId}_${sanitizedCardNumber}${suffix}.jpg`;
 44:     return `${options.groupId}/${fileName}`;
 45:   }
 46: 
 47:   private async getImageHash(imageBuffer: Buffer): Promise<string> {
 48:     return crypto.createHash("md5").update(imageBuffer).digest("hex");
 49:   }
 50: 
 51:   private async compressImage(
 52:     buffer: Buffer,
 53:     isHighRes: boolean
 54:   ): Promise<Buffer> {
 55:     try {
 56:       const result = await ImageCompressor.compress(buffer, isHighRes);
 57:       await logInfo("Image compression successful", {
 58:         originalSize: buffer.length,
 59:         compressedSize: result.buffer.length,
 60:         quality: result.info.quality,
 61:         dimensions: `${result.info.width}x${result.info.height}`,
 62:         timestamp: new Date().toISOString(),
 63:       });
 64:       return result.buffer;
 65:     } catch (error) {
 66:       await logWarning("Image compression skipped", {
 67:         error: error instanceof Error ? error.message : "Unknown error",
 68:         timestamp: new Date().toISOString(),
 69:       });
 70:       return buffer;
 71:     }
 72:   }
 73: 
 74:   private async downloadImage(url: string): Promise<Buffer> {
 75:     const cacheKey = imageCache.getBufferCacheKey(url);
 76:     const cachedBuffer = await imageCache.getBuffer(cacheKey);
 77: 
 78:     if (cachedBuffer) {
 79:       await logInfo("Using cached image", {
 80:         url,
 81:         size: cachedBuffer.length,
 82:         timestamp: new Date().toISOString(),
 83:       });
 84:       return cachedBuffer;
 85:     }
 86: 
 87:     try {
 88:       await logInfo("Attempting to download image", {
 89:         url,
 90:         timestamp: new Date().toISOString(),
 91:       });
 92: 
 93:       const response = await axios.get(url, {
 94:         responseType: "arraybuffer",
 95:         timeout: 30000,
 96:         headers: {
 97:           "Accept": "image/jpeg",
 98:           "User-Agent": "FFTCG-Sync-Service/1.0",
 99:         },
100:       });
101: 
102:       const buffer = Buffer.from(response.data);
103:       const validationResult = await ImageValidator.validateImage(buffer);
104: 
105:       if (!validationResult.isValid) {
106:         throw new Error(`Image validation failed: ${validationResult.error}`);
107:       }
108: 
109:       imageCache.setBuffer(cacheKey, buffer);
110: 
111:       await logInfo("Successfully downloaded and validated image", {
112:         url,
113:         size: buffer.length,
114:         timestamp: new Date().toISOString(),
115:       });
116: 
117:       return buffer;
118:     } catch (error) {
119:       await logWarning("Failed to download or validate image", {
120:         url,
121:         error: error instanceof Error ? error.message : "Unknown error",
122:         timestamp: new Date().toISOString(),
123:       });
124:       throw error;
125:     }
126:   }
127: 
128:   private async shouldUpdateImage(
129:     options: ImagePathOptions,
130:     imageBuffer: Buffer
131:   ): Promise<boolean> {
132:     if (
133:       process.env.NODE_ENV === "test" ||
134:       process.env.FORCE_UPDATE === "true"
135:     ) {
136:       await logInfo("Force update enabled", {
137:         env: process.env.NODE_ENV,
138:         forceUpdate: process.env.FORCE_UPDATE,
139:         timestamp: new Date().toISOString(),
140:       });
141:       return true;
142:     }
143: 
144:     try {
145:       const storagePath = this.getStoragePath(options);
146:       const exists = await r2Storage.fileExists(storagePath);
147: 
148:       if (!exists) {
149:         await logInfo("Image does not exist in storage", {
150:           path: storagePath,
151:           timestamp: new Date().toISOString(),
152:         });
153:         return true;
154:       }
155: 
156:       const metadata = await r2Storage.getImageMetadata(storagePath);
157:       const currentHash = metadata?.hash;
158:       const newHash = await this.getImageHash(imageBuffer);
159: 
160:       await logInfo("Image hash comparison", {
161:         path: storagePath,
162:         currentHash,
163:         newHash,
164:         needsUpdate: currentHash !== newHash,
165:         timestamp: new Date().toISOString(),
166:       });
167: 
168:       return currentHash !== newHash;
169:     } catch (error) {
170:       await logWarning("Error checking image update status", {
171:         error: error instanceof Error ? error.message : "Unknown error",
172:         timestamp: new Date().toISOString(),
173:       });
174:       return true;
175:     }
176:   }
177: 
178:   private async saveToStorage(
179:     options: ImagePathOptions,
180:     buffer: Buffer,
181:     isHighRes: boolean
182:   ): Promise<string> {
183:     const storagePath = this.getStoragePath({
184:       ...options,
185:       isHighRes,
186:       isLowRes: !isHighRes,
187:     });
188: 
189:     const hash = await this.getImageHash(buffer);
190: 
191:     await logInfo(
192:       `Attempting to save ${isHighRes ? "high-res" : "low-res"} image`,
193:       {
194:         path: storagePath,
195:         size: buffer.length,
196:         hash,
197:         timestamp: new Date().toISOString(),
198:         metadata: {
199:           groupId: options.groupId,
200:           productId: options.productId,
201:           cardNumber: options.cardNumber,
202:         },
203:       }
204:     );
205: 
206:     const url = await r2Storage.uploadImage(storagePath, buffer, {
207:       hash,
208:       type: isHighRes ? "highres" : "original",
209:       updatedAt: new Date().toISOString(),
210:     });
211: 
212:     await logInfo(
213:       `${isHighRes ? "High-res" : "Low-res"} image saved successfully`,
214:       {
215:         path: storagePath,
216:         size: buffer.length,
217:         hash,
218:         url,
219:         timestamp: new Date().toISOString(),
220:       }
221:     );
222: 
223:     return url;
224:   }
225: 
226:   private async saveMetadata(
227:     options: ImagePathOptions,
228:     metadata: ImageMetadata
229:   ): Promise<void> {
230:     const sanitizedCardNumber = this.sanitizeCardNumber(options.cardNumber);
231:     const docRef = db
232:       .collection(COLLECTION.IMAGE_METADATA)
233:       .doc(`${options.groupId}_${options.productId}_${sanitizedCardNumber}`);
234: 
235:     await docRef.set(
236:       {
237:         ...metadata,
238:         groupId: options.groupId,
239:         productId: options.productId,
240:         cardNumber: options.cardNumber,
241:         sanitizedCardNumber,
242:         lastUpdated: new Date(),
243:       },
244:       {merge: true}
245:     );
246: 
247:     await logInfo("Saved image metadata", {
248:       groupId: options.groupId,
249:       productId: options.productId,
250:       cardNumber: options.cardNumber,
251:       sanitizedCardNumber,
252:       metadata,
253:       timestamp: new Date().toISOString(),
254:     });
255:   }
256: 
257:   async processImage(
258:     imageUrl: string,
259:     groupId: string,
260:     productId: number,
261:     cardNumber: string
262:   ): Promise<ImageProcessingResult> {
263:     const options: ImagePathOptions = {
264:       groupId,
265:       productId,
266:       cardNumber,
267:     };
268: 
269:     try {
270:       await logInfo("Starting image processing", {
271:         imageUrl,
272:         groupId,
273:         productId,
274:         cardNumber,
275:         timestamp: new Date().toISOString(),
276:       });
277: 
278:       const highResUrl = this.getHighResUrl(imageUrl);
279:       let highResBuffer: Buffer | null = null;
280:       let lowResBuffer: Buffer | null = null;
281:       let updated = false;
282:       let lowResStorageUrl = "";
283:       let highResStorageUrl = "";
284: 
285:       // Process low-res image
286:       try {
287:         lowResBuffer = await this.downloadImage(imageUrl);
288:         if (lowResBuffer) {
289:           lowResBuffer = await this.compressImage(lowResBuffer, false);
290:           if (
291:             await this.shouldUpdateImage(
292:               {...options, isLowRes: true},
293:               lowResBuffer
294:             )
295:           ) {
296:             lowResStorageUrl = await this.saveToStorage(
297:               options,
298:               lowResBuffer,
299:               false
300:             );
301: 
302:             // Add validation after upload
303:             const lowResPath = this.getStoragePath({
304:               ...options,
305:               isLowRes: true,
306:             });
307:             const lowResValid = await r2Storage.validateUpload(
308:               lowResPath,
309:               lowResBuffer.length
310:             );
311:             if (!lowResValid) {
312:               throw new Error(
313:                 `Low-res image validation failed for ${lowResPath}`
314:               );
315:             }
316: 
317:             updated = true;
318:           } else {
319:             lowResStorageUrl = this.getPublicUrl(
320:               this.getStoragePath({...options, isLowRes: true})
321:             );
322:           }
323:         }
324:       } catch (error) {
325:         await logWarning("Low-res image processing failed", {
326:           error: error instanceof Error ? error.message : "Unknown error",
327:           imageUrl,
328:           groupId,
329:           productId,
330:         });
331:         throw error;
332:       }
333: 
334:       // Process high-res image
335:       try {
336:         highResBuffer = await this.downloadImage(highResUrl);
337:         if (highResBuffer) {
338:           highResBuffer = await this.compressImage(highResBuffer, true);
339:           if (
340:             await this.shouldUpdateImage(
341:               {...options, isHighRes: true},
342:               highResBuffer
343:             )
344:           ) {
345:             highResStorageUrl = await this.saveToStorage(
346:               options,
347:               highResBuffer,
348:               true
349:             );
350: 
351:             // Add validation after upload
352:             const highResPath = this.getStoragePath({
353:               ...options,
354:               isHighRes: true,
355:             });
356:             const highResValid = await r2Storage.validateUpload(
357:               highResPath,
358:               highResBuffer.length
359:             );
360:             if (!highResValid) {
361:               throw new Error(
362:                 `High-res image validation failed for ${highResPath}`
363:               );
364:             }
365: 
366:             updated = true;
367:           } else {
368:             highResStorageUrl = this.getPublicUrl(
369:               this.getStoragePath({...options, isHighRes: true})
370:             );
371:           }
372:         }
373:       } catch (error) {
374:         await logWarning("High-res image processing failed", {
375:           error: error instanceof Error ? error.message : "Unknown error",
376:           imageUrl: highResUrl,
377:           groupId,
378:           productId,
379:         });
380:         throw error;
381:       }
382: 
383:       // Set default storage URLs if not generated
384:       if (!lowResStorageUrl) {
385:         lowResStorageUrl = this.getPublicUrl(
386:           this.getStoragePath({...options, isLowRes: true})
387:         );
388:       }
389:       if (!highResStorageUrl) {
390:         highResStorageUrl = this.getPublicUrl(
391:           this.getStoragePath({...options, isHighRes: true})
392:         );
393:       }
394: 
395:       const metadata: ImageMetadata = {
396:         contentType: "image/jpeg",
397:         size: lowResBuffer?.length || 0,
398:         updated: new Date(),
399:         hash: lowResBuffer ? await this.getImageHash(lowResBuffer) : "",
400:         highResSize: highResBuffer?.length,
401:         lowResSize: lowResBuffer?.length,
402:       };
403: 
404:       await this.saveMetadata(options, metadata);
405: 
406:       await logInfo("Image processing completed", {
407:         productId,
408:         groupId,
409:         updated,
410:         highResUrl: highResStorageUrl,
411:         lowResUrl: lowResStorageUrl,
412:         sizes: {
413:           highRes: highResBuffer?.length,
414:           lowRes: lowResBuffer?.length,
415:         },
416:         timestamp: new Date().toISOString(),
417:       });
418: 
419:       return {
420:         highResUrl: highResStorageUrl,
421:         lowResUrl: lowResStorageUrl,
422:         metadata,
423:         updated,
424:       };
425:     } catch (error) {
426:       const genericError: GenericError = {
427:         message: error instanceof Error ? error.message : "Unknown error",
428:         name: error instanceof Error ? error.name : "UnknownError",
429:         code: error instanceof AxiosError ? error.code : undefined,
430:         stack: error instanceof Error ? error.stack : undefined,
431:       };
432:       await logError(genericError, "processImage");
433:       await r2Storage.rollback();
434:       throw error;
435:     }
436:   }
437: }
438: 
439: export const imageHandler = new ImageHandler();
</file>

<file path="src/utils/imageValidator.ts">
 1: // src/utils/imageValidator.ts
 2: import sharp from "sharp";
 3: import {logInfo, logWarning} from "./logger";
 4: 
 5: export interface ValidationResult {
 6:   isValid: boolean;
 7:   error?: string;
 8:   metadata?: sharp.Metadata;
 9: }
10: 
11: export class ImageValidator {
12:   private static readonly MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB
13:   private static readonly ALLOWED_FORMATS = ["jpeg", "jpg"];
14:   private static readonly REQUIRED_METADATA = [
15:     "format",
16:     "width",
17:     "height",
18:     "size",
19:   ];
20: 
21:   static async validateImage(buffer: Buffer): Promise<ValidationResult> {
22:     try {
23:       // Check file size
24:       if (buffer.length > this.MAX_FILE_SIZE) {
25:         return {
26:           isValid: false,
27:           error: `Image exceeds maximum size of ${
28:             this.MAX_FILE_SIZE / 1024 / 1024
29:           }MB`,
30:         };
31:       }
32: 
33:       // Get image metadata using sharp
34:       const metadata = await sharp(buffer).metadata();
35: 
36:       // Validate format
37:       if (!metadata.format || !this.ALLOWED_FORMATS.includes(metadata.format)) {
38:         return {
39:           isValid: false,
40:           error: `Invalid image format: ${
41:             metadata.format
42:           }. Allowed formats: ${this.ALLOWED_FORMATS.join(", ")}`,
43:         };
44:       }
45: 
46:       // Validate required metadata
47:       const missingMetadata = this.REQUIRED_METADATA.filter(
48:         (field) => !(field in metadata)
49:       );
50:       if (missingMetadata.length > 0) {
51:         return {
52:           isValid: false,
53:           error: `Missing required metadata: ${missingMetadata.join(", ")}`,
54:         };
55:       }
56: 
57:       await logInfo("Image validation successful", {
58:         format: metadata.format,
59:         width: metadata.width,
60:         height: metadata.height,
61:         size: buffer.length,
62:       });
63: 
64:       return {
65:         isValid: true,
66:         metadata,
67:       };
68:     } catch (error) {
69:       await logWarning("Image validation failed", {
70:         error: error instanceof Error ? error.message : "Unknown error",
71:       });
72:       return {
73:         isValid: false,
74:         error:
75:           error instanceof Error ? error.message : "Unknown validation error",
76:       };
77:     }
78:   }
79: }
</file>

<file path="src/utils/logger.ts">
 1: import * as functions from "firebase-functions";
 2: import {db, COLLECTION} from "../config/firebase";
 3: import {GenericError, LogData, GenericObject} from "../types";
 4: 
 5: export const logger = functions.logger;
 6: 
 7: interface LogEntry {
 8:   timestamp: Date;
 9:   level: "INFO" | "WARNING" | "ERROR";
10:   message: string;
11:   context?: string;
12:   data?: Record<string, unknown>;
13: }
14: 
15: function cleanLogData(data: Record<string, unknown>): Record<string, unknown> {
16:   return Object.entries(data).reduce((acc, [key, value]) => {
17:     // Skip undefined and null values
18:     if (value !== undefined && value !== null) {
19:       if (value && typeof value === "object") {
20:         const cleaned = cleanLogData(value as Record<string, unknown>);
21:         // Only add non-empty objects
22:         if (Object.keys(cleaned).length > 0) {
23:           acc[key] = cleaned;
24:         }
25:       } else {
26:         // Convert any specialized types to plain values
27:         acc[key] = value instanceof Date ? value.toISOString() : value;
28:       }
29:     }
30:     return acc;
31:   }, {} as Record<string, unknown>);
32: }
33: 
34: async function saveLogEntry(entry: LogEntry): Promise<void> {
35:   const cleanEntry = {
36:     timestamp: entry.timestamp,
37:     level: entry.level,
38:     message: entry.message,
39:     ...(entry.context && {context: entry.context}),
40:     ...(entry.data && {data: cleanLogData(entry.data)}),
41:   };
42: 
43:   await db.collection(COLLECTION.LOGS).add(cleanEntry);
44: }
45: 
46: export const logError = async (error: GenericError | GenericObject, context: string) => {
47:   const errorData = cleanLogData({
48:     stack: error.stack,
49:     code: error.code,
50:     ...(error as GenericObject),
51:     timestamp: new Date().toISOString(),
52:   });
53: 
54:   const entry: LogEntry = {
55:     timestamp: new Date(),
56:     level: "ERROR",
57:     message: error.message || "Unknown error",
58:     context,
59:     data: errorData,
60:   };
61: 
62:   logger.error(entry.message, errorData);
63:   await saveLogEntry(entry);
64: };
65: 
66: export const logInfo = async (message: string, data?: LogData) => {
67:   const cleanedData = data ? cleanLogData({
68:     ...data,
69:     timestamp: new Date().toISOString(),
70:   }) : undefined;
71: 
72:   const entry: LogEntry = {
73:     timestamp: new Date(),
74:     level: "INFO",
75:     message,
76:     ...(cleanedData && Object.keys(cleanedData).length > 0 && {data: cleanedData}),
77:   };
78: 
79:   logger.info(message, cleanedData);
80:   await saveLogEntry(entry);
81: };
82: 
83: export const logWarning = async (message: string, data?: LogData) => {
84:   const cleanedData = data ? cleanLogData({
85:     ...data,
86:     timestamp: new Date().toISOString(),
87:   }) : undefined;
88: 
89:   const entry: LogEntry = {
90:     timestamp: new Date(),
91:     level: "WARNING",
92:     message,
93:     ...(cleanedData && Object.keys(cleanedData).length > 0 && {data: cleanedData}),
94:   };
95: 
96:   logger.warn(message, cleanedData);
97:   await saveLogEntry(entry);
98: };
</file>

<file path="src/utils/progress.ts">
 1: // src/utils/progress.ts
 2: 
 3: import {logInfo} from "./logger";
 4: 
 5: export interface ProgressStats {
 6:   current: number;
 7:   total: number;
 8:   percent: number;
 9:   elapsed: number;
10:   rate: number;
11:   remaining: number;
12:   eta: number;
13: }
14: 
15: export class EnhancedProgressTracker {
16:   private startTime: number;
17:   private current: number;
18:   private estimates: number[] = [];
19:   private lastUpdate: number;
20:   private updateInterval: number;
21: 
22:   constructor(
23:     private total: number,
24:     private description: string,
25:     options: { updateInterval?: number } = {}
26:   ) {
27:     this.startTime = Date.now();
28:     this.current = 0;
29:     this.lastUpdate = Date.now();
30:     this.updateInterval = options.updateInterval || 1000; // Default 1 second
31:   }
32: 
33:   private calculateStats(): ProgressStats {
34:     const now = Date.now();
35:     const elapsed = (now - this.startTime) / 1000;
36:     const percent = (this.current / this.total) * 100;
37:     const rate = this.current / elapsed;
38:     const remaining = this.total - this.current;
39:     const eta = remaining / rate;
40: 
41:     return {
42:       current: this.current,
43:       total: this.total,
44:       percent,
45:       elapsed,
46:       rate,
47:       remaining,
48:       eta,
49:     };
50:   }
51: 
52:   update(amount = 1): void {
53:     const now = Date.now();
54:     this.current += amount;
55: 
56:     // Only update log if enough time has passed
57:     if (now - this.lastUpdate >= this.updateInterval) {
58:       const stats = this.calculateStats();
59:       this.estimates.push(stats.eta);
60: 
61:       // Keep only last 10 estimates for averaging
62:       if (this.estimates.length > 10) {
63:         this.estimates.shift();
64:       }
65: 
66:       const avgEta = this.estimates.reduce((a, b) => a + b, 0) / this.estimates.length;
67: 
68:       logInfo(
69:         `${this.description}: ${stats.current}/${stats.total} ` +
70:         `(${stats.percent.toFixed(1)}%) - ${stats.remaining} remaining - ` +
71:         `ETA: ${avgEta.toFixed(1)}s - Rate: ${stats.rate.toFixed(1)}/s`
72:       );
73: 
74:       this.lastUpdate = now;
75:     }
76:   }
77: 
78:   getProgress(): ProgressStats {
79:     return this.calculateStats();
80:   }
81: }
</file>

<file path="src/utils/syncLogger.ts">
  1: interface CardDetails {
  2:   id: number;
  3:   name: string;
  4:   groupId: string;
  5:   cardNumber: string;
  6:   normalPrice?: number;
  7:   foilPrice?: number;
  8:   rawPrices: Array<{
  9:     type: string;
 10:     price: number;
 11:     groupId: string;
 12:   }>;
 13:   highResUrl?: string;
 14:   lowResUrl?: string;
 15: }
 16: 
 17: interface SyncLoggerOptions {
 18:   type: "manual" | "scheduled" | "both";
 19:   limit?: number;
 20:   dryRun?: boolean;
 21:   groupId?: string;
 22:   batchSize?: number;
 23: }
 24: 
 25: interface SyncResults {
 26:   success: number;
 27:   failures: number;
 28:   groupId?: string;
 29:   type: string;
 30:   imagesProcessed?: number;
 31:   imagesUpdated?: number;
 32: }
 33: 
 34: export class SyncLogger {
 35:   private startTime: number;
 36:   private cards: CardDetails[] = [];
 37:   private groups: Map<string, { products: number; prices: number }> = new Map();
 38: 
 39:   constructor(private options: SyncLoggerOptions) {
 40:     this.startTime = Date.now();
 41:   }
 42: 
 43:   async start(): Promise<void> {
 44:     console.log("\nStarting sync operation...");
 45:     console.log(`Type: ${this.options.type}`);
 46:     if (this.options.limit) console.log(`Limit: ${this.options.limit} cards`);
 47:     if (this.options.groupId) console.log(`Group ID: ${this.options.groupId}`);
 48:     console.log(`Dry Run: ${this.options.dryRun ? "Yes" : "No"}`);
 49:     console.log("\n=== Processing Data ===");
 50:   }
 51: 
 52:   async logGroupFound(totalGroups: number): Promise<void> {
 53:     if (this.options.groupId) {
 54:       console.log(`Processing group ${this.options.groupId}`);
 55:     } else {
 56:       console.log(`Found ${totalGroups} groups to process`);
 57:     }
 58:   }
 59: 
 60:   async logGroupDetails(
 61:     groupId: string,
 62:     products: number,
 63:     prices: number
 64:   ): Promise<void> {
 65:     if (!this.options.groupId || this.options.groupId === groupId) {
 66:       this.groups.set(groupId, {products, prices});
 67:       console.log(`Group ${groupId}: ${products} products, ${prices} prices`);
 68:     }
 69:   }
 70: 
 71:   async logCardDetails(details: CardDetails): Promise<void> {
 72:     if (!this.options.groupId || this.options.groupId === details.groupId) {
 73:       this.cards.push(details);
 74:       if (this.cards.length === 1) {
 75:         console.log("\n=== Card Details ===");
 76:       }
 77: 
 78:       console.log(`\nCard: ${details.name}`);
 79:       console.log(`ID: ${details.id}`);
 80:       if (details.cardNumber) console.log(`Number: ${details.cardNumber}`);
 81:       console.log(`Group: ${details.groupId}`);
 82: 
 83:       if (details.rawPrices.length > 0) {
 84:         console.log("Prices:");
 85:         details.rawPrices.forEach((price) => {
 86:           console.log(`  ${price.type}: $${price.price.toFixed(2)}`);
 87:         });
 88:       }
 89: 
 90:       if (details.highResUrl || details.lowResUrl) {
 91:         console.log("Images:");
 92:         if (details.highResUrl) {
 93:           console.log(`  High Res: ${details.highResUrl}`);
 94:         }
 95:         if (details.lowResUrl) {
 96:           console.log(`  Low Res: ${details.lowResUrl}`);
 97:         }
 98:       }
 99:     }
100:   }
101: 
102:   async logManualSyncStart(): Promise<void> {
103:     console.log("\n=== Starting Manual Sync ===");
104:     if (this.options.groupId) {
105:       console.log(`Filtering for group: ${this.options.groupId}`);
106:     }
107:     if (this.options.dryRun) {
108:       console.log("DRY RUN MODE - No data will be modified");
109:     }
110:     if (this.options.limit) {
111:       console.log(`Limited to ${this.options.limit} cards`);
112:     }
113:     if (this.options.batchSize) {
114:       console.log(`Batch size: ${this.options.batchSize}`);
115:     }
116:     console.log();
117:   }
118: 
119:   async logSyncResults(results: SyncResults): Promise<void> {
120:     const duration = (Date.now() - this.startTime) / 1000;
121: 
122:     console.log("\n=== Sync Results ===");
123:     console.log(`Operation: ${results.type}`);
124:     if (results.groupId) {
125:       console.log(`Group: ${results.groupId}`);
126:     }
127:     console.log(`Duration: ${duration.toFixed(1)} seconds`);
128:     console.log(`Successful Operations: ${results.success}`);
129:     console.log(`Failed Operations: ${results.failures}`);
130: 
131:     if (typeof results.imagesProcessed === "number") {
132:       console.log("\nImage Processing:");
133:       console.log(`Total Processed: ${results.imagesProcessed}`);
134:       console.log(`Updated: ${results.imagesUpdated || 0}`);
135:       console.log(
136:         `Unchanged: ${results.imagesProcessed - (results.imagesUpdated || 0)}`
137:       );
138:     }
139: 
140:     if (this.cards.length > 0) {
141:       console.log(`\nProcessed Cards: ${this.cards.length}`);
142:       const withImages = this.cards.filter(
143:         (card) => card.highResUrl || card.lowResUrl
144:       ).length;
145:       console.log(`Cards with Images: ${withImages}`);
146:       console.log(`Cards without Images: ${this.cards.length - withImages}`);
147:     }
148:   }
149: 
150:   async finish(): Promise<void> {
151:     const totalDuration = (Date.now() - this.startTime) / 1000;
152:     console.log("\n=== Operation Complete ===");
153:     console.log(`Total Duration: ${totalDuration.toFixed(1)} seconds`);
154: 
155:     if (this.options.dryRun) {
156:       console.log("\nThis was a dry run - no changes were made");
157:       console.log("Remove --dry-run flag to perform actual updates");
158:     }
159:   }
160: }
</file>

<file path="src/utils/syncUtils.ts">
  1: import axios, {AxiosError} from "axios";
  2: import {logWarning} from "./logger";
  3: 
  4: // Centralized constants
  5: export const BASE_URL = "https://tcgcsv.com/tcgplayer";
  6: export const MAX_RETRIES = 3;
  7: export const BASE_DELAY = 1000;
  8: 
  9: /**
 10:  * Validates and constructs full paths for TCGCSV requests.
 11:  */
 12: export function constructTCGCSVPath(endpoint: string): string {
 13:   if (!endpoint.startsWith("/tcgplayer")) {
 14:     throw new Error(
 15:       `Invalid path: ${endpoint}. All paths must start with /tcgplayer.`
 16:     );
 17:   }
 18:   return `${BASE_URL}${endpoint}`;
 19: }
 20: 
 21: /**
 22:  * Validates and fixes document IDs, including promo cards.
 23:  */
 24: export function validateAndFixDocumentId(
 25:   productId: number,
 26:   cardNumber: string
 27: ): string {
 28:   if (!productId || !cardNumber) {
 29:     throw new Error(
 30:       "Missing productId or cardNumber for document ID generation."
 31:     );
 32:   }
 33: 
 34:   const sanitizedCardNumber = cardNumber.replace(/\//g, "_");
 35:   return `${productId}_${sanitizedCardNumber}`;
 36: }
 37: 
 38: /**
 39:  * Handles network requests with retries.
 40:  */
 41: export async function makeRequest<T>(
 42:   endpoint: string,
 43:   options: { retryCount?: number; customDelay?: number } = {}
 44: ): Promise<T> {
 45:   const {retryCount = 0, customDelay = BASE_DELAY} = options;
 46: 
 47:   try {
 48:     const url = constructTCGCSVPath(endpoint);
 49:     await new Promise((resolve) => setTimeout(resolve, customDelay));
 50:     const response = await axios.get<T>(url, {
 51:       timeout: 30000,
 52:       headers: {
 53:         "Accept": "application/json",
 54:         "User-Agent": "FFTCG-Sync-Service/1.0",
 55:       },
 56:     });
 57:     return response.data;
 58:   } catch (error) {
 59:     if (retryCount < MAX_RETRIES - 1 && error instanceof AxiosError) {
 60:       const delay = Math.pow(2, retryCount) * BASE_DELAY;
 61:       await logWarning(`Request failed, retrying in ${delay}ms...`, {
 62:         endpoint,
 63:         attempt: retryCount + 1,
 64:         maxRetries: MAX_RETRIES,
 65:         error: error.message,
 66:       });
 67:       return makeRequest<T>(endpoint, {
 68:         retryCount: retryCount + 1,
 69:         customDelay: delay,
 70:       });
 71:     }
 72:     throw error;
 73:   }
 74: }
 75: 
 76: export async function processBatch<T>(
 77:   items: T[],
 78:   processFn: (batch: T[]) => Promise<void>,
 79:   options: {
 80:     batchSize?: number;
 81:     onBatchComplete?: (stats: {
 82:       processed: number;
 83:       total: number;
 84:     }) => Promise<void>;
 85:   } = {}
 86: ): Promise<void> {
 87:   const batchSize = options.batchSize || 500; // Default batch size
 88:   const totalItems = items.length;
 89: 
 90:   for (let i = 0; i < totalItems; i += batchSize) {
 91:     const batch = items.slice(i, i + batchSize);
 92:     await processFn(batch);
 93: 
 94:     if (options.onBatchComplete) {
 95:       await options.onBatchComplete({
 96:         processed: i + batch.length,
 97:         total: totalItems,
 98:       });
 99:     }
100:   }
101: }
</file>

<file path="tsconfig.dev.json">
1: {
2:   "extends": "./tsconfig.json",
3:   "include": [
4:     ".eslintrc.js",
5:     ".eslintrc.fix.js",
6:     ".eslintrc.base.cjs"
7:   ]
8: }
</file>

<file path="tsconfig.json">
 1: {
 2:   "compilerOptions": {
 3:     "module": "commonjs",
 4:     "noImplicitReturns": true,
 5:     "noUnusedLocals": true,
 6:     "outDir": "lib",
 7:     "sourceMap": true,
 8:     "strict": true,
 9:     "target": "es2017",
10:     "esModuleInterop": true,
11:     "skipLibCheck": true,
12:     "types": ["node", "express"],
13:     "baseUrl": "./src",
14:     "lib": ["es2017", "dom"],
15:     "typeRoots": [
16:       "./node_modules/@types",
17:       "./src/types"
18:     ]
19:   },
20:   "compileOnSave": true,
21:   "include": [
22:     "src/**/*",
23:     ".eslintrc.js",
24:     ".eslintrc.fix.js",
25:     ".eslintrc.base.cjs"
26:   ],
27:   "exclude": [
28:     "node_modules",
29:     "lib"
30:   ]
31: }
</file>

</repository_files>
