This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-04T03:49:33.844Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

- Line numbers have been added to the beginning of each line.
</notes>

<additional_info>

For more information about Repomix, visit: https://github.com/yamadashy/repomix
</additional_info>

</file_summary>

<repository_structure>
.eslintignore
.eslintrc.base.cjs
.eslintrc.fix.js
.eslintrc.js
.firebaserc
.gitignore
.npmrc
.prettierrc
.repomixignore
firebase.json
package.json
repomix.config.json
src/config/environment.ts
src/config/firebase.ts
src/config/r2.ts
src/index.ts
src/scripts/cleanup.ts
src/scripts/prodSync.ts
src/scripts/setenv.ts
src/scripts/syncAll.ts
src/scripts/syncCards.ts
src/scripts/syncPrices.ts
src/scripts/testSync.ts
src/services/cardSync.ts
src/services/priceSync.ts
src/services/storageService.ts
src/types/index.ts
src/utils/api.ts
src/utils/logger.ts
src/utils/retention.ts
src/utils/timeout.ts
tsconfig.dev.json
tsconfig.json
</repository_structure>

<repository_files>
This section contains the contents of the repository's files.

<file path=".eslintignore">
1: node_modules/
2: lib/
3: coverage/
4: *.d.ts
5: *.cjs
</file>

<file path=".eslintrc.base.cjs">
1: module.exports = {
2:     rules: {
3:       "valid-jsdoc": "off",
4:       "require-jsdoc": "off"
5:     }
6:   };
</file>

<file path=".eslintrc.fix.js">
 1: module.exports = {
 2:   extends: "./.eslintrc.js",
 3:   rules: {
 4:     "max-len": ["error", {"code": 120}],
 5:     "valid-jsdoc": 0,
 6:     "require-jsdoc": 0,
 7:     "@typescript-eslint/no-explicit-any": 0,
 8:     "@typescript-eslint/explicit-function-return-type": 0,
 9:     "@typescript-eslint/explicit-module-boundary-types": 0,
10:     "@typescript-eslint/no-unused-vars": ["error", {
11:       "argsIgnorePattern": "^_",
12:       "varsIgnorePattern": "^_",
13:     }],
14:     // Add these additional rules to be extra sure
15:     "jsdoc/require-jsdoc": 0,
16:     "jsdoc/valid-jsdoc": 0,
17:     "jsdoc/require-param-type": 0,
18:     "jsdoc/require-returns": 0,
19:   },
20: };
</file>

<file path=".eslintrc.js">
 1: module.exports = {
 2:   root: true,
 3:   env: {
 4:     es6: true,
 5:     node: true,
 6:   },
 7:   extends: [
 8:     "eslint:recommended",
 9:     "plugin:import/errors",
10:     "plugin:import/warnings",
11:     "plugin:import/typescript",
12:     "google",
13:     "plugin:@typescript-eslint/recommended",
14:   ],
15:   parser: "@typescript-eslint/parser",
16:   parserOptions: {
17:     project: ["tsconfig.json", "tsconfig.dev.json"],
18:     sourceType: "module",
19:   },
20:   ignorePatterns: [
21:     "/lib/**/*",
22:     "/generated/**/*",
23:     "*.js", // Add this line to ignore JS files
24:   ],
25:   plugins: ["@typescript-eslint", "import"],
26:   rules: {
27:     quotes: ["error", "double"],
28:     "import/no-unresolved": 0,
29:     indent: ["error", 2],
30:     "linebreak-style": 0, // Disable linebreak-style checks
31:     "object-curly-spacing": ["error", "always"],
32:     "max-len": ["error", { code: 120 }],
33:     "@typescript-eslint/no-explicit-any": "warn",
34:     "require-jsdoc": 0,
35:     "valid-jsdoc": 0,
36:     "@typescript-eslint/no-var-requires": 0,
37:     camelcase: 0,
38:   },
39: };
</file>

<file path=".firebaserc">
1: {
2:   "projects": {
3:     "default": "fftcg-sync-service"
4:   }
5: }
</file>

<file path=".gitignore">
 1: # Dependencies
 2: node_modules/
 3: 
 4: # Build output
 5: lib/
 6: dist/
 7: 
 8: # Environment variables
 9: .env
10: .env.local
11: .env.*.local
12: 
13: # Service account keys
14: service_account_key.json
15: *-service-account.json
16: 
17: # Firebase
18: .firebase/
19: firebase-debug.log
20: firebase-debug.*.log
21: 
22: # IDE
23: .vscode/
24: .idea/
25: 
26: # Logs
27: *.log
</file>

<file path=".npmrc">
1: //us-central1-npm.pkg.dev/fftcg-sync-service/gcf-artifacts/:_authToken=${NPM_TOKEN}
2: @google-cloud:registry=https://us-central1-npm.pkg.dev/fftcg-sync-service/gcf-artifacts/
</file>

<file path=".prettierrc">
1: {
2:   "singleQuote": false,
3:   "trailingComma": "es5",
4:   "bracketSpacing": true,
5:   "semi": true,
6:   "printWidth": 120,
7:   "tabWidth": 2,
8:   "endOfLine": "auto"
9: }
</file>

<file path=".repomixignore">
1: lib/**
2: !*/
3: !.gitignore
4: service_account_key.json
5: !src/**
</file>

<file path="firebase.json">
 1: {
 2:   "functions": [
 3:     {
 4:       "source": ".",
 5:       "codebase": "default",
 6:       "runtime": "nodejs18",
 7:       "region": "us-central1",
 8:       "ignore": ["node_modules", ".git", "firebase-debug.log", "firebase-debug.*.log", "*.local"],
 9:       "predeploy": [
10:         "npm run lint",
11:         "npm run build"
12:       ]
13:     }
14:   ],
15:   "emulators": {
16:     "functions": {
17:       "port": 5001
18:     },
19:     "firestore": {
20:       "port": 8080
21:     },
22:     "ui": {
23:       "enabled": true
24:     },
25:     "singleProjectMode": true
26:   }
27: }
</file>

<file path="package.json">
 1: {
 2:   "name": "functions",
 3:   "scripts": {
 4:     "lint": "eslint --ext .js,.ts .",
 5:     "lint:fix": "eslint --ext .js,.ts . --fix",
 6:     "build": "rimraf lib && tsc",
 7:     "build:watch": "tsc --watch",
 8:     "serve": "npm run build && firebase emulators:start --only functions,firestore",
 9:     "shell": "npm run build && firebase functions:shell",
10:     "start": "npm run shell",
11:     "deploy": "firebase deploy --only functions",
12:     "logs": "firebase functions:log"
13:   },
14:   "engines": {
15:     "node": "18"
16:   },
17:   "main": "lib/index.js",
18:   "dependencies": {
19:     "@aws-sdk/client-s3": "^3.485.0",
20:     "@aws-sdk/s3-request-presigner": "^3.485.0",
21:     "axios": "^1.7.7",
22:     "cors": "^2.8.5",
23:     "dotenv": "^16.4.7",
24:     "express": "^4.18.2",
25:     "firebase-admin": "^12.0.0",
26:     "firebase-functions": "^6.2.0"
27:   },
28:   "devDependencies": {
29:     "@types/cors": "^2.8.17",
30:     "@types/express": "^4.17.21",
31:     "@typescript-eslint/eslint-plugin": "^5.12.0",
32:     "@typescript-eslint/parser": "^5.12.0",
33:     "eslint": "^8.9.0",
34:     "eslint-config-google": "^0.14.0",
35:     "eslint-plugin-import": "^2.25.4",
36:     "firebase-functions-test": "^3.1.0",
37:     "rimraf": "^5.0.0",
38:     "typescript": "^4.9.0"
39:   },
40:   "private": true,
41:   "publishConfig": {
42:     "registry": "https://us-central1-npm.pkg.dev/fftcg-sync-service/gcf-artifacts/"
43:   }
44: }
</file>

<file path="repomix.config.json">
 1: {
 2:   "output": {
 3:     "filePath": "C:\\VSCode\\fftcg-sync-service\\codebase.xml",
 4:     "style": "xml",
 5:     "removeComments": false,
 6:     "removeEmptyLines": false,
 7:     "topFilesLength": 5,
 8:     "showLineNumbers": true,
 9:     "copyToClipboard": false
10:   },
11:   "include": [],
12:   "ignore": {
13:     "useGitignore": false,
14:     "useDefaultPatterns": true,
15:     "customPatterns": []
16:   },
17:   "security": {
18:     "enableSecurityCheck": true
19:   }
20: }
</file>

<file path="src/config/environment.ts">
 1: // src/config/environment.ts
 2: import * as functions from "firebase-functions";
 3: import * as dotenv from "dotenv";
 4: 
 5: // Load .env file in development
 6: if (process.env.NODE_ENV !== "production") {
 7:   dotenv.config();
 8: }
 9: 
10: // Helper function to get config value
11: function getConfigValue(key: string): string {
12:   if (process.env.NODE_ENV === "production") {
13:     const config = functions.config();
14:     return config.r2?.[key.toLowerCase().replace("r2_", "")] || "";
15:   }
16:   return process.env[key] || "";
17: }
18: 
19: export const environment = {
20:   nodeEnv: process.env.NODE_ENV || "development",
21:   isLocal: process.env.NODE_ENV !== "production",
22:   r2: {
23:     accountId: getConfigValue("R2_ACCOUNT_ID"),
24:     accessKeyId: getConfigValue("R2_ACCESS_KEY_ID"),
25:     secretAccessKey: getConfigValue("R2_SECRET_ACCESS_KEY"),
26:     bucketName: getConfigValue("R2_BUCKET_NAME"),
27:     storagePath: getConfigValue("R2_STORAGE_PATH"),
28:     customDomain: getConfigValue("R2_CUSTOM_DOMAIN"),
29:   } as { [key: string]: string },
30: };
31: 
32: // Validate required environment variables
33: if (!environment.isLocal) {
34:   const required = ["R2_ACCOUNT_ID", "R2_ACCESS_KEY_ID", "R2_SECRET_ACCESS_KEY", "R2_BUCKET_NAME"];
35:   const missing = required.filter((key) => !(environment.r2[key.toLowerCase()] as string));
36:   if (missing.length) {
37:     throw new Error(`Missing required environment variables: ${missing.join(", ")}`);
38:   }
39: }
</file>

<file path="src/config/firebase.ts">
 1: // functions/src/config/firebase.ts
 2: 
 3: import * as admin from "firebase-admin";
 4: 
 5: const app = !admin.apps.length ? admin.initializeApp() : admin.app();
 6: const db = admin.firestore(app);
 7: 
 8: // Enable ignoreUndefinedProperties and other settings
 9: db.settings({
10:   ignoreUndefinedProperties: true,
11:   timestampsInSnapshots: true,
12: });
13: 
14: export { db };
15: 
16: export const COLLECTION = {
17:   CARDS: "cards",
18:   PRICES: "prices",
19:   SYNC_METADATA: "syncMetadata",
20:   LOGS: "logs",
21:   CARD_HASHES: "cardHashes",
22:   PRICE_HASHES: "priceHashes",
23:   IMAGE_METADATA: "imageMetadata",
24:   HISTORICAL_PRICES: "historicalPrices",
25:   PRICE_ARCHIVES: "priceArchives",
26: };
27: 
28: export const BASE_URL = "https://tcgcsv.com/tcgplayer";
29: export const FFTCG_CATEGORY_ID = "24";
30: 
31: export const runtimeOpts = {
32:   timeoutSeconds: 540,
33:   memory: "1GiB",
34: } as const;
</file>

<file path="src/config/r2.ts">
 1: // src/config/r2.ts
 2: 
 3: import * as dotenv from "dotenv";
 4: dotenv.config();
 5: 
 6: export const R2_CONFIG = {
 7:   ACCOUNT_ID: process.env.R2_ACCOUNT_ID || "",
 8:   ACCESS_KEY_ID: process.env.R2_ACCESS_KEY_ID || "",
 9:   SECRET_ACCESS_KEY: process.env.R2_SECRET_ACCESS_KEY || "",
10:   BUCKET_NAME: process.env.R2_BUCKET_NAME || "",
11:   STORAGE_PATH: process.env.R2_STORAGE_PATH || "",
12:   CUSTOM_DOMAIN: process.env.R2_CUSTOM_DOMAIN || "",
13: } as const;
14: 
15: if (!R2_CONFIG.ACCOUNT_ID) {
16:   console.warn("Missing R2_ACCOUNT_ID in .env file");
17: }
18: if (!R2_CONFIG.ACCESS_KEY_ID) {
19:   console.warn("Missing R2_ACCESS_KEY_ID in .env file");
20: }
21: if (!R2_CONFIG.SECRET_ACCESS_KEY) {
22:   console.warn("Missing R2_SECRET_ACCESS_KEY in .env file");
23: }
24: if (!R2_CONFIG.BUCKET_NAME) {
25:   console.warn("Missing R2_BUCKET_NAME in .env file");
26: }
27: if (!R2_CONFIG.STORAGE_PATH) {
28:   console.warn("Missing R2_STORAGE_PATH in .env file");
29: }
30: if (!R2_CONFIG.CUSTOM_DOMAIN) {
31:   console.warn("Missing R2_CUSTOM_DOMAIN in .env file");
32: }
33: 
34: console.log("R2 Config:", R2_CONFIG);
</file>

<file path="src/index.ts">
  1: // src/index.ts
  2: import { onCall, HttpsError } from "firebase-functions/v2/https";
  3: import { onSchedule } from "firebase-functions/v2/scheduler";
  4: import { logger } from "firebase-functions/v2";
  5: import { cardSync } from "./services/cardSync";
  6: import { priceSync } from "./services/priceSync";
  7: import { retention } from "./utils/retention";
  8: import { runtimeOpts } from "./config/firebase";
  9: import * as dotenv from "dotenv";
 10: 
 11: dotenv.config();
 12: 
 13: // Manual card sync endpoint as a callable function
 14: export const manualCardSync = onCall(
 15:   {
 16:     memory: runtimeOpts.memory,
 17:     timeoutSeconds: runtimeOpts.timeoutSeconds,
 18:     region: "us-central1",
 19:   },
 20:   async (request) => {
 21:     try {
 22:       const forceUpdate = request.data.force === true;
 23:       const groupId = request.data.groupId as string | undefined;
 24: 
 25:       const result = await cardSync.syncCards({
 26:         forceUpdate,
 27:         groupId,
 28:         skipImages: false,
 29:         imagesOnly: false,
 30:         silent: false,
 31:         dryRun: false,
 32:       });
 33: 
 34:       return result;
 35:     } catch (error) {
 36:       logger.error("Manual card sync failed", { error });
 37:       throw new HttpsError(
 38:         "internal",
 39:         error instanceof Error ? error.message : "Unknown error"
 40:       );
 41:     }
 42:   }
 43: );
 44: 
 45: // Manual price sync endpoint as a callable function
 46: export const manualPriceSync = onCall(
 47:   {
 48:     memory: runtimeOpts.memory,
 49:     timeoutSeconds: runtimeOpts.timeoutSeconds,
 50:     region: "us-central1",
 51:   },
 52:   async (request) => {
 53:     try {
 54:       const forceUpdate = request.data.force === true;
 55:       const groupId = request.data.groupId as string | undefined;
 56: 
 57:       const result = await priceSync.syncPrices({
 58:         forceUpdate,
 59:         groupId,
 60:         silent: false,
 61:         dryRun: false,
 62:       });
 63: 
 64:       return result;
 65:     } catch (error) {
 66:       logger.error("Manual price sync failed", { error });
 67:       throw new HttpsError(
 68:         "internal",
 69:         error instanceof Error ? error.message : "Unknown error"
 70:       );
 71:     }
 72:   }
 73: );
 74: 
 75: // Manual cleanup endpoint as a callable function
 76: export const manualCleanup = onCall(
 77:   {
 78:     memory: runtimeOpts.memory,
 79:     timeoutSeconds: runtimeOpts.timeoutSeconds,
 80:     region: "us-central1",
 81:   },
 82:   async () => {
 83:     try {
 84:       await retention.cleanOldData();
 85:       return { success: true };
 86:     } catch (error) {
 87:       logger.error("Manual cleanup failed", { error });
 88:       throw new HttpsError(
 89:         "internal",
 90:         error instanceof Error ? error.message : "Unknown error"
 91:       );
 92:     }
 93:   }
 94: );
 95: 
 96: // Scheduled Functions
 97: export const scheduledCardSync = onSchedule(
 98:   {
 99:     schedule: "0 21 * * *", // Daily at 21:00 UTC
100:     timeZone: "UTC",
101:     memory: runtimeOpts.memory,
102:     timeoutSeconds: runtimeOpts.timeoutSeconds,
103:     retryCount: 3,
104:   },
105:   async () => {
106:     try {
107:       logger.info("Starting scheduled card sync");
108:       const result = await cardSync.syncCards({
109:         forceUpdate: false,
110:         skipImages: false,
111:         imagesOnly: false,
112:         silent: false,
113:         dryRun: false,
114:       });
115:       logger.info("Card sync completed", result);
116:     } catch (error) {
117:       logger.error("Scheduled card sync failed", { error });
118:       throw error;
119:     }
120:   }
121: );
122: 
123: export const scheduledPriceSync = onSchedule(
124:   {
125:     schedule: "30 21 * * *", // Daily at 21:30 UTC
126:     timeZone: "UTC",
127:     memory: runtimeOpts.memory,
128:     timeoutSeconds: runtimeOpts.timeoutSeconds,
129:     retryCount: 3,
130:   },
131:   async () => {
132:     try {
133:       logger.info("Starting scheduled price sync");
134:       const result = await priceSync.syncPrices({
135:         forceUpdate: false,
136:         silent: false,
137:         dryRun: false,
138:       });
139:       logger.info("Price sync completed", result);
140:     } catch (error) {
141:       logger.error("Scheduled price sync failed", { error });
142:       throw error;
143:     }
144:   }
145: );
146: 
147: export const scheduledCleanup = onSchedule(
148:   {
149:     schedule: "0 22 * * *", // Daily at 22:00 UTC
150:     timeZone: "UTC",
151:     memory: runtimeOpts.memory,
152:     timeoutSeconds: runtimeOpts.timeoutSeconds,
153:     retryCount: 3,
154:   },
155:   async () => {
156:     try {
157:       logger.info("Starting scheduled cleanup");
158:       await retention.cleanOldData();
159:       logger.info("Cleanup completed");
160:     } catch (error) {
161:       logger.error("Scheduled cleanup failed", { error });
162:       throw error;
163:     }
164:   }
165: );
</file>

<file path="src/scripts/cleanup.ts">
 1: import { retention } from "../utils/retention";
 2: 
 3: async function main() {
 4:   console.log("Starting manual cleanup...");
 5:   try {
 6:     await retention.cleanOldData();
 7:     console.log("Cleanup completed successfully");
 8:   } catch (error) {
 9:     console.error("Cleanup failed:", error);
10:     process.exit(1);
11:   }
12: }
13: 
14: main();
</file>

<file path="src/scripts/prodSync.ts">
  1: // src/scripts/prodSync.ts
  2: import { cardSync } from "../services/cardSync";
  3: import { priceSync } from "../services/priceSync";
  4: import { logger, LogData } from "../utils/logger";
  5: 
  6: 
  7: interface SyncStats {
  8:   success: boolean;
  9:   itemsProcessed: number;
 10:   itemsUpdated: number;
 11:   errors: string[];
 12:   duration: number;
 13: }
 14: 
 15: interface SyncOptions {
 16:   forceUpdate?: boolean;
 17:   groupId?: string;
 18:   cardsOnly?: boolean;
 19:   pricesOnly?: boolean;
 20: }
 21: 
 22: // Move runProductionSync into a class for better organization
 23: class ProductionSync {
 24:   async run(options: SyncOptions = {}) {
 25:     const startTime = Date.now();
 26:     const results: {
 27:       cards?: SyncStats;
 28:       prices?: SyncStats;
 29:     } = {};
 30: 
 31:     try {
 32:       logger.info("Starting production sync", { options } as LogData);
 33: 
 34:       // Run card sync if not prices-only
 35:       if (!options.pricesOnly) {
 36:         logger.info("Starting card sync...");
 37:         const cardResult = await cardSync.syncCards({
 38:           forceUpdate: options.forceUpdate,
 39:           groupId: options.groupId,
 40:         });
 41: 
 42:         results.cards = {
 43:           success: cardResult.success,
 44:           itemsProcessed: cardResult.itemsProcessed,
 45:           itemsUpdated: cardResult.itemsUpdated,
 46:           errors: cardResult.errors,
 47:           duration: cardResult.timing.duration || 0,
 48:         };
 49: 
 50:         logger.info("Card sync completed", { stats: results.cards } as LogData);
 51:       }
 52: 
 53:       // Run price sync if not cards-only
 54:       if (!options.cardsOnly) {
 55:         logger.info("Starting price sync...");
 56:         const priceResult = await priceSync.syncPrices({
 57:           forceUpdate: options.forceUpdate,
 58:           groupId: options.groupId,
 59:         });
 60: 
 61:         results.prices = {
 62:           success: priceResult.success,
 63:           itemsProcessed: priceResult.itemsProcessed,
 64:           itemsUpdated: priceResult.itemsUpdated,
 65:           errors: priceResult.errors,
 66:           duration: priceResult.timing.duration || 0,
 67:         };
 68: 
 69:         logger.info("Price sync completed", { stats: results.prices } as LogData);
 70:       }
 71: 
 72:       const totalDuration = (Date.now() - startTime) / 1000;
 73:       logger.info(`Full sync completed in ${totalDuration}s`, { results } as LogData);
 74: 
 75:       return results;
 76:     } catch (error) {
 77:       logger.error("Production sync failed", { error } as LogData);
 78:       throw error;
 79:     }
 80:   }
 81: }
 82: 
 83: function parseArgs(args: string[]): SyncOptions {
 84:   const options: SyncOptions = {};
 85: 
 86:   for (let i = 0; i < args.length; i++) {
 87:     switch (args[i]) {
 88:     case "--force":
 89:       options.forceUpdate = true;
 90:       break;
 91:     case "--group":
 92:       options.groupId = args[++i];
 93:       break;
 94:     case "--cards-only":
 95:       options.cardsOnly = true;
 96:       break;
 97:     case "--prices-only":
 98:       options.pricesOnly = true;
 99:       break;
100:     case "--help":
101:       printHelp();
102:       process.exit(0);
103:     }
104:   }
105: 
106:   return options;
107: }
108: 
109: function printHelp() {
110:   console.log(`
111: Usage: npx ts-node src/scripts/prodSync.ts [options]
112: 
113: Options:
114:   --force         Force update all items regardless of changes
115:   --group <id>    Sync specific group ID only
116:   --cards-only    Only sync card data
117:   --prices-only   Only sync price data
118:   --help          Show this help message
119:   
120: Examples:
121:   npx ts-node src/scripts/prodSync.ts
122:   npx ts-node src/scripts/prodSync.ts --force
123:   npx ts-node src/scripts/prodSync.ts --group 23244
124:   npx ts-node src/scripts/prodSync.ts --cards-only
125:   `);
126: }
127: 
128: // Create singleton instance
129: export const productionSync = new ProductionSync();
130: 
131: // Command line execution
132: async function main() {
133:   const args = process.argv.slice(2);
134:   const options = parseArgs(args);
135: 
136:   console.log("Starting production sync with options:", options);
137: 
138:   try {
139:     const results = await productionSync.run(options);
140:     console.log("Sync completed successfully!");
141:     console.log(JSON.stringify(results, null, 2));
142:     process.exit(0);
143:   } catch (error) {
144:     console.error("Sync failed:", error);
145:     process.exit(1);
146:   }
147: }
148: 
149: // Run if called directly
150: if (require.main === module) {
151:   main();
152: }
</file>

<file path="src/scripts/setenv.ts">
 1: // scripts/setenv.ts
 2: import * as dotenv from "dotenv";
 3: import { exec } from "child_process";
 4: import { promisify } from "util";
 5: 
 6: const execAsync = promisify(exec);
 7: 
 8: async function setFirebaseConfig() {
 9:   try {
10:     dotenv.config();
11: 
12:     const config = {
13:       account_id: process.env.R2_ACCOUNT_ID,
14:       access_key_id: process.env.R2_ACCESS_KEY_ID,
15:       secret_access_key: process.env.R2_SECRET_ACCESS_KEY,
16:       bucket_name: process.env.R2_BUCKET_NAME,
17:       storage_path: process.env.R2_STORAGE_PATH,
18:       custom_domain: process.env.R2_CUSTOM_DOMAIN,
19:     };
20: 
21:     // Remove existing config
22:     await execAsync("firebase functions:config:unset r2");
23: 
24:     // Set new config
25:     const configString = Object.entries(config)
26:       .map(([key, value]) => `r2.${key}="${value}"`)
27:       .join(" ");
28: 
29:     await execAsync(`firebase functions:config:set ${configString}`);
30:     console.log("Firebase config updated successfully");
31:   } catch (error) {
32:     console.error("Error setting Firebase config:", error);
33:   }
34: }
35: 
36: setFirebaseConfig();
</file>

<file path="src/scripts/syncAll.ts">
 1: import { cardSync } from "../services/cardSync";
 2: import { priceSync } from "../services/priceSync";
 3: 
 4: async function main() {
 5:   console.log("Starting full sync...");
 6: 
 7:   try {
 8:     console.log("\n1. Running card sync...");
 9:     const cardResult = await cardSync.syncCards();
10:     console.log("Card sync completed:", {
11:       success: cardResult.success,
12:       processed: cardResult.itemsProcessed,
13:       updated: cardResult.itemsUpdated,
14:       errors: cardResult.errors.length,
15:     });
16: 
17:     console.log("\n2. Running price sync...");
18:     const priceResult = await priceSync.syncPrices();
19:     console.log("Price sync completed:", {
20:       success: priceResult.success,
21:       processed: priceResult.itemsProcessed,
22:       updated: priceResult.itemsUpdated,
23:       errors: priceResult.errors.length,
24:     });
25: 
26:     const allErrors = [...cardResult.errors, ...priceResult.errors];
27:     if (allErrors.length > 0) {
28:       console.log("\nErrors encountered:");
29:       allErrors.forEach((error) => console.log(`- ${error}`));
30:     }
31: 
32:     console.log("\nFull sync completed!");
33:   } catch (error) {
34:     console.error("Full sync failed:", error);
35:     process.exit(1);
36:   }
37: }
38: 
39: main();
</file>

<file path="src/scripts/syncCards.ts">
 1: import { cardSync } from "../services/cardSync";
 2: 
 3: async function main() {
 4:   try {
 5:     console.log("Starting manual card sync...");
 6:     const result = await cardSync.syncCards();
 7:     console.log("Card sync completed:", {
 8:       success: result.success,
 9:       processed: result.itemsProcessed,
10:       updated: result.itemsUpdated,
11:       errors: result.errors.length,
12:       duration: `${result.timing.duration}s`,
13:     });
14: 
15:     if (result.errors.length > 0) {
16:       console.log("\nErrors encountered:");
17:       result.errors.forEach((error) => console.log(`- ${error}`));
18:     }
19:   } catch (error) {
20:     console.error("Card sync failed:", error);
21:     process.exit(1);
22:   }
23: }
24: 
25: main();
</file>

<file path="src/scripts/syncPrices.ts">
 1: import { priceSync } from "../services/priceSync";
 2: 
 3: async function main() {
 4:   console.log("Starting manual price sync...");
 5:   try {
 6:     const result = await priceSync.syncPrices();
 7:     console.log("Price sync completed:", {
 8:       success: result.success,
 9:       processed: result.itemsProcessed,
10:       updated: result.itemsUpdated,
11:       errors: result.errors.length,
12:       duration: `${result.timing.duration}s`,
13:     });
14: 
15:     if (result.errors.length > 0) {
16:       console.log("\nErrors encountered:");
17:       result.errors.forEach((error) => console.log(`- ${error}`));
18:     }
19:   } catch (error) {
20:     console.error("Price sync failed:", error);
21:     process.exit(1);
22:   }
23: }
24: 
25: main();
</file>

<file path="src/scripts/testSync.ts">
  1: // src/scripts/testSync.ts
  2: import { cardSync } from "../services/cardSync";
  3: import { priceSync } from "../services/priceSync";
  4: import { logger } from "../utils/logger";
  5: import { withTimeout, TimeoutError } from "../utils/timeout";
  6: import { storageService } from "../services/storageService";
  7: 
  8: const MAX_SYNC_TIME = 30 * 60 * 1000; // 30 minutes
  9: const TEST_GROUP_ID = "23244"; // Dawn of Heroes
 10: const TEST_PRODUCT_ID = 508343; // Example product ID
 11: const IMAGE_BASE_URL = "https://fftcgcompanion.com/card-images";
 12: 
 13: async function testImageProcessing() {
 14:   try {
 15:     logger.info("Testing image processing...");
 16: 
 17:     // Test with a valid image URL using correct format
 18:     const validImageResult = await storageService.processAndStoreImage(
 19:       `${IMAGE_BASE_URL}/${TEST_GROUP_ID}/${TEST_PRODUCT_ID}_200w.jpg`,
 20:       TEST_PRODUCT_ID,
 21:       TEST_GROUP_ID,
 22:       "1-001" // Example card number
 23:     );
 24: 
 25:     logger.info("Valid image processing result:", {
 26:       highResUrl: validImageResult.highResUrl,
 27:       lowResUrl: validImageResult.lowResUrl,
 28:       isPlaceholder: validImageResult.metadata.isPlaceholder,
 29:       originalUrl: validImageResult.metadata.originalUrl,
 30:     });
 31: 
 32:     // Verify the image URLs follow the correct pattern
 33:     const urlPattern = new RegExp(`^${IMAGE_BASE_URL}/.*_[24]00w.jpg$`);
 34:     const isValidImageUrl = urlPattern.test(validImageResult.metadata.originalUrl || "");
 35: 
 36:     if (!isValidImageUrl) {
 37:       logger.error("Image URL pattern does not match expected format", {
 38:         url: validImageResult.metadata.originalUrl,
 39:         expectedPattern: `${IMAGE_BASE_URL}/{groupId}/{productId}_200w.jpg`,
 40:       });
 41:     }
 42: 
 43:     // Test with invalid/missing image (should return placeholder)
 44:     const placeholderResult = await storageService.processAndStoreImage(
 45:       undefined,
 46:       TEST_PRODUCT_ID,
 47:       TEST_GROUP_ID,
 48:       "1-001"
 49:     );
 50: 
 51:     logger.info("Placeholder image result:", {
 52:       highResUrl: placeholderResult.highResUrl,
 53:       lowResUrl: placeholderResult.lowResUrl,
 54:       isPlaceholder: placeholderResult.metadata.isPlaceholder,
 55:     });
 56: 
 57:     return {
 58:       validImage: {
 59:         success: validImageResult.metadata.isPlaceholder !== true,
 60:         correctUrlPattern: isValidImageUrl,
 61:         urls: {
 62:           original: validImageResult.metadata.originalUrl,
 63:           highRes: validImageResult.highResUrl,
 64:           lowRes: validImageResult.lowResUrl,
 65:         },
 66:       },
 67:       placeholderImage: {
 68:         success: placeholderResult.metadata.isPlaceholder === true,
 69:         urls: {
 70:           highRes: placeholderResult.highResUrl,
 71:           lowRes: placeholderResult.lowResUrl,
 72:         },
 73:       },
 74:     };
 75:   } catch (error) {
 76:     logger.error("Image processing test failed:", { error });
 77:     throw error;
 78:   }
 79: }
 80: 
 81: async function testSync() {
 82:   try {
 83:     logger.info("Starting test sync with group " + TEST_GROUP_ID);
 84: 
 85:     // Test image processing first
 86:     logger.info("Testing image processing capabilities...");
 87:     const imageResults = await testImageProcessing();
 88:     logger.info("Image processing test results:", imageResults);
 89: 
 90:     // Monitor card sync with timeout
 91:     const cardResult = await withTimeout(
 92:       cardSync.syncCards({
 93:         groupId: TEST_GROUP_ID,
 94:         forceUpdate: true,
 95:       }),
 96:       MAX_SYNC_TIME
 97:     );
 98: 
 99:     logger.info("Card sync results:", {
100:       processed: cardResult.itemsProcessed,
101:       updated: cardResult.itemsUpdated,
102:       errors: cardResult.errors,
103:       timing: cardResult.timing,
104:     });
105: 
106:     // Monitor price sync with timeout
107:     const priceResult = await withTimeout(
108:       priceSync.syncPrices({
109:         groupId: TEST_GROUP_ID,
110:         forceUpdate: true,
111:       }),
112:       MAX_SYNC_TIME
113:     );
114: 
115:     logger.info("Price sync results:", {
116:       processed: priceResult.itemsProcessed,
117:       updated: priceResult.itemsUpdated,
118:       errors: priceResult.errors,
119:       timing: priceResult.timing,
120:     });
121: 
122:     // Validate results
123:     const validationResults = {
124:       imageProcessing: imageResults,
125:       cardSync: {
126:         success: cardResult.success,
127:         hasUpdates: cardResult.itemsUpdated > 0,
128:         hasErrors: cardResult.errors.length > 0,
129:       },
130:       priceSync: {
131:         success: priceResult.success,
132:         hasUpdates: priceResult.itemsUpdated > 0,
133:         hasErrors: priceResult.errors.length > 0,
134:       },
135:     };
136: 
137:     logger.info("Test validation results:", validationResults);
138: 
139:     // Log any errors
140:     const allErrors = [...cardResult.errors, ...priceResult.errors];
141:     if (allErrors.length > 0) {
142:       logger.error("Errors during sync:", { errors: allErrors });
143:     }
144: 
145:     return validationResults;
146:   } catch (error) {
147:     if (error instanceof TimeoutError) {
148:       logger.error("Sync operation timed out", { error });
149:     } else {
150:       logger.error("Test sync failed:", { error });
151:     }
152:     throw error;
153:   }
154: }
155: 
156: // Execute if run directly
157: if (require.main === module) {
158:   testSync()
159:     .then((results) => {
160:       console.log("Test sync completed successfully!");
161:       console.log("Results:", JSON.stringify(results, null, 2));
162:       process.exit(0);
163:     })
164:     .catch((error) => {
165:       console.error("Test failed:", error);
166:       process.exit(1);
167:     });
168: }
169: 
170: export { testSync, testImageProcessing };
</file>

<file path="src/services/cardSync.ts">
  1: // src/services/cardSync.ts
  2: import { db } from "../config/firebase";
  3: import { tcgcsvApi } from "../utils/api";
  4: import { storageService } from "./storageService";
  5: import { CardProduct, SyncResult, CardHashData, SyncTiming, SyncOptions } from "../types";
  6: import { logger } from "../utils/logger";
  7: import * as crypto from "crypto";
  8: 
  9: export class CardSyncService {
 10:   private readonly CARDS_COLLECTION = "cards";
 11:   private readonly HASH_COLLECTION = "cardHashes";
 12:   private readonly BATCH_SIZE = 5;
 13: 
 14:   private calculateHash(data: CardHashData): string {
 15:     return crypto.createHash("md5").update(JSON.stringify(data)).digest("hex");
 16:   }
 17: 
 18:   private async getStoredHash(productId: number): Promise<string | null> {
 19:     const doc = await db.collection(this.HASH_COLLECTION).doc(productId.toString()).get();
 20:     return doc.exists ? doc.data()?.hash : null;
 21:   }
 22: 
 23:   private async updateStoredHash(productId: number, hash: string): Promise<void> {
 24:     await db.collection(this.HASH_COLLECTION).doc(productId.toString()).set({
 25:       hash,
 26:       lastUpdated: new Date(),
 27:     });
 28:   }
 29: 
 30:   private getCardNumbers(card: CardProduct): string[] {
 31:     const numbers: string[] = [];
 32: 
 33:     // Get all number fields from extended data
 34:     card.extendedData
 35:       .filter((data) => data.name === "Number")
 36:       .forEach((numberField) => {
 37:         // Split on common separators and trim
 38:         const vals = numberField.value.split(/[,;/]/).map((n) => n.trim());
 39:         numbers.push(...vals);
 40:       });
 41: 
 42:     // If no numbers found, use product ID
 43:     if (numbers.length === 0) {
 44:       numbers.push(`P${card.productId}`);
 45:     }
 46: 
 47:     return [...new Set(numbers)]; // Remove duplicates
 48:   }
 49: 
 50:   private getDocumentIds(card: CardProduct): string[] {
 51:     return this.getCardNumbers(card).map((num) => `${card.productId}_${num}`);
 52:   }
 53: 
 54:   private isNonCardProduct(card: CardProduct): boolean {
 55:     const cardType = card.extendedData.find((data) => data.name === "CardType")?.value;
 56:     return !cardType || cardType.toLowerCase() === "sealed product";
 57:   }
 58: 
 59:   private updateTiming(timing: SyncTiming): void {
 60:     timing.lastUpdateTime = new Date();
 61:     if (timing.startTime) {
 62:       timing.duration = (timing.lastUpdateTime.getTime() - timing.startTime.getTime()) / 1000;
 63:     }
 64:   }
 65: 
 66:   private async processCardBatch(
 67:     cards: CardProduct[],
 68:     groupId: string,
 69:     options: { forceUpdate?: boolean } = {}
 70:   ): Promise<{
 71:     processed: number;
 72:     updated: number;
 73:     errors: string[];
 74:   }> {
 75:     const result = {
 76:       processed: 0,
 77:       updated: 0,
 78:       errors: [] as string[],
 79:     };
 80: 
 81:     const batches = [];
 82:     for (let i = 0; i < cards.length; i += this.BATCH_SIZE) {
 83:       batches.push(cards.slice(i, i + this.BATCH_SIZE));
 84:     }
 85: 
 86:     for (const batch of batches) {
 87:       try {
 88:         await Promise.all(
 89:           batch.map(async (card) => {
 90:             try {
 91:               result.processed++;
 92: 
 93:               const relevantData: CardHashData = {
 94:                 name: card.name,
 95:                 cleanName: card.cleanName,
 96:                 modifiedOn: card.modifiedOn,
 97:                 extendedData: card.extendedData,
 98:               };
 99:               const currentHash = this.calculateHash(relevantData);
100:               const storedHash = await this.getStoredHash(card.productId);
101: 
102:               if (currentHash === storedHash && !options.forceUpdate) {
103:                 logger.info(`Skipping card ${card.productId} - no changes`);
104:                 return;
105:               }
106: 
107:               const cardNumbers = this.getCardNumbers(card);
108:               const documentIds = this.getDocumentIds(card);
109:               const primaryCardNumber = cardNumbers[0];
110: 
111:               const imageResult = await storageService.processAndStoreImage(
112:                 card.imageUrl,
113:                 card.productId,
114:                 groupId,
115:                 primaryCardNumber
116:               );
117: 
118:               const cardDoc = {
119:                 ...card,
120:                 imageUrl: undefined,
121:                 highResUrl: imageResult.highResUrl,
122:                 lowResUrl: imageResult.lowResUrl,
123:                 imageMetadata: imageResult.metadata,
124:                 lastUpdated: new Date(),
125:                 groupId: parseInt(groupId),
126:                 isNonCard: this.isNonCardProduct(card),
127:                 cardNumbers: cardNumbers,
128:                 primaryCardNumber: primaryCardNumber,
129:               };
130: 
131:               // Create a batch for multiple document writes
132:               const batch = db.batch();
133:               documentIds.forEach((docId) => {
134:                 batch.set(db.collection(this.CARDS_COLLECTION).doc(docId), cardDoc, { merge: true });
135:               });
136:               await batch.commit();
137: 
138:               await this.updateStoredHash(card.productId, currentHash);
139: 
140:               result.updated++;
141:               logger.info(`Updated card ${card.productId}: ${card.name} with numbers: ${cardNumbers.join(", ")}`);
142:             } catch (error) {
143:               const errorMessage = error instanceof Error ? error.message : "Unknown error";
144:               result.errors.push(`Error processing card ${card.productId}: ${errorMessage}`);
145:               logger.error(`Error processing card ${card.productId}`, { error: errorMessage });
146:             }
147:           })
148:         );
149:       } catch (error) {
150:         const errorMessage = error instanceof Error ? error.message : "Unknown error";
151:         result.errors.push(`Error processing batch: ${errorMessage}`);
152:         logger.error("Error processing batch", { error: errorMessage });
153:       }
154:     }
155: 
156:     return result;
157:   }
158: 
159:   async syncCards(options: SyncOptions = {}): Promise<SyncResult> {
160:     const result: SyncResult = {
161:       success: true,
162:       itemsProcessed: 0,
163:       itemsUpdated: 0,
164:       errors: [],
165:       timing: {
166:         startTime: new Date(),
167:       },
168:     };
169: 
170:     try {
171:       logger.info("Starting card sync", { options });
172: 
173:       const groups = options.groupId ? [{ groupId: options.groupId }] : await tcgcsvApi.getGroups();
174:       logger.info(`Found ${groups.length} groups to process`);
175: 
176:       for (const group of groups) {
177:         result.timing.groupStartTime = new Date();
178:         try {
179:           const cards = await tcgcsvApi.getGroupProducts(group.groupId);
180:           logger.info(`Retrieved ${cards.length} cards for group ${group.groupId}`);
181: 
182:           const batchResult = await this.processCardBatch(cards, group.groupId, options);
183: 
184:           result.itemsProcessed += batchResult.processed;
185:           result.itemsUpdated += batchResult.updated;
186:           result.errors.push(...batchResult.errors);
187: 
188:           this.updateTiming(result.timing);
189:         } catch (error) {
190:           const errorMessage = error instanceof Error ? error.message : "Unknown error";
191:           result.errors.push(`Error processing group ${group.groupId}: ${errorMessage}`);
192:           logger.error(`Error processing group ${group.groupId}`, { error: errorMessage });
193:         }
194:       }
195:     } catch (error) {
196:       result.success = false;
197:       const errorMessage = error instanceof Error ? error.message : "Unknown error";
198:       result.errors.push(`Card sync failed: ${errorMessage}`);
199:       logger.error("Card sync failed", { error: errorMessage });
200:     }
201: 
202:     result.timing.endTime = new Date();
203:     result.timing.duration = (result.timing.endTime.getTime() - result.timing.startTime.getTime()) / 1000;
204: 
205:     logger.logSyncStats({
206:       startTime: result.timing.startTime,
207:       endTime: result.timing.endTime,
208:       totalItems: result.itemsProcessed,
209:       successCount: result.itemsUpdated,
210:       errorCount: result.errors.length,
211:       duration: result.timing.duration,
212:     });
213: 
214:     return result;
215:   }
216: }
217: 
218: export const cardSync = new CardSyncService();
</file>

<file path="src/services/priceSync.ts">
  1: // src/services/priceSync.ts
  2: import { db } from "../config/firebase";
  3: import { tcgcsvApi } from "../utils/api";
  4: import { CardPrice, SyncResult, SyncTiming, SyncOptions } from "../types";
  5: import { logger } from "../utils/logger";
  6: import * as crypto from "crypto";
  7: 
  8: export class PriceSyncService {
  9:   private readonly PRICES_COLLECTION = "prices";
 10:   private readonly HISTORICAL_PRICES_COLLECTION = "historicalPrices";
 11:   private readonly HASH_COLLECTION = "priceHashes";
 12: 
 13:   private calculateHash(price: CardPrice): string {
 14:     const relevantData = {
 15:       normal: price.normal,
 16:       foil: price.foil,
 17:       lastUpdated: price.lastUpdated,
 18:     };
 19:     return crypto.createHash("md5").update(JSON.stringify(relevantData)).digest("hex");
 20:   }
 21: 
 22:   private async getStoredHash(productId: number): Promise<string | null> {
 23:     const doc = await db.collection(this.HASH_COLLECTION).doc(productId.toString()).get();
 24:     return doc.exists ? doc.data()?.hash : null;
 25:   }
 26: 
 27:   private async updateStoredHash(productId: number, hash: string): Promise<void> {
 28:     await db.collection(this.HASH_COLLECTION).doc(productId.toString()).set({
 29:       hash,
 30:       lastUpdated: new Date(),
 31:     });
 32:   }
 33: 
 34:   private validatePrice(price: CardPrice): boolean {
 35:     const validatePriceData = (data: typeof price.normal | typeof price.foil) => {
 36:       if (!data) return false;
 37:       return true; // Accept any price data as valid
 38:     };
 39: 
 40:     const hasValidNormal = price.normal ? validatePriceData(price.normal) : false;
 41:     const hasValidFoil = price.foil ? validatePriceData(price.foil) : false;
 42: 
 43:     return hasValidNormal || hasValidFoil;
 44:   }
 45: 
 46:   private updateTiming(timing: SyncTiming): void {
 47:     timing.lastUpdateTime = new Date();
 48:     if (timing.startTime) {
 49:       timing.duration = (timing.lastUpdateTime.getTime() - timing.startTime.getTime()) / 1000;
 50:     }
 51:     logger.info(`Price sync progress - Duration: ${timing.duration}s`, {
 52:       lastUpdate: timing.lastUpdateTime,
 53:       duration: timing.duration,
 54:     });
 55:   }
 56: 
 57:   private async saveHistoricalPrice(price: CardPrice, groupId: string): Promise<void> {
 58:     const today = new Date();
 59:     today.setHours(0, 0, 0, 0);
 60:     const docId = `${price.productId}_${today.toISOString().split("T")[0]}`;
 61: 
 62:     // Check if we already have today's record
 63:     const docRef = db.collection(this.HISTORICAL_PRICES_COLLECTION).doc(docId);
 64:     const doc = await docRef.get();
 65: 
 66:     if (doc.exists) {
 67:       logger.info(`Historical price for ${price.productId} already exists for today, skipping`);
 68:       return;
 69:     }
 70: 
 71:     const historicalPrice = {
 72:       productId: price.productId,
 73:       groupId,
 74:       date: today,
 75:       ...(price.normal && {
 76:         normal: {
 77:           directLow: price.normal.directLowPrice,
 78:           high: price.normal.highPrice,
 79:           low: price.normal.lowPrice,
 80:           market: price.normal.marketPrice,
 81:           mid: price.normal.midPrice,
 82:         },
 83:       }),
 84:       ...(price.foil && {
 85:         foil: {
 86:           directLow: price.foil.directLowPrice,
 87:           high: price.foil.highPrice,
 88:           low: price.foil.lowPrice,
 89:           market: price.foil.marketPrice,
 90:           mid: price.foil.midPrice,
 91:         },
 92:       }),
 93:     };
 94: 
 95:     await docRef.set(historicalPrice);
 96:     logger.info(`Saved historical price for product ${price.productId} for date ${today.toISOString().split("T")[0]}`);
 97:   }
 98: 
 99:   // src/services/priceSync.ts - Update processPriceBatch method
100:   private async processPriceBatch(
101:     prices: CardPrice[],
102:     groupId: string,
103:     options: { forceUpdate?: boolean } = {}
104:   ): Promise<{
105:   processed: number;
106:   updated: number;
107:   errors: string[];
108: }> {
109:     const result = {
110:       processed: 0,
111:       updated: 0,
112:       errors: [] as string[],
113:     };
114: 
115:     const writeBatch = db.batch();
116:     const updates: Array<() => Promise<void>> = [];
117: 
118:     for (const price of prices) {
119:       try {
120:         result.processed++;
121: 
122:         if (!this.validatePrice(price)) {
123:           logger.info(`Skipping price for product ${price.productId} - no valid price data`);
124:           continue;
125:         }
126: 
127:         const currentHash = this.calculateHash(price);
128:         const storedHash = await this.getStoredHash(price.productId);
129: 
130:         // Always save historical price
131:         updates.push(() => this.saveHistoricalPrice(price, groupId));
132: 
133:         if (currentHash === storedHash && !options.forceUpdate) {
134:           logger.info(`Skipping price update for ${price.productId} - no changes`);
135:           continue;
136:         }
137: 
138:         const priceDoc = {
139:           ...price,
140:           lastUpdated: new Date(),
141:           groupId,
142:         };
143: 
144:         writeBatch.set(
145:           db.collection(this.PRICES_COLLECTION).doc(price.productId.toString()),
146:           priceDoc,
147:           { merge: true }
148:         );
149: 
150:         updates.push(() => this.updateStoredHash(price.productId, currentHash));
151:         result.updated++;
152:       } catch (error) {
153:         const errorMessage = error instanceof Error ? error.message : "Unknown error";
154:         result.errors.push(`Error processing price for product ${price.productId}: ${errorMessage}`);
155:         logger.error(`Error processing price for product ${price.productId}`, { error: errorMessage });
156:       }
157:     }
158: 
159:     try {
160:       await writeBatch.commit();
161:       await Promise.all(updates.map((update) => update()));
162:     } catch (error) {
163:       const errorMessage = error instanceof Error ? error.message : "Unknown error";
164:       result.errors.push(`Error committing batch: ${errorMessage}`);
165:       logger.error("Error committing batch", { error: errorMessage });
166:     }
167: 
168:     return result;
169:   }
170: 
171:   async syncPrices(options: SyncOptions = {}): Promise<SyncResult> {
172:     const result: SyncResult = {
173:       success: true,
174:       itemsProcessed: 0,
175:       itemsUpdated: 0,
176:       errors: [],
177:       timing: {
178:         startTime: new Date(),
179:       },
180:     };
181: 
182:     try {
183:       logger.info("Starting price sync", { options });
184: 
185:       const groups = options.groupId ? [{ groupId: options.groupId }] : await tcgcsvApi.getGroups();
186:       logger.info(`Found ${groups.length} groups to process`);
187: 
188:       for (const group of groups) {
189:         result.timing.groupStartTime = new Date();
190:         try {
191:           const prices = await tcgcsvApi.getGroupPrices(group.groupId);
192:           logger.info(`Retrieved ${prices.length} prices for group ${group.groupId}`);
193: 
194:           const batchResult = await this.processPriceBatch(prices, group.groupId, options);
195: 
196:           result.itemsProcessed += batchResult.processed;
197:           result.itemsUpdated += batchResult.updated;
198:           result.errors.push(...batchResult.errors);
199: 
200:           this.updateTiming(result.timing);
201:         } catch (error) {
202:           const errorMessage = error instanceof Error ? error.message : "Unknown error";
203:           result.errors.push(`Error processing prices for group ${group.groupId}: ${errorMessage}`);
204:           logger.error(`Error processing prices for group ${group.groupId}`, { error: errorMessage });
205:         }
206:       }
207:     } catch (error) {
208:       result.success = false;
209:       const errorMessage = error instanceof Error ? error.message : "Unknown error";
210:       result.errors.push(`Price sync failed: ${errorMessage}`);
211:       logger.error("Price sync failed", { error: errorMessage });
212:     }
213: 
214:     result.timing.endTime = new Date();
215:     result.timing.duration = (result.timing.endTime.getTime() - result.timing.startTime.getTime()) / 1000;
216: 
217:     logger.info(`Price sync completed in ${result.timing.duration}s`, {
218:       processed: result.itemsProcessed,
219:       updated: result.itemsUpdated,
220:       errors: result.errors.length,
221:       timing: result.timing,
222:     });
223: 
224:     return result;
225:   }
226: }
227: 
228: export const priceSync = new PriceSyncService();
</file>

<file path="src/services/storageService.ts">
  1: // src/services/storageService.ts
  2: import { S3Client, PutObjectCommand, HeadObjectCommand } from "@aws-sdk/client-s3";
  3: import axios from "axios";
  4: import { R2_CONFIG } from "../config/r2";
  5: import { logger } from "../utils/logger";
  6: 
  7: interface ImageResult {
  8:   highResUrl: string;
  9:   lowResUrl: string;
 10:   metadata: {
 11:     contentType: string;
 12:     productId: string;
 13:     groupId: string;
 14:     lastUpdated: string;
 15:     isPlaceholder?: boolean;
 16:     originalUrl?: string;
 17:     existingImage?: boolean;
 18:     errorMessage?: string;
 19:   };
 20: }
 21: 
 22: export class StorageService {
 23:   private client: S3Client;
 24:   private readonly bucket: string;
 25:   private readonly customDomain: string;
 26:   private readonly storagePath: string;
 27:   private readonly maxRetries = 3;
 28:   private readonly timeoutMs = 30000; // 30 seconds
 29:   private readonly PLACEHOLDER_URL = "https://fftcgcompanion.com/card-images/image-coming-soon.jpeg";
 30: 
 31:   constructor() {
 32:     this.client = new S3Client({
 33:       region: "auto",
 34:       endpoint: `https://${R2_CONFIG.ACCOUNT_ID}.r2.cloudflarestorage.com`,
 35:       credentials: {
 36:         accessKeyId: R2_CONFIG.ACCESS_KEY_ID,
 37:         secretAccessKey: R2_CONFIG.SECRET_ACCESS_KEY,
 38:       },
 39:       forcePathStyle: true,
 40:     });
 41: 
 42:     this.bucket = R2_CONFIG.BUCKET_NAME;
 43:     this.customDomain = R2_CONFIG.CUSTOM_DOMAIN;
 44:     this.storagePath = R2_CONFIG.STORAGE_PATH;
 45:   }
 46: 
 47:   private isValidImageUrl(url: string | undefined): boolean {
 48:     if (!url) return false;
 49: 
 50:     // Check if it's TCGPlayer's missing image SVG
 51:     if (url.includes("image-missing.svg")) {
 52:       logger.info(`TCGPlayer missing image URL detected: ${url}, using our placeholder`);
 53:       return false;
 54:     }
 55: 
 56:     // Check for TCGPlayer's standard image size patterns
 57:     const validPatterns = [
 58:       "_200w.", // Match _200w followed by any extension
 59:       "_400w.", // Match _400w followed by any extension
 60:       "_1000x1000.", // Match _1000x1000 followed by any extension
 61:     ];
 62: 
 63:     // If URL contains any of our valid patterns, it's a valid TCGPlayer image URL
 64:     const isValidPattern = validPatterns.some((pattern) => url.includes(pattern));
 65: 
 66:     // If URL doesn't match our patterns, consider it invalid
 67:     if (!isValidPattern) {
 68:       logger.info(`Invalid image URL pattern: ${url}, using placeholder`);
 69:       return false;
 70:     }
 71: 
 72:     return true;
 73:   }
 74: 
 75:   private async checkImageExists(path: string): Promise<boolean> {
 76:     try {
 77:       await this.client.send(
 78:         new HeadObjectCommand({
 79:           Bucket: this.bucket,
 80:           Key: path,
 81:         })
 82:       );
 83:       return true;
 84:     } catch (error) {
 85:       return false;
 86:     }
 87:   }
 88: 
 89:   private async validateImage(buffer: Buffer): Promise<boolean> {
 90:     if (buffer.length < 4) return false;
 91: 
 92:     const header = buffer.slice(0, 4);
 93:     // JPEG magic number: FF D8 FF
 94:     const isJPEG = header[0] === 0xff && header[1] === 0xd8 && header[2] === 0xff;
 95:     // PNG magic number: 89 50 4E 47
 96:     const isPNG = header[0] === 0x89 && header[1] === 0x50 && header[2] === 0x4e && header[3] === 0x47;
 97: 
 98:     return isJPEG || isPNG;
 99:   }
100: 
101:   private async downloadImage(url: string, retries = this.maxRetries): Promise<Buffer> {
102:     let lastError: Error | null = null;
103: 
104:     for (let attempt = 0; attempt <= retries; attempt++) {
105:       try {
106:         const response = await axios.get(url, {
107:           responseType: "arraybuffer",
108:           timeout: this.timeoutMs,
109:           headers: {
110:             "User-Agent": "FFTCG-Sync-Service/1.0",
111:             Accept: "image/jpeg,image/png,image/*",
112:           },
113:           maxContentLength: 10 * 1024 * 1024, // 10MB max
114:           validateStatus: (status) => status === 200, // Only accept 200 status
115:         });
116: 
117:         const buffer = Buffer.from(response.data);
118: 
119:         if (await this.validateImage(buffer)) {
120:           return buffer;
121:         } else {
122:           throw new Error("Invalid image format");
123:         }
124:       } catch (error) {
125:         const axiosError = error as { response?: { status?: number } };
126: 
127:         // If we get a 403, this means the image doesn't exist or access is denied
128:         // Don't retry and don't log as error since this is an expected case
129:         if (axiosError?.response?.status === 403) {
130:           logger.info(`Image not available (403) for URL: ${url}`);
131:           throw new Error("IMAGE_NOT_AVAILABLE");
132:         }
133: 
134:         // For other errors, continue with retry logic
135:         lastError = error instanceof Error ? error : new Error(String(error));
136: 
137:         if (attempt === retries) {
138:           logger.error(`Failed to download image after ${retries + 1} attempts`, {
139:             url,
140:             error: lastError.message,
141:             status: axiosError?.response?.status,
142:           });
143:           break;
144:         }
145: 
146:         // Only log retries for non-403 errors
147:         logger.info(`Retrying image download (attempt ${attempt + 1}/${retries})`, {
148:           url,
149:           status: axiosError?.response?.status,
150:         });
151: 
152:         await new Promise((resolve) => setTimeout(resolve, 2000 * Math.pow(2, attempt)));
153:       }
154:     }
155: 
156:     throw lastError || new Error("Download failed after retries");
157:   }
158: 
159:   private async uploadToR2WithRetry(
160:     buffer: Buffer,
161:     path: string,
162:     metadata: Record<string, string>,
163:     retries = this.maxRetries
164:   ): Promise<string> {
165:     let lastError: Error | null = null;
166: 
167:     const stringMetadata = Object.entries(metadata).reduce(
168:       (acc, [key, value]) => ({
169:         ...acc,
170:         [key]: String(value),
171:       }),
172:       {}
173:     );
174: 
175:     for (let attempt = 0; attempt <= retries; attempt++) {
176:       try {
177:         await this.client.send(
178:           new PutObjectCommand({
179:             Bucket: this.bucket,
180:             Key: path,
181:             Body: buffer,
182:             ContentType: "image/jpeg",
183:             Metadata: stringMetadata,
184:             ContentLength: buffer.length,
185:             CacheControl: "public, max-age=31536000",
186:             ACL: "public-read",
187:           })
188:         );
189:         return `${this.customDomain}/${path}`;
190:       } catch (error) {
191:         lastError = error instanceof Error ? error : new Error(String(error));
192:         logger.error(`Upload attempt ${attempt + 1} failed`, {
193:           path,
194:           error: lastError.message,
195:         });
196:         if (attempt === retries) break;
197:         await new Promise((resolve) => setTimeout(resolve, 1000 * (attempt + 1)));
198:       }
199:     }
200: 
201:     throw lastError || new Error("Upload failed after retries");
202:   }
203: 
204:   private getImagePath(groupId: string, cardNumber: string, resolution: "200w" | "400w"): string {
205:     return `${this.storagePath}/${groupId}/${cardNumber}_${resolution}.jpg`;
206:   }
207: 
208:   public async processAndStoreImage(
209:     imageUrl: string | undefined,
210:     productId: number,
211:     groupId: string,
212:     cardNumber: string
213:   ): Promise<ImageResult> {
214:     const baseMetadata = {
215:       productId: productId.toString(),
216:       groupId,
217:       lastUpdated: new Date().toISOString(),
218:       contentType: "image/jpeg",
219:     };
220: 
221:     // Check for valid TCGPlayer URL first
222:     if (!this.isValidImageUrl(imageUrl)) {
223:       logger.info(`Invalid or missing image URL for product ${productId}, using placeholder`);
224:       return {
225:         highResUrl: this.PLACEHOLDER_URL,
226:         lowResUrl: this.PLACEHOLDER_URL,
227:         metadata: {
228:           ...baseMetadata,
229:           isPlaceholder: true,
230:           originalUrl: imageUrl,
231:           errorMessage: "Invalid or missing image URL",
232:         },
233:       };
234:     }
235: 
236:     try {
237:       // Check if images already exist in R2
238:       const highResPath = this.getImagePath(groupId, cardNumber, "400w");
239:       const lowResPath = this.getImagePath(groupId, cardNumber, "200w");
240: 
241:       const [highResExists, lowResExists] = await Promise.all([
242:         this.checkImageExists(highResPath),
243:         this.checkImageExists(lowResPath),
244:       ]);
245: 
246:       // If both images exist, return their URLs
247:       if (highResExists && lowResExists) {
248:         const existingHighResUrl = `${this.customDomain}/${highResPath}`;
249:         const existingLowResUrl = `${this.customDomain}/${lowResPath}`;
250: 
251:         logger.info(`Using existing images for product ${productId}`);
252:         return {
253:           highResUrl: existingHighResUrl,
254:           lowResUrl: existingLowResUrl,
255:           metadata: {
256:             ...baseMetadata,
257:             originalUrl: imageUrl,
258:             existingImage: true,
259:           },
260:         };
261:       }
262: 
263:       try {
264:         const baseUrl = imageUrl || "";
265:         const highResTcgUrl = baseUrl.replace("/fit-in/", "/fit-in/437x437/");
266:         const lowResTcgUrl = baseUrl.replace("/fit-in/", "/fit-in/223x223/");
267: 
268:         const [highResBuffer, lowResBuffer] = await Promise.all([
269:           this.downloadImage(highResTcgUrl),
270:           this.downloadImage(lowResTcgUrl),
271:         ]);
272: 
273:         // Upload both versions to R2
274:         const [storedHighResUrl, storedLowResUrl] = await Promise.all([
275:           this.uploadToR2WithRetry(highResBuffer, highResPath, baseMetadata),
276:           this.uploadToR2WithRetry(lowResBuffer, lowResPath, baseMetadata),
277:         ]);
278: 
279:         return {
280:           highResUrl: storedHighResUrl,
281:           lowResUrl: storedLowResUrl,
282:           metadata: {
283:             ...baseMetadata,
284:             originalUrl: imageUrl,
285:           },
286:         };
287:       } catch (unknownError: unknown) {
288:         const error = unknownError instanceof Error ? unknownError : new Error(String(unknownError));
289: 
290:         // Only log as error if it's not an expected case
291:         if (error.message !== "IMAGE_NOT_AVAILABLE") {
292:           logger.error(`Failed to process images for ${productId}`, { error });
293:         }
294: 
295:         return {
296:           highResUrl: this.PLACEHOLDER_URL,
297:           lowResUrl: this.PLACEHOLDER_URL,
298:           metadata: {
299:             ...baseMetadata,
300:             isPlaceholder: true,
301:             originalUrl: imageUrl,
302:             errorMessage:
303:               error.message === "IMAGE_NOT_AVAILABLE" ? "Image not available from source" : "Image processing failed",
304:           },
305:         };
306:       }
307:     } catch (unknownError: unknown) {
308:       const error = unknownError instanceof Error ? unknownError : new Error(String(unknownError));
309: 
310:       // Only log as error if it's not an expected case
311:       if (error.message !== "IMAGE_NOT_AVAILABLE") {
312:         logger.error(`Failed to process images for ${productId}`, { error });
313:       }
314: 
315:       return {
316:         highResUrl: this.PLACEHOLDER_URL,
317:         lowResUrl: this.PLACEHOLDER_URL,
318:         metadata: {
319:           ...baseMetadata,
320:           isPlaceholder: true,
321:           originalUrl: imageUrl,
322:           errorMessage:
323:             error.message === "IMAGE_NOT_AVAILABLE" ? "Image not available from source" : "Image processing failed",
324:         },
325:       };
326:     }
327:   }
328: }
329: 
330: export const storageService = new StorageService();
</file>

<file path="src/types/index.ts">
 1: export interface CardProduct {
 2:   productId: number;
 3:   name: string;
 4:   cleanName: string;
 5:   imageUrl?: string;
 6:   categoryId: number;
 7:   groupId: number;
 8:   url: string;
 9:   modifiedOn: string;
10:   imageCount: number;
11:   extendedData: Array<{
12:     name: string;
13:     displayName: string;
14:     value: string;
15:   }>;
16: }
17: 
18: export interface CardPrice {
19:   productId: number;
20:   normal?: {
21:     directLowPrice: number | null;
22:     highPrice: number;
23:     lowPrice: number;
24:     marketPrice: number;
25:     midPrice: number;
26:     subTypeName: "Normal";
27:   };
28:   foil?: {
29:     directLowPrice: number | null;
30:     highPrice: number;
31:     lowPrice: number;
32:     marketPrice: number;
33:     midPrice: number;
34:     subTypeName: "Foil";
35:   };
36:   lastUpdated: Date;
37: }
38: 
39: export interface HistoricalPrice {
40:   productId: number;
41:   date: Date;
42:   normal?: {
43:     directLow: number | null;
44:     high: number;
45:     low: number;
46:     market: number;
47:     mid: number;
48:   };
49:   foil?: {
50:     directLow: number | null;
51:     high: number;
52:     low: number;
53:     market: number;
54:     mid: number;
55:   };
56:   groupId: string;
57: }
58: 
59: export interface SyncTiming {
60:   startTime: Date;
61:   endTime?: Date;
62:   duration?: number;
63:   groupStartTime?: Date;
64:   imageStartTime?: Date;
65:   lastUpdateTime?: Date;
66: }
67: 
68: export interface SyncResult {
69:   success: boolean;
70:   itemsProcessed: number;
71:   itemsUpdated: number;
72:   errors: string[];
73:   timing: SyncTiming;
74: }
75: 
76: export interface CardHashData {
77:   name: string;
78:   cleanName: string;
79:   modifiedOn: string;
80:   extendedData: Array<{
81:     name: string;
82:     displayName: string;
83:     value: string;
84:   }>;
85: }
86: 
87: export interface SyncOptions {
88:   groupId?: string;
89:   forceUpdate?: boolean;
90:   skipImages?: boolean;
91:   imagesOnly?: boolean;
92:   silent?: boolean;
93:   dryRun?: boolean;
94: }
</file>

<file path="src/utils/api.ts">
  1: import axios, { AxiosError } from "axios";
  2: import { CardProduct, CardPrice } from "../types";
  3: import { logger } from "./logger";
  4: 
  5: export class TcgcsvApi {
  6:   private readonly baseUrl = "https://tcgcsv.com/tcgplayer";
  7:   private readonly categoryId = "24"; // Final Fantasy TCG
  8: 
  9:   private async makeRequest<T>(endpoint: string): Promise<T> {
 10:     const url = `${this.baseUrl}/${endpoint}`;
 11:     logger.info(`Making request to: ${url}`);
 12: 
 13:     try {
 14:       const response = await axios.get<T>(url, {
 15:         timeout: 30000,
 16:         headers: {
 17:           "Accept": "application/json",
 18:           "User-Agent": "FFTCG-Sync-Service/1.0",
 19:         },
 20:       });
 21:       return response.data;
 22:     } catch (error) {
 23:       if (error instanceof AxiosError && error.response?.status === 403) {
 24:         throw new Error(`Access denied to TCGCSV API at path: ${endpoint}`);
 25:       }
 26:       throw error;
 27:     }
 28:   }
 29: 
 30:   async getGroups(): Promise<Array<{ groupId: string }>> {
 31:     const response = await this.makeRequest<{ results: Array<{ groupId: string }> }>(`${this.categoryId}/groups`);
 32:     logger.info(`Retrieved ${response.results.length} groups`);
 33:     return response.results;
 34:   }
 35: 
 36:   async getGroupProducts(groupId: string): Promise<CardProduct[]> {
 37:     const response = await this.makeRequest<{ results: CardProduct[] }>(`${this.categoryId}/${groupId}/products`);
 38:     logger.info(`Retrieved ${response.results.length} products for group ${groupId}`);
 39: 
 40:     // Transform the results to use correct image URLs
 41:     const products = response.results.map((product) => ({
 42:       ...product,
 43:       // No modification needed, keep original TCGPlayer URL
 44:     }));
 45: 
 46:     return products;
 47:   }
 48: 
 49:   async getGroupPrices(groupId: string): Promise<CardPrice[]> {
 50:     interface RawPriceData {
 51:       productId: number;
 52:       lowPrice: number | null;
 53:       midPrice: number | null;
 54:       highPrice: number | null;
 55:       marketPrice: number | null;
 56:       directLowPrice: number | null;
 57:       subTypeName: string;
 58:     }
 59: 
 60:     interface PriceResponse {
 61:       success: boolean;
 62:       errors: string[];
 63:       results: RawPriceData[];
 64:     }
 65: 
 66:     const response = await this.makeRequest<PriceResponse>(`${this.categoryId}/${groupId}/prices`);
 67:     logger.info(`Retrieved ${response.results.length} prices for group ${groupId}`);
 68: 
 69:     // Group prices by productId
 70:     const priceMap = new Map<number, CardPrice>();
 71: 
 72:     response.results.forEach((price) => {
 73:       const existing = priceMap.get(price.productId) || {
 74:         productId: price.productId,
 75:         lastUpdated: new Date(),
 76:       };
 77: 
 78:       if (price.subTypeName === "Normal") {
 79:         existing.normal = {
 80:           directLowPrice: price.directLowPrice,
 81:           highPrice: price.highPrice || 0,
 82:           lowPrice: price.lowPrice || 0,
 83:           marketPrice: price.marketPrice || 0,
 84:           midPrice: price.midPrice || 0,
 85:           subTypeName: "Normal",
 86:         };
 87:       } else if (price.subTypeName === "Foil") {
 88:         existing.foil = {
 89:           directLowPrice: price.directLowPrice,
 90:           highPrice: price.highPrice || 0,
 91:           lowPrice: price.lowPrice || 0,
 92:           marketPrice: price.marketPrice || 0,
 93:           midPrice: price.midPrice || 0,
 94:           subTypeName: "Foil",
 95:         };
 96:       }
 97: 
 98:       priceMap.set(price.productId, existing);
 99:     });
100: 
101:     return Array.from(priceMap.values());
102:   }
103: }
104: 
105: export const tcgcsvApi = new TcgcsvApi();
</file>

<file path="src/utils/logger.ts">
 1: // src/utils/logger.ts
 2: import { db } from "../config/firebase";
 3: import { environment } from "../config/environment";
 4: import { SyncResult } from "../types";
 5: 
 6: export type LogData = Record<string, unknown>;
 7: 
 8: export interface SyncStats {
 9:   startTime: Date;
10:   endTime?: Date;
11:   totalItems: number;
12:   successCount: number;
13:   errorCount: number;
14:   duration?: number;
15: }
16: 
17: export class Logger {
18:   private readonly COLLECTION = "logs";
19: 
20:   async info(message: string, data?: LogData | SyncResult): Promise<void> {
21:     await this.log("INFO", message, data);
22:   }
23: 
24:   async error(message: string, data?: LogData | { error: unknown }): Promise<void> {
25:     await this.log("ERROR", message, data);
26:   }
27: 
28:   async logSyncStats(stats: SyncStats): Promise<void> {
29:     const duration = stats.endTime ? (stats.endTime.getTime() - stats.startTime.getTime()) / 1000 : undefined;
30: 
31:     const successRate = ((stats.successCount / stats.totalItems) * 100).toFixed(1);
32: 
33:     console.log({
34:       duration: duration ? `${duration}s` : "unknown",
35:       successRate: `${successRate}%`,
36:       totalItems: stats.totalItems,
37:       successful: stats.successCount,
38:       errors: stats.errorCount,
39:     });
40: 
41:     if (!environment.isLocal) {
42:       await db.collection(this.COLLECTION).add({
43:         type: "SYNC_STATS",
44:         timestamp: new Date(),
45:         stats: {
46:           ...stats,
47:           duration,
48:           successRate: parseFloat(successRate),
49:         },
50:       });
51:     }
52:   }
53: 
54:   async log(
55:     level: "INFO" | "ERROR",
56:     message: string,
57:     metadata?: LogData | SyncResult | { error: unknown }
58:   ): Promise<void> {
59:     const entry = {
60:       timestamp: new Date(),
61:       level,
62:       message,
63:       metadata: metadata || null,
64:       environment: environment.nodeEnv,
65:     };
66: 
67:     // Always log to console with appropriate level
68:     const logFn = level === "ERROR" ? console.error : console.log;
69:     logFn(`[${level}] ${message}`, metadata || "");
70: 
71:     // Only log to Firestore if not in local development
72:     if (!environment.isLocal) {
73:       try {
74:         await db.collection(this.COLLECTION).add(entry);
75:       } catch (error) {
76:         console.error("Failed to write log to Firestore:", error);
77:         // Don't throw the error to prevent disrupting the application
78:       }
79:     }
80:   }
81: }
82: 
83: export const logger = new Logger();
</file>

<file path="src/utils/retention.ts">
 1: import { db } from "../config/firebase";
 2: import { logger } from "./logger";
 3: 
 4: export class RetentionService {
 5:   private readonly RETENTION_CONFIG = {
 6:     logs: 7,
 7:     cardHashes: 7,
 8:     priceHashes: 7,
 9:     syncMetadata: 7,
10:   };
11: 
12:   async cleanOldData(): Promise<void> {
13:     try {
14:       logger.info("Starting data retention cleanup");
15: 
16:       for (const [collection, days] of Object.entries(this.RETENTION_CONFIG)) {
17:         const cutoff = new Date();
18:         cutoff.setDate(cutoff.getDate() - days);
19: 
20:         const snapshot = await db.collection(collection).where("lastUpdated", "<", cutoff).get();
21: 
22:         if (!snapshot.empty) {
23:           const batch = db.batch();
24:           snapshot.docs.forEach((doc) => batch.delete(doc.ref));
25:           await batch.commit();
26: 
27:           logger.info(`Cleaned up ${snapshot.size} documents from ${collection}`);
28:         }
29:       }
30: 
31:       logger.info("Data retention cleanup completed");
32:     } catch (error) {
33:       const errorMessage = error instanceof Error ? error.message : "Unknown error";
34:       logger.error("Data retention cleanup failed", { error: errorMessage });
35:       throw error;
36:     }
37:   }
38: }
39: 
40: export const retention = new RetentionService();
</file>

<file path="src/utils/timeout.ts">
 1: // src/utils/timeout.ts
 2: export class TimeoutError extends Error {
 3:   constructor(message: string) {
 4:     super(message);
 5:     this.name = "TimeoutError";
 6:   }
 7: }
 8: 
 9: export function withTimeout<T>(promise: Promise<T>, timeoutMs: number): Promise<T> {
10:   return Promise.race([
11:     promise,
12:     new Promise<T>((_, reject) => {
13:       setTimeout(() => {
14:         reject(new TimeoutError(`Operation timed out after ${timeoutMs}ms`));
15:       }, timeoutMs);
16:     }),
17:   ]);
18: }
</file>

<file path="tsconfig.dev.json">
1: {
2:   "include": [
3:     ".eslintrc.js"
4:   ]
5: }
</file>

<file path="tsconfig.json">
 1: {
 2:   "compilerOptions": {
 3:     "module": "commonjs",
 4:     "moduleResolution": "node",
 5:     "noImplicitReturns": true,
 6:     "noUnusedLocals": true,
 7:     "outDir": "lib",
 8:     "sourceMap": true,
 9:     "strict": true,
10:     "target": "es2017",
11:     "skipLibCheck": true, // Add this line
12:     "esModuleInterop": true, // Make sure this is present
13:     "resolveJsonModule": true, // Add this line
14:     "baseUrl": "./src", // Add this line
15:     "paths": {
16:       // Add this section
17:       "*": ["*"]
18:     }
19:   },
20:   "compileOnSave": true,
21:   "include": ["src"],
22:   "exclude": ["node_modules", "lib"]
23: }
</file>

</repository_files>
