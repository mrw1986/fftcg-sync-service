This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-21T20:55:18.066Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

- Line numbers have been added to the beginning of each line.
</notes>

<additional_info>

For more information about Repomix, visit: https://github.com/yamadashy/repomix
</additional_info>

</file_summary>

<repository_structure>
.eslintrc.fix.js
.eslintrc.js
.firebaserc
firebase.json
firestore.indexes.json
firestore.rules
functions/.eslintignore
functions/.eslintrc.base.cjs
functions/.eslintrc.fix.js
functions/.eslintrc.js
functions/package.json
functions/src/config/firebase.ts
functions/src/global.d.ts
functions/src/index.ts
functions/src/services/cardSync.ts
functions/src/services/priceSync.ts
functions/src/test/testEndpoints.ts
functions/src/test/testSync.ts
functions/src/test/validateSync.ts
functions/src/types/express.d.ts
functions/src/types/index.ts
functions/src/types/node.d.ts
functions/src/utils/batch.ts
functions/src/utils/cache.ts
functions/src/utils/error.ts
functions/src/utils/logger.ts
functions/src/utils/progress.ts
functions/src/utils/request.ts
functions/src/utils/syncLogger.ts
functions/tsconfig.dev.json
functions/tsconfig.json
package.json
storage.rules
tsconfig.json
</repository_structure>

<repository_files>
This section contains the contents of the repository's files.

<file path=".eslintrc.fix.js">
 1: module.exports = {
 2:   extends: "./functions/.eslintrc.js",
 3:   rules: {
 4:     "linebreak-style": ["error", "windows"],
 5:     "quotes": ["error", "double"],
 6:     "indent": ["error", 2],
 7:     "object-curly-spacing": ["error", "always"],
 8:     "max-len": ["error", { "code": 120 }],
 9:     "require-jsdoc": "off",
10:     "valid-jsdoc": "off",
11:     "@typescript-eslint/no-explicit-any": "warn",
12:     "comma-dangle": ["error", "always-multiline"]
13:   },
14: };
</file>

<file path=".eslintrc.js">
1: module.exports = {
2:     root: true,
3:     extends: './functions/.eslintrc.js',
4:   };
</file>

<file path=".firebaserc">
1: {
2:   "projects": {
3:     "default": "fftcg-sync-service"
4:   }
5: }
</file>

<file path="firebase.json">
 1: {
 2:   "firestore": {
 3:     "rules": "firestore.rules",
 4:     "indexes": "firestore.indexes.json"
 5:   },
 6:   "functions": [
 7:     {
 8:       "source": "functions",
 9:       "codebase": "default",
10:       "ignore": [
11:         "node_modules",
12:         ".git",
13:         "firebase-debug.log",
14:         "firebase-debug.*.log",
15:         "*.local"
16:       ],
17:       "predeploy": [
18:         "npm --prefix \"$RESOURCE_DIR\" run lint",
19:         "npm --prefix \"$RESOURCE_DIR\" run build"
20:       ]
21:     }
22:   ],
23:   "storage": {
24:     "rules": "storage.rules"
25:   },
26:   "emulators": {
27:     "functions": {
28:       "port": 5001,
29:       "host": "127.0.0.1"
30:     },
31:     "firestore": {
32:       "port": 8081,
33:       "host": "127.0.0.1"
34:     },
35:     "storage": {
36:       "port": 9199,
37:       "host": "127.0.0.1"
38:     },
39:     "ui": {
40:       "enabled": true,
41:       "port": 4001,
42:       "host": "127.0.0.1"
43:     },
44:     "singleProjectMode": true
45:   }
46: }
</file>

<file path="firestore.indexes.json">
1: {
2:   "indexes": [],
3:   "fieldOverrides": []
4: }
</file>

<file path="firestore.rules">
 1: // firestore.rules
 2: rules_version = '2';
 3: service cloud.firestore {
 4:   match /databases/{database}/documents {
 5:     // Allow read access to all data
 6:     match /{document=**} {
 7:       allow read: true;
 8:       // Only allow write access from Cloud Functions
 9:       allow write: if false;
10:     }
11:   }
12: }
</file>

<file path="functions/.eslintignore">
1: node_modules/
2: lib/
3: coverage/
4: *.d.ts
5: *.cjs
</file>

<file path="functions/.eslintrc.base.cjs">
1: module.exports = {
2:     rules: {
3:       "valid-jsdoc": "off",
4:       "require-jsdoc": "off"
5:     }
6:   };
</file>

<file path="functions/.eslintrc.fix.js">
 1: module.exports = {
 2:   extends: "./.eslintrc.js",
 3:   rules: {
 4:     "max-len": ["error", {"code": 120}],
 5:     "valid-jsdoc": 0,
 6:     "require-jsdoc": 0,
 7:     "@typescript-eslint/no-explicit-any": 0,
 8:     "@typescript-eslint/explicit-function-return-type": 0,
 9:     "@typescript-eslint/explicit-module-boundary-types": 0,
10:     "@typescript-eslint/no-unused-vars": ["error", {
11:       "argsIgnorePattern": "^_",
12:       "varsIgnorePattern": "^_",
13:     }],
14:     // Add these additional rules to be extra sure
15:     "jsdoc/require-jsdoc": 0,
16:     "jsdoc/valid-jsdoc": 0,
17:     "jsdoc/require-param-type": 0,
18:     "jsdoc/require-returns": 0,
19:   },
20: };
</file>

<file path="functions/.eslintrc.js">
 1: module.exports = {
 2:   root: true,
 3:   env: {
 4:     es6: true,
 5:     node: true,
 6:   },
 7:   extends: [
 8:     "eslint:recommended",
 9:     "plugin:import/errors",
10:     "plugin:import/warnings",
11:     "plugin:import/typescript",
12:     "google",
13:     "plugin:@typescript-eslint/recommended",
14:   ],
15:   parser: "@typescript-eslint/parser",
16:   parserOptions: {
17:     project: ["tsconfig.json", "tsconfig.dev.json"],
18:     tsconfigRootDir: __dirname,
19:     sourceType: "module",
20:     createDefaultProgram: true,
21:   },
22:   ignorePatterns: [
23:     "/lib/**/*",
24:     "/generated/**/*",
25:     "node_modules/",
26:     "*.cjs",
27:   ],
28:   plugins: [
29:     "@typescript-eslint",
30:     "import",
31:   ],
32:   rules: {
33:     "quotes": ["error", "double"],
34:     "import/no-unresolved": 0,
35:     "indent": ["error", 2],
36:     "max-len": ["error", {"code": 120}],
37:     "@typescript-eslint/no-explicit-any": "off",
38:     "@typescript-eslint/no-unused-vars": ["error", {
39:       "argsIgnorePattern": "^_",
40:       "varsIgnorePattern": "^_",
41:     }],
42:     "valid-jsdoc": 0,
43:     "require-jsdoc": 0,
44:   },
45:   overrides: [
46:     {
47:       files: ["*.js", "*.cjs"],
48:       rules: {
49:         "@typescript-eslint/no-var-requires": "off",
50:       },
51:     },
52:   ],
53: };
</file>

<file path="functions/package.json">
 1: {
 2:   "name": "functions",
 3:   "scripts": {
 4:     "clean": "rimraf lib",
 5:     "lint": "eslint --ext .js,.ts .",
 6:     "lint:fix": "eslint --ext .js,.ts . --fix",
 7:     "build": "npm run clean && tsc",
 8:     "build:watch": "tsc --watch",
 9:     "serve": "npm run build && firebase emulators:start --only functions,firestore,storage",
10:     "shell": "npm run build && firebase functions:shell",
11:     "start": "npm run shell",
12:     "deploy": "npm run lint:fix && firebase deploy --only functions",
13:     "logs": "firebase functions:log",
14:     "lint:fix:force": "eslint . --ext .js,.ts --fix --config .eslintrc.fix.js"
15:   },
16:   "engines": {
17:     "node": "18"
18:   },
19:   "main": "lib/index.js",
20:   "dependencies": {
21:     "axios": "^1.7.7",
22:     "firebase-admin": "^12.0.0",
23:     "firebase-functions": "^6.1.0",
24:     "lru-cache": "^7.14.1"
25:   },
26:   "devDependencies": {
27:     "@types/express": "^4.17.21",
28:     "@types/node": "^18.19.64",
29:     "@typescript-eslint/eslint-plugin": "^6.0.0",
30:     "@typescript-eslint/parser": "^6.0.0",
31:     "eslint": "^8.0.0",
32:     "eslint-config-google": "^0.14.0",
33:     "eslint-plugin-import": "^2.25.4",
34:     "firebase-functions-test": "^3.1.0",
35:     "rimraf": "^5.0.0",
36:     "typescript": "^4.9.5"
37:   },
38:   "private": true
39: }
</file>

<file path="functions/src/config/firebase.ts">
 1: import * as admin from "firebase-admin";
 2: 
 3: const app = !admin.apps.length ? admin.initializeApp() : admin.app();
 4: const db = admin.firestore(app);
 5: 
 6: // Enable ignoreUndefinedProperties and other settings
 7: db.settings({
 8:   ignoreUndefinedProperties: true,
 9:   timestampsInSnapshots: true,
10: });
11: 
12: const storage = admin.storage(app);
13: 
14: export {db, storage}; // Export storage as well
15: 
16: export const COLLECTION = {
17:   CARDS: "cards",
18:   PRICES: "prices",
19:   SYNC_METADATA: "syncMetadata",
20:   LOGS: "logs",
21:   CARD_HASHES: "cardHashes",
22:   PRICE_HASHES: "priceHashes",
23: };
24: 
25: export const STORAGE = {
26:   BUCKETS: {
27:     CARD_IMAGES: "card-images",
28:   },
29:   PATHS: {
30:     IMAGES: "images",
31:   },
32: };
33: 
34: export const BASE_URL = "https://tcgcsv.com";
35: export const FFTCG_CATEGORY_ID = "24";
36: 
37: export const runtimeOpts = {
38:   timeoutSeconds: 540,
39:   memory: "1GiB", // Changed from "1GB" to "1GiB"
40: } as const;
</file>

<file path="functions/src/global.d.ts">
1: // / <reference types="node" />
2: // / <reference types="express" />
</file>

<file path="functions/src/index.ts">
 1: // src/index.ts
 2: 
 3: import {onRequest} from "firebase-functions/v2/https";
 4: import {onSchedule} from "firebase-functions/v2/scheduler";
 5: import {Request, Response} from "express";
 6: import {syncCards} from "./services/cardSync";
 7: import {syncPrices} from "./services/priceSync";
 8: import {runtimeOpts} from "./config/firebase";
 9: import {SyncOptions} from "./types";
10: 
11: // Scheduled card sync
12: export const scheduledCardSync = onSchedule({
13:   schedule: "0 21 * * *", // Daily at 21:00 UTC
14:   timeZone: "UTC",
15:   memory: runtimeOpts.memory,
16:   timeoutSeconds: runtimeOpts.timeoutSeconds,
17:   retryCount: 3,
18: }, async (_context) => {
19:   await syncCards();
20: });
21: 
22: // Manual card sync endpoint for testing
23: export const testCardSync = onRequest({
24:   timeoutSeconds: runtimeOpts.timeoutSeconds,
25:   memory: runtimeOpts.memory,
26:   maxInstances: 1,
27: }, async (req: Request, res: Response) => {
28:   const options: SyncOptions = {
29:     dryRun: true, // Always true for test endpoint
30:     limit: req.query.limit ? parseInt(req.query.limit as string) : 5, // Default to 5
31:     groupId: req.query.groupId as string,
32:   };
33: 
34:   const result = await syncCards(options);
35:   res.json(result);
36: });
37: 
38: export const manualCardSync = onRequest({
39:   timeoutSeconds: runtimeOpts.timeoutSeconds,
40:   memory: runtimeOpts.memory,
41:   maxInstances: 1,
42: }, async (_req: Request, res: Response) => {
43:   const result = await syncCards({dryRun: false}); // Full sync
44:   res.json(result);
45: });
46: 
47: // Scheduled price sync
48: export const scheduledPriceSync = onSchedule({
49:   schedule: "30 21 * * *", // Daily at 21:30 UTC
50:   timeZone: "UTC",
51:   memory: runtimeOpts.memory,
52:   timeoutSeconds: runtimeOpts.timeoutSeconds,
53:   retryCount: 3,
54: }, async (_context) => {
55:   await syncPrices();
56: });
57: 
58: // Manual price sync endpoint for testing
59: export const testPriceSync = onRequest({
60:   timeoutSeconds: runtimeOpts.timeoutSeconds,
61:   memory: runtimeOpts.memory,
62:   maxInstances: 1,
63: }, async (req: Request, res: Response) => {
64:   const options: SyncOptions = {
65:     dryRun: req.query.dryRun === "true",
66:     limit: req.query.limit ? parseInt(req.query.limit as string) : undefined,
67:     groupId: req.query.groupId as string,
68:     productId: req.query.productId ? parseInt(req.query.productId as string) : undefined,
69:     showAll: req.query.showAll === "true",
70:   };
71: 
72:   const result = await syncPrices(options);
73:   res.json(result);
74: });
75: 
76: // For manually triggering full price sync
77: export const manualPriceSync = onRequest({
78:   timeoutSeconds: runtimeOpts.timeoutSeconds,
79:   memory: runtimeOpts.memory,
80:   maxInstances: 1,
81: }, async (_req: Request, res: Response) => {
82:   const result = await syncPrices();
83:   res.json(result);
84: });
85: 
86: // Health check endpoint
87: export const healthCheck = onRequest({
88:   timeoutSeconds: 10,
89:   memory: "128MiB",
90: }, async (_req: Request, res: Response) => {
91:   res.json({
92:     status: "healthy",
93:     timestamp: new Date().toISOString(),
94:     version: "1.0.0",
95:   });
96: });
</file>

<file path="functions/src/services/cardSync.ts">
  1: import axios, {AxiosError} from "axios";
  2: import {db, COLLECTION, FFTCG_CATEGORY_ID, BASE_URL} from "../config/firebase";
  3: import {
  4:   CardProduct,
  5:   SyncOptions,
  6:   SyncMetadata,
  7:   GenericError,
  8:   CardPrice,
  9: } from "../types";
 10: import {cardCache, getCacheKey} from "../utils/cache";
 11: import {logError, logInfo, logWarning} from "../utils/logger";
 12: import * as crypto from "crypto";
 13: import {SyncLogger} from "../utils/syncLogger";
 14: 
 15: const MAX_RETRIES = 3;
 16: const BASE_DELAY = 1000;
 17: 
 18: interface RequestOptions {
 19:   retryCount?: number;
 20:   customDelay?: number;
 21:   metadata?: Record<string, unknown>;
 22: }
 23: 
 24: class SyncError extends Error implements GenericError {
 25:   code?: string;
 26: 
 27:   constructor(
 28:     message: string,
 29:     code?: string,
 30:     public details?: Record<string, unknown>
 31:   ) {
 32:     super(message);
 33:     this.name = "SyncError";
 34:     this.code = code;
 35:   }
 36: 
 37:   toGenericError(): GenericError {
 38:     return {
 39:       name: this.name,
 40:       message: this.message,
 41:       code: this.code,
 42:       stack: this.stack,
 43:     };
 44:   }
 45: }
 46: 
 47: async function makeRequest<T>(
 48:   endpoint: string,
 49:   options: RequestOptions = {}
 50: ): Promise<T> {
 51:   const {retryCount = 0, customDelay = BASE_DELAY} = options;
 52: 
 53:   try {
 54:     await new Promise((resolve) => setTimeout(resolve, customDelay));
 55:     const url = `${BASE_URL}/${endpoint}`;
 56: 
 57:     await logInfo(`Making request to: ${url}`, {
 58:       attempt: retryCount + 1,
 59:       maxRetries: MAX_RETRIES,
 60:       endpoint,
 61:       ...options.metadata,
 62:     });
 63: 
 64:     const response = await axios.get<T>(url, {
 65:       timeout: 30000,
 66:       headers: {
 67:         "Accept": "application/json",
 68:         "User-Agent": "FFTCG-Sync-Service/1.0",
 69:       },
 70:     });
 71: 
 72:     return response.data;
 73:   } catch (error) {
 74:     if (retryCount < MAX_RETRIES - 1 && error instanceof AxiosError) {
 75:       const delay = Math.pow(2, retryCount) * BASE_DELAY;
 76:       await logWarning(`Request failed, retrying in ${delay}ms...`, {
 77:         error: error.message,
 78:         url: `${BASE_URL}/${endpoint}`,
 79:         attempt: retryCount + 1,
 80:         maxRetries: MAX_RETRIES,
 81:       });
 82: 
 83:       return makeRequest<T>(endpoint, {
 84:         ...options,
 85:         retryCount: retryCount + 1,
 86:         customDelay: delay,
 87:       });
 88:     }
 89: 
 90:     throw new SyncError(
 91:       error instanceof Error ? error.message : "Unknown request error",
 92:       error instanceof AxiosError ? error.code : "UNKNOWN_ERROR",
 93:       {endpoint, ...options.metadata}
 94:     );
 95:   }
 96: }
 97: 
 98: function getDataHash(data: any): string {
 99:   return crypto.createHash("md5")
100:     .update(JSON.stringify(data, Object.keys(data).sort()))
101:     .digest("hex");
102: }
103: 
104: async function processBatch<T>(
105:   items: T[],
106:   processor: (batch: T[]) => Promise<void>,
107:   batchSize: number = 500
108: ): Promise<void> {
109:   for (let i = 0; i < items.length; i += batchSize) {
110:     const batch = items.slice(i, i + batchSize);
111:     await processor(batch);
112:     await new Promise((resolve) => setTimeout(resolve, 100));
113:   }
114: }
115: 
116: async function processGroupProducts(
117:   group: any,
118:   options: SyncOptions,
119:   metadata: SyncMetadata,
120:   existingHashes: Map<string, string>,
121:   logger?: SyncLogger
122: ): Promise<number> {
123:   const groupId = group.groupId.toString();
124:   let processedCards = 0;
125: 
126:   try {
127:     const [productsResponse, pricesResponse] = await Promise.all([
128:       makeRequest<{ results: CardProduct[] }>(
129:         `${FFTCG_CATEGORY_ID}/${groupId}/products`,
130:         {metadata: {groupId, groupName: group.name}}
131:       ),
132:       makeRequest<{ results: CardPrice[] }>(
133:         `${FFTCG_CATEGORY_ID}/${groupId}/prices`,
134:         {metadata: {groupId, groupName: group.name}}
135:       ),
136:     ]);
137: 
138:     const products = productsResponse.results;
139:     const prices = pricesResponse.results;
140: 
141:     // Log group details if logger is available
142:     if (logger) {
143:       await logger.logGroupDetails(groupId, products.length, prices.length);
144:     }
145: 
146:     const groupHash = getDataHash(products);
147:     const existingHash = existingHashes.get(groupId);
148: 
149:     // Log detailed card information if logger is available
150:     if (logger && options.dryRun) {
151:       for (const product of products) {
152:         if (options.limit && processedCards >= options.limit) break;
153: 
154:         const cardPrices = prices.filter((p) => p.productId === product.productId);
155:         await logger.logCardDetails({
156:           id: product.productId,
157:           name: product.name,
158:           groupId: product.groupId.toString(),
159:           normalPrice: cardPrices.find((p) => p.subTypeName === "Normal")?.midPrice,
160:           foilPrice: cardPrices.find((p) => p.subTypeName === "Foil")?.midPrice,
161:           rawPrices: cardPrices.map((p) => ({
162:             type: p.subTypeName,
163:             price: p.midPrice,
164:             groupId: groupId,
165:           })),
166:         });
167:         processedCards++;
168:       }
169:     }
170: 
171:     if (!options.dryRun && (!existingHash || existingHash !== groupHash)) {
172:       metadata.groupsUpdated++;
173: 
174:       await processBatch(products, async (batch) => {
175:         const writeBatch = db.batch();
176: 
177:         for (const product of batch) {
178:           if (options.limit && processedCards >= options.limit) break;
179: 
180:           const cardRef = db.collection(COLLECTION.CARDS)
181:             .doc(product.productId.toString());
182: 
183:           writeBatch.set(cardRef, {
184:             ...product,
185:             lastUpdated: new Date(),
186:             groupHash,
187:           }, {merge: true});
188: 
189:           cardCache.set(getCacheKey("card", product.productId), product);
190:           processedCards++;
191:         }
192: 
193:         const hashRef = db.collection(COLLECTION.CARD_HASHES)
194:           .doc(groupId);
195:         writeBatch.set(hashRef, {
196:           hash: groupHash,
197:           lastUpdated: new Date(),
198:         });
199: 
200:         await writeBatch.commit();
201:       });
202: 
203:       await logInfo(`Updated ${processedCards} cards from group ${groupId}`);
204:     } else {
205:       await logInfo(`No updates needed for group ${groupId} (unchanged)`);
206:     }
207: 
208:     metadata.cardCount += products.length;
209:     return processedCards;
210:   } catch (error) {
211:     const syncError = error instanceof Error ?
212:       new SyncError(error.message, "GROUP_PROCESSING_ERROR", {groupId}) :
213:       new SyncError("Unknown group processing error", "UNKNOWN_ERROR", {groupId});
214: 
215:     const errorMessage = `Error processing group ${groupId}: ${syncError.message}`;
216:     metadata.errors.push(errorMessage);
217:     await logError(syncError.toGenericError(), "processGroupProducts");
218:     return processedCards;
219:   }
220: }
221: 
222: export async function syncCards(options: SyncOptions = {}): Promise<SyncMetadata> {
223:   // Initialize logger only for test/manual syncs
224:   const logger = options.dryRun ? new SyncLogger({
225:     type: "test",
226:     limit: options.limit,
227:     dryRun: options.dryRun,
228:     groupId: options.groupId,
229:   }) : undefined;
230: 
231:   if (logger) await logger.start();
232: 
233:   const startTime = Date.now();
234:   const metadata: SyncMetadata = {
235:     lastSync: new Date(),
236:     status: "in_progress",
237:     cardCount: 0,
238:     type: options.dryRun ? "manual" : "scheduled",
239:     groupsProcessed: 0,
240:     groupsUpdated: 0,
241:     errors: [],
242:   };
243: 
244:   try {
245:     const groupsResponse = await makeRequest<{ results: any[] }>(
246:       `${FFTCG_CATEGORY_ID}/groups`,
247:       {metadata: {operation: "fetchGroups"}}
248:     );
249: 
250:     const groups = groupsResponse.results;
251:     if (logger) await logger.logGroupFound(groups.length);
252:     await logInfo(`Found ${groups.length} groups`);
253: 
254:     let processedCards = 0;
255:     const existingHashes = new Map<string, string>();
256: 
257:     const hashesSnapshot = await db.collection(COLLECTION.CARD_HASHES).get();
258:     hashesSnapshot.forEach((doc) => {
259:       existingHashes.set(doc.id, doc.data().hash);
260:     });
261: 
262:     for (const group of groups) {
263:       if (options.groupId && group.groupId.toString() !== options.groupId) continue;
264: 
265:       metadata.groupsProcessed++;
266:       const groupProcessedCards = await processGroupProducts(
267:         group,
268:         options,
269:         metadata,
270:         existingHashes,
271:         logger
272:       );
273: 
274:       processedCards += groupProcessedCards;
275:       if (options.limit && processedCards >= options.limit) break;
276:     }
277: 
278:     metadata.status = metadata.errors.length > 0 ? "completed_with_errors" : "success";
279: 
280:     if (logger) {
281:       await logger.logSyncResults({
282:         success: processedCards,
283:         failures: metadata.errors.length,
284:         groupId: options.groupId,
285:       });
286:     }
287:   } catch (error) {
288:     const syncError = error instanceof Error ?
289:       new SyncError(error.message, "SYNC_MAIN_ERROR") :
290:       new SyncError("Unknown sync error", "UNKNOWN_ERROR");
291: 
292:     metadata.status = "failed";
293:     metadata.errors.push(syncError.message);
294:     await logError(syncError.toGenericError(), "syncCards:main");
295:   }
296: 
297:   metadata.lastSync = new Date();
298:   metadata.duration = Date.now() - startTime;
299: 
300:   if (!options.dryRun) {
301:     await db.collection(COLLECTION.SYNC_METADATA)
302:       .add(metadata);
303:   }
304: 
305:   if (logger) await logger.finish();
306:   return metadata;
307: }
</file>

<file path="functions/src/services/priceSync.ts">
  1: import axios, {AxiosError} from "axios";
  2: import {db, COLLECTION, FFTCG_CATEGORY_ID, BASE_URL} from "../config/firebase";
  3: import {
  4:   CardPrice,
  5:   SyncOptions,
  6:   SyncMetadata,
  7:   PriceData,
  8:   GenericError,
  9:   CardProduct,
 10: } from "../types";
 11: import {logError, logInfo, logWarning} from "../utils/logger";
 12: import {SyncLogger} from "../utils/syncLogger";
 13: import * as crypto from "crypto";
 14: 
 15: const MAX_RETRIES = 3;
 16: const BASE_DELAY = 1000;
 17: 
 18: interface RequestOptions {
 19:   retryCount?: number;
 20:   customDelay?: number;
 21:   metadata?: Record<string, unknown>;
 22: }
 23: 
 24: class SyncError extends Error implements GenericError {
 25:   code?: string;
 26: 
 27:   constructor(
 28:     message: string,
 29:     code?: string,
 30:     public details?: Record<string, unknown>
 31:   ) {
 32:     super(message);
 33:     this.name = "SyncError";
 34:     this.code = code;
 35:   }
 36: 
 37:   toGenericError(): GenericError {
 38:     return {
 39:       name: this.name,
 40:       message: this.message,
 41:       code: this.code,
 42:       stack: this.stack,
 43:     };
 44:   }
 45: }
 46: 
 47: async function makeRequest<T>(
 48:   endpoint: string,
 49:   options: RequestOptions = {}
 50: ): Promise<T> {
 51:   const {retryCount = 0, customDelay = BASE_DELAY} = options;
 52: 
 53:   try {
 54:     await new Promise((resolve) => setTimeout(resolve, customDelay));
 55:     const url = `${BASE_URL}/${endpoint}`;
 56: 
 57:     await logInfo(`Making request to: ${url}`, {
 58:       attempt: retryCount + 1,
 59:       maxRetries: MAX_RETRIES,
 60:       endpoint,
 61:       ...options.metadata,
 62:     });
 63: 
 64:     const response = await axios.get<T>(url, {
 65:       timeout: 30000,
 66:       headers: {
 67:         "Accept": "application/json",
 68:         "User-Agent": "FFTCG-Sync-Service/1.0",
 69:       },
 70:     });
 71: 
 72:     return response.data;
 73:   } catch (error) {
 74:     if (retryCount < MAX_RETRIES - 1 && error instanceof AxiosError) {
 75:       const delay = Math.pow(2, retryCount) * BASE_DELAY;
 76:       await logWarning(`Request failed, retrying in ${delay}ms...`, {
 77:         error: error.message,
 78:         url: `${BASE_URL}/${endpoint}`,
 79:         attempt: retryCount + 1,
 80:         maxRetries: MAX_RETRIES,
 81:       });
 82: 
 83:       return makeRequest<T>(endpoint, {
 84:         ...options,
 85:         retryCount: retryCount + 1,
 86:         customDelay: delay,
 87:       });
 88:     }
 89: 
 90:     throw new SyncError(
 91:       error instanceof Error ? error.message : "Unknown request error",
 92:       error instanceof AxiosError ? error.code : "UNKNOWN_ERROR",
 93:       {endpoint, ...options.metadata}
 94:     );
 95:   }
 96: }
 97: 
 98: function getDataHash(data: any): string {
 99:   return crypto.createHash("md5")
100:     .update(JSON.stringify(data, Object.keys(data).sort()))
101:     .digest("hex");
102: }
103: 
104: function processPrices(prices: CardPrice[]): Record<number, PriceData> {
105:   const priceMap: Record<number, PriceData> = {};
106: 
107:   prices.forEach((price) => {
108:     if (!priceMap[price.productId]) {
109:       priceMap[price.productId] = {
110:         lastUpdated: new Date(),
111:       };
112:     }
113: 
114:     if (price.subTypeName === "Normal") {
115:       priceMap[price.productId].normal = price;
116:     } else {
117:       priceMap[price.productId].foil = price;
118:     }
119:   });
120: 
121:   return priceMap;
122: }
123: 
124: async function processBatch<T>(
125:   items: T[],
126:   processor: (batch: T[]) => Promise<void>,
127:   batchSize: number = 500
128: ): Promise<void> {
129:   for (let i = 0; i < items.length; i += batchSize) {
130:     const batch = items.slice(i, i + batchSize);
131:     await processor(batch);
132:     await new Promise((resolve) => setTimeout(resolve, 100));
133:   }
134: }
135: 
136: async function processGroupPrices(
137:   group: any,
138:   options: SyncOptions,
139:   metadata: SyncMetadata,
140:   logger?: SyncLogger
141: ): Promise<void> {
142:   const groupId = group.groupId.toString();
143: 
144:   try {
145:     // If specific productId is provided, first verify the card exists
146:     if (options.productId) {
147:       const card = await db.collection(COLLECTION.CARDS)
148:         .doc(options.productId.toString())
149:         .get();
150: 
151:       if (!card.exists) {
152:         throw new SyncError(
153:           `Card with ID ${options.productId} not found`,
154:           "CARD_NOT_FOUND",
155:           {productId: options.productId}
156:         );
157:       }
158: 
159:       const cardData = card.data();
160:       if (cardData?.groupId?.toString() !== groupId) {
161:         return; // Skip this group if it doesn't contain the requested product
162:       }
163:     }
164: 
165:     // Fetch both products and prices for detailed logging
166:     const [productsResponse, pricesResponse] = await Promise.all([
167:       makeRequest<{ results: CardProduct[] }>(
168:         `${FFTCG_CATEGORY_ID}/${groupId}/products`,
169:         {metadata: {groupId, groupName: group.name}}
170:       ),
171:       makeRequest<{ results: CardPrice[] }>(
172:         `${FFTCG_CATEGORY_ID}/${groupId}/prices`,
173:         {metadata: {groupId, groupName: group.name}}
174:       ),
175:     ]);
176: 
177:     const products = productsResponse.results;
178:     let prices = pricesResponse.results;
179: 
180:     if (logger) {
181:       await logger.logGroupDetails(groupId, products.length, prices.length);
182:     }
183: 
184:     // Filter for specific product if requested
185:     if (options.productId) {
186:       prices = prices.filter((p) => p.productId === options.productId);
187:       if (prices.length === 0) {
188:         throw new SyncError(
189:           `No prices found for product ${options.productId}`,
190:           "NO_PRICES_FOUND",
191:           {productId: options.productId}
192:         );
193:       }
194:     }
195: 
196:     const priceHash = getDataHash(prices);
197:     const hashDoc = await db.collection(COLLECTION.PRICE_HASHES)
198:       .doc(groupId)
199:       .get();
200: 
201:     const existingHash = hashDoc.exists ? hashDoc.data()?.hash : null;
202: 
203:     // Log detailed price information if logger is available
204:     if (logger && options.dryRun) {
205:       for (const product of products) {
206:         const cardPrices = prices.filter((p) => p.productId === product.productId);
207:         if (cardPrices.length > 0) {
208:           await logger.logCardDetails({
209:             id: product.productId,
210:             name: product.name,
211:             groupId: groupId,
212:             normalPrice: cardPrices.find((p) => p.subTypeName === "Normal")?.midPrice,
213:             foilPrice: cardPrices.find((p) => p.subTypeName === "Foil")?.midPrice,
214:             rawPrices: cardPrices.map((p) => ({
215:               type: p.subTypeName,
216:               price: p.midPrice,
217:               groupId: groupId,
218:             })),
219:           });
220:         }
221:       }
222:     }
223: 
224:     if (!options.dryRun && (!existingHash || existingHash !== priceHash)) {
225:       metadata.groupsUpdated++;
226:       const processedPrices = processPrices(prices);
227: 
228:       await processBatch(
229:         Object.entries(processedPrices),
230:         async (batch) => {
231:           const writeBatch = db.batch();
232: 
233:           for (const [productId, priceData] of batch) {
234:             if (options.limit && metadata.cardCount >= options.limit) break;
235: 
236:             const priceRef = db.collection(COLLECTION.PRICES)
237:               .doc(productId);
238:             writeBatch.set(priceRef, priceData, {merge: true});
239: 
240:             metadata.cardCount++;
241:           }
242: 
243:           // Update hash
244:           const hashRef = db.collection(COLLECTION.PRICE_HASHES)
245:             .doc(groupId);
246:           writeBatch.set(hashRef, {
247:             hash: priceHash,
248:             lastUpdated: new Date(),
249:           });
250: 
251:           await writeBatch.commit();
252:         }
253:       );
254: 
255:       await logInfo(`Updated ${metadata.cardCount} prices from group ${groupId}`);
256:     } else {
257:       await logInfo(`No updates needed for group ${groupId} (unchanged)`);
258:     }
259:   } catch (error) {
260:     const syncError = error instanceof SyncError ? error :
261:       error instanceof Error ?
262:         new SyncError(error.message, "GROUP_PROCESSING_ERROR", {groupId}) :
263:         new SyncError("Unknown group processing error", "UNKNOWN_ERROR", {groupId});
264: 
265:     const errorMessage = `Error processing group ${groupId}: ${syncError.message}`;
266:     metadata.errors.push(errorMessage);
267:     await logError(syncError.toGenericError(), "processGroupPrices");
268:   }
269: }
270: 
271: export async function syncPrices(options: SyncOptions = {}): Promise<SyncMetadata> {
272:   // Initialize logger only for test/manual syncs
273:   const logger = options.dryRun ? new SyncLogger({
274:     type: "test",
275:     limit: options.limit,
276:     dryRun: options.dryRun,
277:     groupId: options.groupId,
278:   }) : undefined;
279: 
280:   if (logger) await logger.start();
281: 
282:   const startTime = Date.now();
283:   const metadata: SyncMetadata = {
284:     lastSync: new Date(),
285:     status: "in_progress",
286:     cardCount: 0,
287:     type: options.dryRun ? "manual" : "scheduled",
288:     groupsProcessed: 0,
289:     groupsUpdated: 0,
290:     errors: [],
291:   };
292: 
293:   try {
294:     const groupsResponse = await makeRequest<{ results: any[] }>(
295:       `${FFTCG_CATEGORY_ID}/groups`,
296:       {metadata: {operation: "fetchGroups"}}
297:     );
298: 
299:     const groups = groupsResponse.results;
300:     if (logger) await logger.logGroupFound(groups.length);
301: 
302:     // Filter to specific group if provided
303:     if (options.groupId) {
304:       const group = groups.find((g) => g.groupId.toString() === options.groupId);
305:       if (!group) {
306:         throw new SyncError(
307:           `Group ${options.groupId} not found`,
308:           "GROUP_NOT_FOUND",
309:           {groupId: options.groupId}
310:         );
311:       }
312:       groups.length = 0;
313:       groups.push(group);
314:     }
315: 
316:     // Process each group
317:     for (const group of groups) {
318:       metadata.groupsProcessed++;
319:       await processGroupPrices(group, options, metadata, logger);
320: 
321:       if (options.limit && metadata.cardCount >= options.limit) break;
322:     }
323: 
324:     metadata.status = metadata.errors.length > 0 ? "completed_with_errors" : "success";
325: 
326:     if (logger) {
327:       await logger.logSyncResults({
328:         success: metadata.cardCount,
329:         failures: metadata.errors.length,
330:         groupId: options.groupId,
331:       });
332:     }
333:   } catch (error) {
334:     const syncError = error instanceof SyncError ? error :
335:       error instanceof Error ?
336:         new SyncError(error.message, "SYNC_MAIN_ERROR") :
337:         new SyncError("Unknown sync error", "UNKNOWN_ERROR");
338: 
339:     metadata.status = "failed";
340:     metadata.errors.push(syncError.message);
341:     await logError(syncError.toGenericError(), "syncPrices:main");
342:   }
343: 
344:   metadata.lastSync = new Date();
345:   metadata.duration = Date.now() - startTime;
346: 
347:   if (!options.dryRun) {
348:     await db.collection(COLLECTION.SYNC_METADATA)
349:       .add(metadata);
350:   }
351: 
352:   if (logger) await logger.finish();
353:   return metadata;
354: }
</file>

<file path="functions/src/test/testEndpoints.ts">
 1: import axios, {isAxiosError} from "axios";
 2: 
 3: const FIREBASE_REGION = "us-central1";
 4: const PROJECT_ID = "fftcg-sync-service";
 5: 
 6: const BASE_URL = `https://${FIREBASE_REGION}-${PROJECT_ID}.cloudfunctions.net`;
 7: 
 8: async function testEndpoints() {
 9:   try {
10:     // Test card sync with a small batch
11:     console.log("\nTesting card sync...");
12:     const cardResponse = await axios.get(`${BASE_URL}/testCardSync`, {
13:       params: {
14:         limit: 5,
15:         dryRun: false,
16:       },
17:     });
18:     console.log("Card sync response:", JSON.stringify(cardResponse.data, null, 2));
19: 
20:     // Test price sync with a specific group
21:     console.log("\nTesting price sync...");
22:     const priceResponse = await axios.get(`${BASE_URL}/testPriceSync`, {
23:       params: {
24:         groupId: "22894", // Boss Deck: Final Fantasy VII
25:         dryRun: false,
26:       },
27:     });
28:     console.log("Price sync response:", JSON.stringify(priceResponse.data, null, 2));
29:   } catch (error) {
30:     if (isAxiosError(error)) {
31:       console.error("Test failed:", error.response?.data || error.message);
32:     } else {
33:       console.error("Test failed:", error);
34:     }
35:   }
36: }
37: 
38: testEndpoints();
</file>

<file path="functions/src/test/testSync.ts">
 1: // src/test/testSync.ts
 2: 
 3: import axios, {isAxiosError} from "axios";
 4: 
 5: const PROJECT_ID = "fftcg-sync-service";
 6: const REGION = "us-central1";
 7: const BASE_URL = `https://${REGION}-${PROJECT_ID}.cloudfunctions.net`;
 8: 
 9: interface SyncResponse {
10:   lastSync: Date;
11:   status: string;
12:   cardCount: number;
13:   type: string;
14:   groupsProcessed: number;
15:   groupsUpdated: number;
16:   errors: string[];
17:   duration?: number;
18: }
19: 
20: async function testSync() {
21:   try {
22:     console.log("Testing Card Sync...");
23:     const cardResponse = await axios.get<SyncResponse>(`${BASE_URL}/testCardSync`, {
24:       params: {
25:         limit: 5, // Only sync 5 cards for testing
26:         dryRun: false,
27:       },
28:     });
29:     console.log("Card Sync Response:", JSON.stringify(cardResponse.data, null, 2));
30: 
31:     console.log("\nTesting Price Sync...");
32:     const priceResponse = await axios.get<SyncResponse>(`${BASE_URL}/testPriceSync`, {
33:       params: {
34:         groupId: "22894", // Boss Deck: Final Fantasy VII
35:         dryRun: false,
36:       },
37:     });
38:     console.log("Price Sync Response:", JSON.stringify(priceResponse.data, null, 2));
39:   } catch (error) {
40:     if (isAxiosError(error)) {
41:       console.error("Error:", error.response?.data || error.message);
42:     } else {
43:       console.error("Error:", error);
44:     }
45:   }
46: }
47: 
48: // Run the test
49: testSync().catch((error) => {
50:   console.error("Unhandled error:", error);
51:   process.exit(1);
52: });
</file>

<file path="functions/src/test/validateSync.ts">
  1: import * as admin from "firebase-admin";
  2: import {Timestamp} from "firebase-admin/firestore";
  3: import {ServiceAccount} from "firebase-admin";
  4: import * as path from "path";
  5: import * as fs from "fs/promises";
  6: 
  7: // Import service account using async/await
  8: async function initializeFirebase() {
  9:   const serviceAccountPath = path.resolve(__dirname, "../../../service_account_key.json");
 10:   const serviceAccountData = await fs.readFile(serviceAccountPath, "utf8");
 11:   const serviceAccount = JSON.parse(serviceAccountData) as ServiceAccount;
 12: 
 13:   admin.initializeApp({
 14:     credential: admin.credential.cert(serviceAccount),
 15:   });
 16: 
 17:   return admin.firestore();
 18: }
 19: 
 20: interface ValidationResult {
 21:   collection: string;
 22:   documentsChecked: number;
 23:   documentsValid: number;
 24:   errors: string[];
 25: }
 26: 
 27: async function validateCollection(
 28:   db: FirebaseFirestore.Firestore,
 29:   collectionName: string,
 30:   validator: (doc: FirebaseFirestore.DocumentData) => boolean
 31: ): Promise<ValidationResult> {
 32:   const result: ValidationResult = {
 33:     collection: collectionName,
 34:     documentsChecked: 0,
 35:     documentsValid: 0,
 36:     errors: [],
 37:   };
 38: 
 39:   try {
 40:     const snapshot = await db.collection(collectionName)
 41:       .orderBy("lastUpdated", "desc")
 42:       .limit(100)
 43:       .get();
 44: 
 45:     result.documentsChecked = snapshot.size;
 46: 
 47:     snapshot.forEach((doc) => {
 48:       const data = doc.data();
 49:       try {
 50:         if (validator(data)) {
 51:           result.documentsValid++;
 52:         } else {
 53:           result.errors.push(`Document ${doc.id} failed validation`);
 54:         }
 55:       } catch (error) {
 56:         result.errors.push(`Error validating ${doc.id}: ${error}`);
 57:       }
 58:     });
 59:   } catch (error) {
 60:     result.errors.push(`Error accessing collection: ${error}`);
 61:   }
 62: 
 63:   return result;
 64: }
 65: 
 66: async function validateSync() {
 67:   console.log("Starting sync validation...");
 68: 
 69:   try {
 70:     const db = await initializeFirebase();
 71: 
 72:     // Validate cards
 73:     const cardResult = await validateCollection(db, "cards", (data) => {
 74:       return (
 75:         typeof data.productId === "number" &&
 76:         typeof data.name === "string" &&
 77:         typeof data.lastUpdated === "object" &&
 78:         data.lastUpdated instanceof Timestamp
 79:       );
 80:     });
 81: 
 82:     // Validate prices
 83:     const priceResult = await validateCollection(db, "prices", (data) => {
 84:       return (
 85:         data.lastUpdated instanceof Timestamp &&
 86:         (!data.normal || typeof data.normal.midPrice === "number") &&
 87:         (!data.foil || typeof data.foil.midPrice === "number")
 88:       );
 89:     });
 90: 
 91:     // Validate sync metadata
 92:     const metadataResult = await validateCollection(db, "syncMetadata", (data) => {
 93:       return (
 94:         data.lastSync instanceof Timestamp &&
 95:         typeof data.status === "string" &&
 96:         typeof data.cardCount === "number" &&
 97:         Array.isArray(data.errors)
 98:       );
 99:     });
100: 
101:     // Print results
102:     console.log("\nValidation Results:");
103:     [cardResult, priceResult, metadataResult].forEach((result) => {
104:       console.log(`\n${result.collection}:`);
105:       console.log(`Documents Checked: ${result.documentsChecked}`);
106:       console.log(`Valid Documents: ${result.documentsValid}`);
107:       if (result.errors.length > 0) {
108:         console.log("Errors:");
109:         result.errors.forEach((error) => console.log(`- ${error}`));
110:       }
111:     });
112:   } catch (error) {
113:     console.error("Validation failed:", error);
114:   }
115: }
116: 
117: // Execute the validation
118: validateSync().catch(console.error);
</file>

<file path="functions/src/types/express.d.ts">
1: // / <reference types="express" />
2: import * as express from "express";
3: export = express;
</file>

<file path="functions/src/types/index.ts">
 1: export interface GenericError extends Error {
 2:     code?: string;
 3:     message: string;
 4:     stack?: string;
 5:   }
 6: 
 7: export interface CardProduct {
 8:     productId: number;
 9:     name: string;
10:     cleanName: string;
11:     imageUrl: string;
12:     categoryId: number;
13:     groupId: number;
14:     url: string;
15:     modifiedOn: string;
16:     imageCount: number;
17:     extendedData: Array<{
18:       name: string;
19:       displayName: string;
20:       value: string;
21:     }>;
22:   }
23: 
24: export interface CardPrice {
25:     productId: number;
26:     lowPrice: number;
27:     midPrice: number;
28:     highPrice: number;
29:     marketPrice: number | null;
30:     directLowPrice: number | null;
31:     subTypeName: "Normal" | "Foil";
32:   }
33: 
34: export interface SyncOptions {
35:     dryRun?: boolean;
36:     limit?: number;
37:     groupId?: string;
38:     productId?: number;
39:     showAll?: boolean;
40:   }
41: 
42: export interface SyncMetadata {
43:     lastSync: Date;
44:     status: "in_progress" | "success" | "failed" | "completed_with_errors";
45:     cardCount: number;
46:     type: "manual" | "scheduled";
47:     groupsProcessed: number;
48:     groupsUpdated: number;
49:     errors: string[];
50:     duration?: number;
51:   }
52: 
53: export type CacheType = "card" | "price";
54: 
55: export interface PriceData {
56:     normal?: CardPrice;
57:     foil?: CardPrice;
58:     lastUpdated: Date;
59:   }
60: 
61: export type LogData = any;
62: export type GenericObject = Record<string, any>;
</file>

<file path="functions/src/types/node.d.ts">
1: // / <reference types="node" />
</file>

<file path="functions/src/utils/batch.ts">
 1: import {logInfo} from "./logger";
 2: 
 3: export interface BatchProcessorOptions {
 4:   batchSize?: number;
 5:   delayBetweenBatches?: number;
 6:   onBatchComplete?: (processedCount: number, totalCount: number) => Promise<void>;
 7: }
 8: 
 9: export async function processBatch<TItem>(
10:   items: TItem[],
11:   processor: (batch: TItem[]) => Promise<void>,
12:   options: BatchProcessorOptions = {}
13: ): Promise<void> {
14:   const {
15:     batchSize = 500,
16:     delayBetweenBatches = 100,
17:     onBatchComplete,
18:   } = options;
19: 
20:   const totalBatches = Math.ceil(items.length / batchSize);
21:   let processedCount = 0;
22: 
23:   for (let i = 0; i < items.length; i += batchSize) {
24:     const batch = items.slice(i, i + batchSize);
25:     const batchNumber = Math.floor(i / batchSize) + 1;
26: 
27:     await processor(batch);
28:     processedCount += batch.length;
29: 
30:     if (onBatchComplete) {
31:       await onBatchComplete(processedCount, items.length);
32:     }
33: 
34:     logInfo(`Processed batch ${batchNumber}/${totalBatches} (${processedCount}/${items.length} items)`);
35: 
36:     if (i + batchSize < items.length) {
37:       await new Promise((resolve) => setTimeout(resolve, delayBetweenBatches));
38:     }
39:   }
40: }
</file>

<file path="functions/src/utils/cache.ts">
 1: import LRUCache from "lru-cache";
 2: import {CacheType, CardProduct} from "../types";
 3: 
 4: const options = {
 5:   max: 500,
 6:   ttl: 1000 * 60 * 60, // 1 hour
 7: };
 8: 
 9: export const cardCache = new LRUCache<string, CardProduct>(options);
10: 
11: export const getCacheKey = (type: CacheType, id: number): string => {
12:   return `${type}:${id}`;
13: };
</file>

<file path="functions/src/utils/error.ts">
 1: import {db, COLLECTION} from "../config/firebase";
 2: import {logError} from "./logger";
 3: 
 4: export interface ErrorReport {
 5:   timestamp: Date;
 6:   context: string;
 7:   error: string;
 8:   stackTrace?: string;
 9:   metadata?: Record<string, unknown>;
10:   severity: "ERROR" | "WARNING" | "CRITICAL";
11: }
12: 
13: export class DetailedError extends Error {
14:   constructor(
15:     message: string,
16:     public context: string,
17:     public metadata?: Record<string, unknown>,
18:     public severity: "ERROR" | "WARNING" | "CRITICAL" = "ERROR"
19:   ) {
20:     super(message);
21:     this.name = "DetailedError";
22:   }
23: }
24: 
25: export async function logDetailedError(
26:   error: Error,
27:   context: string,
28:   metadata?: Record<string, unknown>,
29:   severity: "ERROR" | "WARNING" | "CRITICAL" = "ERROR"
30: ): Promise<void> {
31:   const report: ErrorReport = {
32:     timestamp: new Date(),
33:     context,
34:     error: error.message,
35:     stackTrace: error.stack,
36:     metadata,
37:     severity,
38:   };
39: 
40:   // Log to Firestore
41:   await db.collection(COLLECTION.LOGS)
42:     .add(report);
43: 
44:   // Log using existing logger
45:   await logError(error, context);
46: }
</file>

<file path="functions/src/utils/logger.ts">
 1: import * as functions from "firebase-functions";
 2: import {db, COLLECTION} from "../config/firebase";
 3: import {GenericError, LogData, GenericObject} from "../types";
 4: 
 5: export const logger = functions.logger;
 6: 
 7: interface LogEntry {
 8:   timestamp: Date;
 9:   level: "INFO" | "WARNING" | "ERROR";
10:   message: string;
11:   context?: string;
12:   data?: Record<string, unknown>;
13: }
14: 
15: async function saveLogEntry(entry: LogEntry): Promise<void> {
16:   // Remove undefined values and convert data to a plain object
17:   const cleanEntry = {
18:     timestamp: entry.timestamp,
19:     level: entry.level,
20:     message: entry.message,
21:     ...(entry.context && {context: entry.context}),
22:     ...(entry.data && {data: JSON.parse(JSON.stringify(entry.data))}),
23:   };
24: 
25:   await db.collection(COLLECTION.LOGS).add(cleanEntry);
26: }
27: 
28: export const logError = async (error: GenericError | GenericObject, context: string) => {
29:   const entry: LogEntry = {
30:     timestamp: new Date(),
31:     level: "ERROR",
32:     message: error.message || "Unknown error",
33:     context,
34:     data: {
35:       stack: error.stack || null,
36:       code: error.code || null,
37:     },
38:   };
39: 
40:   logger.error(entry.message, entry.data);
41:   await saveLogEntry(entry);
42: };
43: 
44: export const logInfo = async (message: string, data?: LogData) => {
45:   const entry: LogEntry = {
46:     timestamp: new Date(),
47:     level: "INFO",
48:     message,
49:     ...(data && {data: JSON.parse(JSON.stringify(data))}),
50:   };
51: 
52:   logger.info(message, data);
53:   await saveLogEntry(entry);
54: };
55: 
56: export const logWarning = async (message: string, data?: LogData) => {
57:   const entry: LogEntry = {
58:     timestamp: new Date(),
59:     level: "WARNING",
60:     message,
61:     ...(data && {data: JSON.parse(JSON.stringify(data))}),
62:   };
63: 
64:   logger.warn(message, data);
65:   await saveLogEntry(entry);
66: };
</file>

<file path="functions/src/utils/progress.ts">
 1: // src/utils/progress.ts
 2: 
 3: import {logInfo} from "./logger";
 4: 
 5: export interface ProgressStats {
 6:   current: number;
 7:   total: number;
 8:   percent: number;
 9:   elapsed: number;
10:   rate: number;
11:   remaining: number;
12:   eta: number;
13: }
14: 
15: export class EnhancedProgressTracker {
16:   private startTime: number;
17:   private current: number;
18:   private estimates: number[] = [];
19:   private lastUpdate: number;
20:   private updateInterval: number;
21: 
22:   constructor(
23:     private total: number,
24:     private description: string,
25:     options: { updateInterval?: number } = {}
26:   ) {
27:     this.startTime = Date.now();
28:     this.current = 0;
29:     this.lastUpdate = Date.now();
30:     this.updateInterval = options.updateInterval || 1000; // Default 1 second
31:   }
32: 
33:   private calculateStats(): ProgressStats {
34:     const now = Date.now();
35:     const elapsed = (now - this.startTime) / 1000;
36:     const percent = (this.current / this.total) * 100;
37:     const rate = this.current / elapsed;
38:     const remaining = this.total - this.current;
39:     const eta = remaining / rate;
40: 
41:     return {
42:       current: this.current,
43:       total: this.total,
44:       percent,
45:       elapsed,
46:       rate,
47:       remaining,
48:       eta,
49:     };
50:   }
51: 
52:   update(amount = 1): void {
53:     const now = Date.now();
54:     this.current += amount;
55: 
56:     // Only update log if enough time has passed
57:     if (now - this.lastUpdate >= this.updateInterval) {
58:       const stats = this.calculateStats();
59:       this.estimates.push(stats.eta);
60: 
61:       // Keep only last 10 estimates for averaging
62:       if (this.estimates.length > 10) {
63:         this.estimates.shift();
64:       }
65: 
66:       const avgEta = this.estimates.reduce((a, b) => a + b, 0) / this.estimates.length;
67: 
68:       logInfo(
69:         `${this.description}: ${stats.current}/${stats.total} ` +
70:         `(${stats.percent.toFixed(1)}%) - ${stats.remaining} remaining - ` +
71:         `ETA: ${avgEta.toFixed(1)}s - Rate: ${stats.rate.toFixed(1)}/s`
72:       );
73: 
74:       this.lastUpdate = now;
75:     }
76:   }
77: 
78:   getProgress(): ProgressStats {
79:     return this.calculateStats();
80:   }
81: }
</file>

<file path="functions/src/utils/request.ts">
 1: import axios, {AxiosError} from "axios";
 2: import {logWarning} from "./logger";
 3: 
 4: export const MAX_RETRIES = 3;
 5: export const BASE_DELAY = 1000; // 1 second
 6: 
 7: export interface RequestOptions {
 8:   retryCount?: number;
 9:   customDelay?: number;
10:   metadata?: Record<string, unknown>;
11: }
12: 
13: export class RequestError extends Error {
14:   constructor(
15:     message: string,
16:     public originalError: Error,
17:     public context: string,
18:     public metadata?: Record<string, unknown>
19:   ) {
20:     super(message);
21:     this.name = "RequestError";
22:   }
23: }
24: 
25: export async function makeRequest<T>(
26:   endpoint: string,
27:   baseUrl: string,
28:   options: RequestOptions = {}
29: ): Promise<T> {
30:   const {retryCount = 0, customDelay = BASE_DELAY} = options;
31: 
32:   try {
33:     await new Promise((resolve) => setTimeout(resolve, customDelay));
34:     const url = `${baseUrl}/${endpoint}`;
35:     const response = await axios.get<T>(url, {
36:       timeout: 30000, // 30 seconds timeout
37:       headers: {
38:         "Accept": "application/json",
39:         "User-Agent": "FFTCG-Sync-Service/1.0",
40:       },
41:     });
42: 
43:     return response.data;
44:   } catch (error) {
45:     if (retryCount < MAX_RETRIES - 1 && error instanceof AxiosError) {
46:       const delay = Math.pow(2, retryCount) * BASE_DELAY;
47:       await logWarning(`Request failed, retrying in ${delay}ms...`, {
48:         url: `${baseUrl}/${endpoint}`,
49:         attempt: retryCount + 1,
50:         maxRetries: MAX_RETRIES,
51:         error: error.message,
52:         ...options.metadata,
53:       });
54: 
55:       return makeRequest<T>(endpoint, baseUrl, {
56:         ...options,
57:         retryCount: retryCount + 1,
58:         customDelay: delay,
59:       });
60:     }
61: 
62:     throw new RequestError(
63:       `Request failed after ${retryCount + 1} attempts`,
64:       error as Error,
65:       endpoint,
66:       options.metadata
67:     );
68:   }
69: }
</file>

<file path="functions/src/utils/syncLogger.ts">
 1: interface CardDetails {
 2:     id: number;
 3:     name: string;
 4:     groupId: string;
 5:     normalPrice?: number;
 6:     foilPrice?: number;
 7:     rawPrices: Array<{
 8:       type: "Normal" | "Foil";
 9:       price: number;
10:       groupId: string;
11:     }>;
12:   }
13: 
14: export class SyncLogger {
15:   private startTime: number;
16:   private cards: CardDetails[] = [];
17:   private groups: Map<string, { products: number; prices: number }> = new Map();
18: 
19:   constructor(private options: {
20:       type: "test" | "manual" | "scheduled";
21:       limit?: number;
22:       dryRun?: boolean;
23:       groupId?: string;
24:     }) {
25:     this.startTime = Date.now();
26:   }
27: 
28:   async start(): Promise<void> {
29:     console.log("\nStarting sync operation...");
30:     console.log(`Type: ${this.options.type}`);
31:     if (this.options.limit) console.log(`Limit: ${this.options.limit} cards`);
32:     if (this.options.groupId) console.log(`Group ID: ${this.options.groupId}`);
33:     console.log(`Dry Run: ${this.options.dryRun ? "true" : "false"}`);
34:     console.log("\n=== Fetching Raw Data ===");
35:   }
36: 
37:   async logGroupFound(totalGroups: number): Promise<void> {
38:     console.log(`Found ${totalGroups} groups`);
39:   }
40: 
41:   async logGroupDetails(groupId: string, products: number, prices: number): Promise<void> {
42:     this.groups.set(groupId, {products, prices});
43:     console.log(`Group ${groupId} has ${products} products and ${prices} prices`);
44:   }
45: 
46:   async logCardDetails(details: CardDetails): Promise<void> {
47:     this.cards.push(details);
48:     if (this.cards.length === 1) {
49:       console.log("\n=== Card Details ===");
50:     }
51: 
52:     console.log(`Card: ${details.name} (${details.groupId || "UNKNOWN"})`);
53:     console.log(`- ID: ${details.id}`);
54:     console.log(`- Group ID: ${details.groupId || "UNKNOWN"}`);
55: 
56:     if (details.rawPrices.length > 0) {
57:       console.log("- Raw Prices:");
58:       details.rawPrices.forEach((price) => {
59:         console.log(`  > ${price.type}: $${price.price.toFixed(2)} (Group: ${price.groupId})`);
60:       });
61:     }
62: 
63:     console.log(`- Normal Price: $${details.normalPrice?.toFixed(2) || "0.00"}`);
64:     console.log(`- Foil Price: $${details.foilPrice?.toFixed(2) || "0.00"}`);
65:     console.log("---");
66:   }
67: 
68:   async logSyncResults(results: {
69:       success: number;
70:       failures: number;
71:       groupId?: string;
72:     }): Promise<void> {
73:     const duration = (Date.now() - this.startTime) / 1000;
74: 
75:     console.log(`\n=== ${this.capitalizeFirst(this.options.type)} Sync Results ===`);
76:     if (this.options.dryRun) console.log("DRY RUN MODE - No data will be modified");
77:     if (this.options.limit) console.log(`Processing limited to ${this.options.limit} cards`);
78: 
79:     console.log("\nResults:");
80:     console.log(`- Success: ${results.success}`);
81:     console.log(`- Failures: ${results.failures}`);
82:     console.log(`- Duration: ${duration.toFixed(1)} seconds`);
83:     if (results.groupId) console.log(`- Group ID: ${results.groupId}`);
84:   }
85: 
86:   async finish(): Promise<void> {
87:     console.log("\nSync operation completed!");
88:   }
89: 
90:   private capitalizeFirst(str: string): string {
91:     return str.charAt(0).toUpperCase() + str.slice(1);
92:   }
93: }
</file>

<file path="functions/tsconfig.dev.json">
1: {
2:   "extends": "./tsconfig.json",
3:   "include": [
4:     ".eslintrc.js",
5:     ".eslintrc.fix.js",
6:     ".eslintrc.base.cjs"
7:   ]
8: }
</file>

<file path="functions/tsconfig.json">
 1: {
 2:   "compilerOptions": {
 3:     "module": "commonjs",
 4:     "noImplicitReturns": true,
 5:     "noUnusedLocals": true,
 6:     "outDir": "lib",
 7:     "sourceMap": true,
 8:     "strict": true,
 9:     "target": "es2017",
10:     "esModuleInterop": true,
11:     "skipLibCheck": true,
12:     "typeRoots": [
13:       "./node_modules/@types",
14:       "./src/types"
15:     ],
16:     "types": ["node", "express"],
17:     "baseUrl": "./src"
18:   },
19:   "compileOnSave": true,
20:   "include": [
21:     "src/**/*",
22:     ".eslintrc.js",
23:     ".eslintrc.fix.js",
24:     ".eslintrc.base.cjs"
25:   ],
26:   "exclude": [
27:     "node_modules",
28:     "lib"
29:   ]
30: }
</file>

<file path="package.json">
 1: {
 2:   "name": "fftcg-sync-service",
 3:   "version": "1.0.0",
 4:   "description": "FFTCG Card Data Sync Service",
 5:   "scripts": {
 6:     "start": "cd functions && npm run serve",
 7:     "build": "cd functions && npm run build",
 8:     "deploy": "cd functions && npm run deploy",
 9:     "test": "cd functions && npm test",
10:     "lint": "cd functions && npm run lint",
11:     "lint:fix": "cd functions && npm run lint:fix",
12:     "serve": "cd functions && npm run serve",
13:     "shell": "cd functions && npm run shell",
14:     "logs": "cd functions && npm run logs",
15:     "install:all": "npm install && cd functions && npm install && npm run build",
16:     "clean": "cd functions && npm run clean"
17:   },
18:   "devDependencies": {
19:     "@types/express": "^4.17.21",
20:     "@types/node": "^18.19.64",
21:     "@typescript-eslint/eslint-plugin": "^6.0.0",
22:     "@typescript-eslint/parser": "^6.0.0",
23:     "eslint": "^8.0.0",
24:     "eslint-config-google": "^0.14.0",
25:     "eslint-plugin-import": "^2.25.4",
26:     "typescript": "^4.9.5"
27:   },
28:   "engines": {
29:     "node": "18"
30:   },
31:   "private": true,
32:   "dependencies": {
33:     "firebase-functions": "^6.1.0"
34:   }
35: }
</file>

<file path="storage.rules">
1: rules_version = '2';
2: service firebase.storage {
3:   match /b/{bucket}/o {
4:     match /{allPaths=**} {
5:       // Only allow access from our Cloud Functions
6:       allow read, write: if false;
7:     }
8:   }
9: }
</file>

<file path="tsconfig.json">
 1: {
 2:   "extends": "./functions/tsconfig.json",
 3:   "compilerOptions": {
 4:     "baseUrl": ".",
 5:     "paths": {
 6:       "*": ["node_modules/*", "functions/node_modules/*"]
 7:     },
 8:     "types": []
 9:   },
10:   "include": [
11:     "functions/src"
12:   ],
13:   "exclude": [
14:     "node_modules",
15:     "functions/node_modules"
16:   ]
17: }
</file>

</repository_files>
