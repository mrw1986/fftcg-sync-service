This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-03T03:20:29.632Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

- Line numbers have been added to the beginning of each line.
</notes>

<additional_info>

For more information about Repomix, visit: https://github.com/yamadashy/repomix
</additional_info>

</file_summary>

<repository_structure>
.eslintignore
.eslintrc.base.cjs
.eslintrc.fix.js
.eslintrc.js
.firebaserc
.gitignore
.prettierrc
.repomixignore
firebase.json
package.json
repomix.config.json
src/config/environment.ts
src/config/firebase.ts
src/config/r2.ts
src/index.ts
src/scripts/cleanup.ts
src/scripts/setenv.ts
src/scripts/syncAll.ts
src/scripts/syncCards.ts
src/scripts/syncPrices.ts
src/scripts/testSync.ts
src/services/cardSync.ts
src/services/priceSync.ts
src/services/storageService.ts
src/types/index.ts
src/utils/api.ts
src/utils/logger.ts
src/utils/retention.ts
src/utils/timeout.ts
tsconfig.dev.json
tsconfig.json
</repository_structure>

<repository_files>
This section contains the contents of the repository's files.

<file path=".eslintignore">
1: node_modules/
2: lib/
3: coverage/
4: *.d.ts
5: *.cjs
</file>

<file path=".eslintrc.base.cjs">
1: module.exports = {
2:     rules: {
3:       "valid-jsdoc": "off",
4:       "require-jsdoc": "off"
5:     }
6:   };
</file>

<file path=".eslintrc.fix.js">
 1: module.exports = {
 2:   extends: "./.eslintrc.js",
 3:   rules: {
 4:     "max-len": ["error", {"code": 120}],
 5:     "valid-jsdoc": 0,
 6:     "require-jsdoc": 0,
 7:     "@typescript-eslint/no-explicit-any": 0,
 8:     "@typescript-eslint/explicit-function-return-type": 0,
 9:     "@typescript-eslint/explicit-module-boundary-types": 0,
10:     "@typescript-eslint/no-unused-vars": ["error", {
11:       "argsIgnorePattern": "^_",
12:       "varsIgnorePattern": "^_",
13:     }],
14:     // Add these additional rules to be extra sure
15:     "jsdoc/require-jsdoc": 0,
16:     "jsdoc/valid-jsdoc": 0,
17:     "jsdoc/require-param-type": 0,
18:     "jsdoc/require-returns": 0,
19:   },
20: };
</file>

<file path=".eslintrc.js">
 1: module.exports = {
 2:   root: true,
 3:   env: {
 4:     es6: true,
 5:     node: true,
 6:   },
 7:   extends: [
 8:     "eslint:recommended",
 9:     "plugin:import/errors",
10:     "plugin:import/warnings",
11:     "plugin:import/typescript",
12:     "google",
13:     "plugin:@typescript-eslint/recommended",
14:   ],
15:   parser: "@typescript-eslint/parser",
16:   parserOptions: {
17:     project: ["tsconfig.json", "tsconfig.dev.json"],
18:     sourceType: "module",
19:   },
20:   ignorePatterns: [
21:     "/lib/**/*",
22:     "/generated/**/*",
23:     "*.js", // Add this line to ignore JS files
24:   ],
25:   plugins: ["@typescript-eslint", "import"],
26:   rules: {
27:     quotes: ["error", "double"],
28:     "import/no-unresolved": 0,
29:     indent: ["error", 2],
30:     "linebreak-style": 0, // Disable linebreak-style checks
31:     "object-curly-spacing": ["error", "always"],
32:     "max-len": ["error", { code: 120 }],
33:     "@typescript-eslint/no-explicit-any": "warn",
34:     "require-jsdoc": 0,
35:     "valid-jsdoc": 0,
36:     "@typescript-eslint/no-var-requires": 0,
37:     camelcase: 0,
38:   },
39: };
</file>

<file path=".firebaserc">
1: {
2:   "projects": {
3:     "default": "fftcg-sync-service"
4:   }
5: }
</file>

<file path=".gitignore">
 1: # Dependencies
 2: node_modules/
 3: 
 4: # Build output
 5: lib/
 6: dist/
 7: 
 8: # Environment variables
 9: .env
10: .env.local
11: .env.*.local
12: 
13: # Service account keys
14: service_account_key.json
15: *-service-account.json
16: 
17: # Firebase
18: .firebase/
19: firebase-debug.log
20: firebase-debug.*.log
21: 
22: # IDE
23: .vscode/
24: .idea/
25: 
26: # Logs
27: *.log
</file>

<file path=".prettierrc">
1: {
2:   "singleQuote": false,
3:   "trailingComma": "es5",
4:   "bracketSpacing": true,
5:   "semi": true,
6:   "printWidth": 120,
7:   "tabWidth": 2,
8:   "endOfLine": "auto"
9: }
</file>

<file path=".repomixignore">
1: lib/**
2: !*/
3: !.gitignore
4: service_account_key.json
5: !src/**
</file>

<file path="firebase.json">
 1: {
 2:   "functions": [
 3:     {
 4:       "source": ".",
 5:       "predeploy": [
 6:         "npm --prefix \"$RESOURCE_DIR\" run lint",
 7:         "npm --prefix \"$RESOURCE_DIR\" run build"
 8:       ],
 9:       "codebase": "default",
10:       "ignore": [
11:         "node_modules",
12:         ".git",
13:         "firebase-debug.log",
14:         "firebase-debug.*.log",
15:         "*.local"
16:       ]
17:     }
18:   ],
19:   "emulators": {
20:     "functions": {
21:       "port": 5001
22:     },
23:     "ui": {
24:       "enabled": true
25:     },
26:     "firestore": {
27:       "port": 8080
28:     },
29:     "singleProjectMode": true
30:   }
31: }
</file>

<file path="package.json">
 1: {
 2:   "name": "functions",
 3:   "scripts": {
 4:     "lint": "eslint --ext .js,.ts .",
 5:     "lint:fix": "eslint --ext .js,.ts . --fix",
 6:     "build": "tsc",
 7:     "build:watch": "tsc --watch",
 8:     "serve": "npm run build && firebase emulators:start --only functions,firestore",
 9:     "shell": "npm run build && firebase functions:shell",
10:     "start": "npm run shell",
11:     "deploy": "firebase deploy --only functions",
12:     "logs": "firebase functions:log",
13:     "format": "prettier --write \"src/**/*.{js,ts}\"",
14:     "setenv": "ts-node src/scripts/setenv.ts"
15:   },
16:   "engines": {
17:     "node": "18"
18:   },
19:   "main": "lib/index.js",
20:   "dependencies": {
21:     "@aws-sdk/client-s3": "^3.485.0",
22:     "@aws-sdk/s3-request-presigner": "^3.485.0",
23:     "axios": "^1.7.7",
24:     "dotenv": "^16.4.7",
25:     "firebase-admin": "^12.6.0",
26:     "firebase-functions": "^6.0.1"
27:   },
28:   "devDependencies": {
29:     "@typescript-eslint/eslint-plugin": "^5.12.0",
30:     "@typescript-eslint/parser": "^5.12.0",
31:     "eslint": "^8.9.0",
32:     "eslint-config-google": "^0.14.0",
33:     "eslint-plugin-import": "^2.25.4",
34:     "firebase-functions-test": "^3.1.0",
35:     "prettier": "^3.4.2",
36:     "typescript": "^4.9.0"
37:   },
38:   "private": true
39: }
</file>

<file path="repomix.config.json">
 1: {
 2:   "output": {
 3:     "filePath": "C:\\VSCode\\fftcg-sync-service\\codebase.xml",
 4:     "style": "xml",
 5:     "removeComments": false,
 6:     "removeEmptyLines": false,
 7:     "topFilesLength": 5,
 8:     "showLineNumbers": true,
 9:     "copyToClipboard": false
10:   },
11:   "include": [],
12:   "ignore": {
13:     "useGitignore": false,
14:     "useDefaultPatterns": true,
15:     "customPatterns": []
16:   },
17:   "security": {
18:     "enableSecurityCheck": true
19:   }
20: }
</file>

<file path="src/config/environment.ts">
 1: // src/config/environment.ts
 2: import * as functions from "firebase-functions";
 3: import * as dotenv from "dotenv";
 4: 
 5: // Load .env file in development
 6: if (process.env.NODE_ENV !== "production") {
 7:   dotenv.config();
 8: }
 9: 
10: // Helper function to get config value
11: function getConfigValue(key: string): string {
12:   // In production, use Firebase config
13:   if (process.env.NODE_ENV === "production") {
14:     const config = functions.config();
15:     return config.r2?.[key.toLowerCase().replace("r2_", "")] || "";
16:   }
17: 
18:   // In development, use .env file
19:   return process.env[key] || "";
20: }
21: 
22: export const environment = {
23:   nodeEnv: process.env.NODE_ENV || "development",
24:   isLocal: process.env.NODE_ENV !== "production",
25:   r2: {
26:     accountId: getConfigValue("R2_ACCOUNT_ID"),
27:     accessKeyId: getConfigValue("R2_ACCESS_KEY_ID"),
28:     secretAccessKey: getConfigValue("R2_SECRET_ACCESS_KEY"),
29:     bucketName: getConfigValue("R2_BUCKET_NAME"),
30:     storagePath: getConfigValue("R2_STORAGE_PATH"),
31:     customDomain: getConfigValue("R2_CUSTOM_DOMAIN"),
32:   },
33: };
34: 
35: // Skip validation in production since we're using Firebase config
36: if (process.env.NODE_ENV !== "production") {
37:   const required = ["R2_ACCOUNT_ID", "R2_ACCESS_KEY_ID", "R2_SECRET_ACCESS_KEY", "R2_BUCKET_NAME"];
38: 
39:   const missing = required.filter((key) => !process.env[key]);
40: 
41:   if (missing.length) {
42:     throw new Error(`Missing required env vars: ${missing.join(", ")}`);
43:   }
44: }
</file>

<file path="src/config/firebase.ts">
 1: // functions/src/config/firebase.ts
 2: 
 3: import * as admin from "firebase-admin";
 4: 
 5: const app = !admin.apps.length ? admin.initializeApp() : admin.app();
 6: const db = admin.firestore(app);
 7: 
 8: // Enable ignoreUndefinedProperties and other settings
 9: db.settings({
10:   ignoreUndefinedProperties: true,
11:   timestampsInSnapshots: true,
12: });
13: 
14: export { db };
15: 
16: export const COLLECTION = {
17:   CARDS: "cards",
18:   PRICES: "prices",
19:   SYNC_METADATA: "syncMetadata",
20:   LOGS: "logs",
21:   CARD_HASHES: "cardHashes",
22:   PRICE_HASHES: "priceHashes",
23:   IMAGE_METADATA: "imageMetadata",
24:   HISTORICAL_PRICES: "historicalPrices",
25:   PRICE_ARCHIVES: "priceArchives",
26: };
27: 
28: export const BASE_URL = "https://tcgcsv.com/tcgplayer";
29: export const FFTCG_CATEGORY_ID = "24";
30: 
31: export const runtimeOpts = {
32:   timeoutSeconds: 540,
33:   memory: "1GiB",
34: } as const;
</file>

<file path="src/config/r2.ts">
 1: // src/config/r2.ts
 2: 
 3: import * as dotenv from "dotenv";
 4: dotenv.config();
 5: 
 6: export const R2_CONFIG = {
 7:   ACCOUNT_ID: process.env.R2_ACCOUNT_ID || "",
 8:   ACCESS_KEY_ID: process.env.R2_ACCESS_KEY_ID || "",
 9:   SECRET_ACCESS_KEY: process.env.R2_SECRET_ACCESS_KEY || "",
10:   BUCKET_NAME: process.env.R2_BUCKET_NAME || "",
11:   STORAGE_PATH: process.env.R2_STORAGE_PATH || "",
12:   CUSTOM_DOMAIN: process.env.R2_CUSTOM_DOMAIN || "",
13: } as const;
14: 
15: if (!R2_CONFIG.ACCOUNT_ID) {
16:   console.warn("Missing R2_ACCOUNT_ID in .env file");
17: }
18: if (!R2_CONFIG.ACCESS_KEY_ID) {
19:   console.warn("Missing R2_ACCESS_KEY_ID in .env file");
20: }
21: if (!R2_CONFIG.SECRET_ACCESS_KEY) {
22:   console.warn("Missing R2_SECRET_ACCESS_KEY in .env file");
23: }
24: if (!R2_CONFIG.BUCKET_NAME) {
25:   console.warn("Missing R2_BUCKET_NAME in .env file");
26: }
27: if (!R2_CONFIG.STORAGE_PATH) {
28:   console.warn("Missing R2_STORAGE_PATH in .env file");
29: }
30: if (!R2_CONFIG.CUSTOM_DOMAIN) {
31:   console.warn("Missing R2_CUSTOM_DOMAIN in .env file");
32: }
33: 
34: console.log("R2 Config:", R2_CONFIG);
</file>

<file path="src/index.ts">
  1: // src/index.ts
  2: import { onRequest } from "firebase-functions/v2/https";
  3: import { onSchedule } from "firebase-functions/v2/scheduler";
  4: import { cardSync } from "./services/cardSync";
  5: import { priceSync } from "./services/priceSync";
  6: import { retention } from "./utils/retention";
  7: import { logger } from "./utils/logger";
  8: import { db, runtimeOpts } from "./config/firebase";
  9: 
 10: // HTTP Functions
 11: export const manualCardSync = onRequest(runtimeOpts, async (req, res) => {
 12:   try {
 13:     const forceUpdate = req.query.force === "true";
 14:     const groupId = req.query.groupId as string | undefined;
 15:     const result = await cardSync.syncCards({ forceUpdate, groupId });
 16:     res.json(result);
 17:   } catch (error) {
 18:     logger.error("Manual card sync failed", { error });
 19:     res.status(500).json({
 20:       error: "Sync failed",
 21:       message: error instanceof Error ? error.message : "Unknown error",
 22:     });
 23:   }
 24: });
 25: 
 26: export const manualPriceSync = onRequest(runtimeOpts, async (req, res) => {
 27:   try {
 28:     const forceUpdate = req.query.force === "true";
 29:     const groupId = req.query.groupId as string | undefined;
 30:     const result = await priceSync.syncPrices({
 31:       forceUpdate,
 32:       ...(groupId && { groupId }),
 33:     });
 34:     res.json(result);
 35:   } catch (error) {
 36:     logger.error("Manual price sync failed", { error });
 37:     res.status(500).json({
 38:       error: "Sync failed",
 39:       message: error instanceof Error ? error.message : "Unknown error",
 40:     });
 41:   }
 42: });
 43: 
 44: export const manualCleanup = onRequest(runtimeOpts, async (_req, res) => {
 45:   try {
 46:     await retention.cleanOldData();
 47:     res.json({ success: true });
 48:   } catch (error) {
 49:     logger.error("Manual cleanup failed", { error });
 50:     res.status(500).json({
 51:       error: "Cleanup failed",
 52:       message: error instanceof Error ? error.message : "Unknown error",
 53:     });
 54:   }
 55: });
 56: 
 57: export const healthCheck = onRequest(runtimeOpts, async (_req, res) => {
 58:   try {
 59:     await db.collection("cards").limit(1).get();
 60:     res.json({
 61:       status: "healthy",
 62:       timestamp: new Date(),
 63:       environment: process.env.NODE_ENV,
 64:     });
 65:   } catch (error) {
 66:     logger.error("Health check failed", { error });
 67:     res.status(503).json({
 68:       status: "unhealthy",
 69:       timestamp: new Date(),
 70:       error: error instanceof Error ? error.message : "Unknown error",
 71:     });
 72:   }
 73: });
 74: 
 75: // Scheduled Functions
 76: export const scheduledCardSync = onSchedule(
 77:   {
 78:     schedule: "0 21 * * *", // Daily at 21:00 UTC
 79:     timeZone: "UTC",
 80:     ...runtimeOpts,
 81:   },
 82:   async () => {
 83:     try {
 84:       logger.info("Starting scheduled card sync");
 85:       const result = await cardSync.syncCards();
 86:       logger.info("Card sync completed", result);
 87:     } catch (error) {
 88:       logger.error("Scheduled card sync failed", { error });
 89:       throw error;
 90:     }
 91:   }
 92: );
 93: 
 94: export const scheduledPriceSync = onSchedule(
 95:   {
 96:     schedule: "30 21 * * *", // Daily at 21:30 UTC
 97:     timeZone: "UTC",
 98:     ...runtimeOpts,
 99:   },
100:   async () => {
101:     try {
102:       logger.info("Starting scheduled price sync");
103:       const result = await priceSync.syncPrices({}); // Pass empty options object
104:       logger.info("Price sync completed", result);
105:     } catch (error) {
106:       logger.error("Scheduled price sync failed", { error });
107:       throw error;
108:     }
109:   }
110: );
111: 
112: export const scheduledCleanup = onSchedule(
113:   {
114:     schedule: "0 22 * * *", // Daily at 22:00 UTC
115:     timeZone: "UTC",
116:     ...runtimeOpts,
117:   },
118:   async () => {
119:     try {
120:       logger.info("Starting scheduled cleanup");
121:       await retention.cleanOldData();
122:       logger.info("Cleanup completed");
123:     } catch (error) {
124:       logger.error("Scheduled cleanup failed", { error });
125:       throw error;
126:     }
127:   }
128: );
</file>

<file path="src/scripts/cleanup.ts">
 1: import { retention } from "../utils/retention";
 2: 
 3: async function main() {
 4:   console.log("Starting manual cleanup...");
 5:   try {
 6:     await retention.cleanOldData();
 7:     console.log("Cleanup completed successfully");
 8:   } catch (error) {
 9:     console.error("Cleanup failed:", error);
10:     process.exit(1);
11:   }
12: }
13: 
14: main();
</file>

<file path="src/scripts/setenv.ts">
 1: // scripts/setenv.ts
 2: import * as dotenv from "dotenv";
 3: import { exec } from "child_process";
 4: import { promisify } from "util";
 5: 
 6: const execAsync = promisify(exec);
 7: 
 8: async function setFirebaseConfig() {
 9:   try {
10:     dotenv.config();
11: 
12:     const config = {
13:       account_id: process.env.R2_ACCOUNT_ID,
14:       access_key_id: process.env.R2_ACCESS_KEY_ID,
15:       secret_access_key: process.env.R2_SECRET_ACCESS_KEY,
16:       bucket_name: process.env.R2_BUCKET_NAME,
17:       storage_path: process.env.R2_STORAGE_PATH,
18:       custom_domain: process.env.R2_CUSTOM_DOMAIN,
19:     };
20: 
21:     // Remove existing config
22:     await execAsync("firebase functions:config:unset r2");
23: 
24:     // Set new config
25:     const configString = Object.entries(config)
26:       .map(([key, value]) => `r2.${key}="${value}"`)
27:       .join(" ");
28: 
29:     await execAsync(`firebase functions:config:set ${configString}`);
30:     console.log("Firebase config updated successfully");
31:   } catch (error) {
32:     console.error("Error setting Firebase config:", error);
33:   }
34: }
35: 
36: setFirebaseConfig();
</file>

<file path="src/scripts/syncAll.ts">
 1: import { cardSync } from "../services/cardSync";
 2: import { priceSync } from "../services/priceSync";
 3: 
 4: async function main() {
 5:   console.log("Starting full sync...");
 6: 
 7:   try {
 8:     console.log("\n1. Running card sync...");
 9:     const cardResult = await cardSync.syncCards();
10:     console.log("Card sync completed:", {
11:       success: cardResult.success,
12:       processed: cardResult.itemsProcessed,
13:       updated: cardResult.itemsUpdated,
14:       errors: cardResult.errors.length,
15:     });
16: 
17:     console.log("\n2. Running price sync...");
18:     const priceResult = await priceSync.syncPrices();
19:     console.log("Price sync completed:", {
20:       success: priceResult.success,
21:       processed: priceResult.itemsProcessed,
22:       updated: priceResult.itemsUpdated,
23:       errors: priceResult.errors.length,
24:     });
25: 
26:     const allErrors = [...cardResult.errors, ...priceResult.errors];
27:     if (allErrors.length > 0) {
28:       console.log("\nErrors encountered:");
29:       allErrors.forEach((error) => console.log(`- ${error}`));
30:     }
31: 
32:     console.log("\nFull sync completed!");
33:   } catch (error) {
34:     console.error("Full sync failed:", error);
35:     process.exit(1);
36:   }
37: }
38: 
39: main();
</file>

<file path="src/scripts/syncCards.ts">
 1: import { cardSync } from "../services/cardSync";
 2: 
 3: async function main() {
 4:   try {
 5:     console.log("Starting manual card sync...");
 6:     const result = await cardSync.syncCards();
 7:     console.log("Card sync completed:", {
 8:       success: result.success,
 9:       processed: result.itemsProcessed,
10:       updated: result.itemsUpdated,
11:       errors: result.errors.length,
12:       duration: `${result.timing.duration}s`,
13:     });
14: 
15:     if (result.errors.length > 0) {
16:       console.log("\nErrors encountered:");
17:       result.errors.forEach((error) => console.log(`- ${error}`));
18:     }
19:   } catch (error) {
20:     console.error("Card sync failed:", error);
21:     process.exit(1);
22:   }
23: }
24: 
25: main();
</file>

<file path="src/scripts/syncPrices.ts">
 1: import { priceSync } from "../services/priceSync";
 2: 
 3: async function main() {
 4:   console.log("Starting manual price sync...");
 5:   try {
 6:     const result = await priceSync.syncPrices();
 7:     console.log("Price sync completed:", {
 8:       success: result.success,
 9:       processed: result.itemsProcessed,
10:       updated: result.itemsUpdated,
11:       errors: result.errors.length,
12:       duration: `${result.timing.duration}s`,
13:     });
14: 
15:     if (result.errors.length > 0) {
16:       console.log("\nErrors encountered:");
17:       result.errors.forEach((error) => console.log(`- ${error}`));
18:     }
19:   } catch (error) {
20:     console.error("Price sync failed:", error);
21:     process.exit(1);
22:   }
23: }
24: 
25: main();
</file>

<file path="src/scripts/testSync.ts">
 1: // src/test/testSync.ts
 2: import { cardSync } from "../services/cardSync";
 3: import { priceSync } from "../services/priceSync";
 4: import { logger } from "../utils/logger";
 5: import { withTimeout, TimeoutError } from "../utils/timeout";
 6: 
 7: const MAX_SYNC_TIME = 30 * 60 * 1000; // 30 minutes
 8: const TEST_GROUP_ID = "23244"; // Dawn of Heroes
 9: 
10: async function testSync() {
11:   try {
12:     logger.info("Starting test sync with group " + TEST_GROUP_ID);
13: 
14:     // Monitor card sync with timeout
15:     const cardResult = await withTimeout(
16:       cardSync.syncCards({
17:         groupId: TEST_GROUP_ID,
18:         forceUpdate: true, // Add this to force update even if hash matches
19:       }),
20:       MAX_SYNC_TIME
21:     );
22: 
23:     logger.info("Card sync results:", {
24:       processed: cardResult.itemsProcessed,
25:       updated: cardResult.itemsUpdated,
26:       errors: cardResult.errors,
27:       timing: cardResult.timing,
28:     });
29: 
30:     // Monitor price sync with timeout
31:     const priceResult = await withTimeout(
32:       priceSync.syncPrices({
33:         groupId: TEST_GROUP_ID,
34:         forceUpdate: true,
35:       }),
36:       MAX_SYNC_TIME
37:     );
38: 
39:     logger.info("Price sync results:", {
40:       processed: priceResult.itemsProcessed,
41:       updated: priceResult.itemsUpdated,
42:       errors: priceResult.errors,
43:       timing: priceResult.timing,
44:     });
45: 
46:     // Log any errors
47:     const allErrors = [...cardResult.errors, ...priceResult.errors];
48:     if (allErrors.length > 0) {
49:       logger.error("Errors during sync:", { errors: allErrors });
50:     }
51:   } catch (error) {
52:     if (error instanceof TimeoutError) {
53:       logger.error("Sync operation timed out", { error });
54:     } else {
55:       logger.error("Test sync failed:", { error });
56:     }
57:     throw error;
58:   }
59: }
60: 
61: // Execute if run directly
62: if (require.main === module) {
63:   testSync()
64:     .then(() => {
65:       console.log("Test sync completed successfully!");
66:       process.exit(0);
67:     })
68:     .catch((error) => {
69:       console.error("Test failed:", error);
70:       process.exit(1);
71:     });
72: }
73: 
74: export { testSync };
</file>

<file path="src/services/cardSync.ts">
  1: // src/services/cardSync.ts
  2: import { db } from "../config/firebase";
  3: import { tcgcsvApi } from "../utils/api";
  4: import { storageService } from "./storageService";
  5: import { CardProduct, SyncResult, CardHashData, SyncTiming } from "../types";
  6: import { logger } from "../utils/logger";
  7: import * as crypto from "crypto";
  8: 
  9: export class CardSyncService {
 10:   private readonly CARDS_COLLECTION = "cards";
 11:   private readonly HASH_COLLECTION = "cardHashes";
 12:   private readonly BATCH_SIZE = 5;
 13: 
 14:   private calculateHash(data: CardHashData): string {
 15:     return crypto.createHash("md5").update(JSON.stringify(data)).digest("hex");
 16:   }
 17: 
 18:   private async getStoredHash(productId: number): Promise<string | null> {
 19:     const doc = await db.collection(this.HASH_COLLECTION).doc(productId.toString()).get();
 20:     return doc.exists ? doc.data()?.hash : null;
 21:   }
 22: 
 23:   private async updateStoredHash(productId: number, hash: string): Promise<void> {
 24:     await db.collection(this.HASH_COLLECTION).doc(productId.toString()).set({
 25:       hash,
 26:       lastUpdated: new Date(),
 27:     });
 28:   }
 29: 
 30:   private getCardNumber(card: CardProduct): string {
 31:     const numberField = card.extendedData.find((data) => data.name === "Number");
 32:     return numberField ? numberField.value : `P${card.productId}`;
 33:   }
 34: 
 35:   private getDocumentId(card: CardProduct): string {
 36:     const cardNumber = this.getCardNumber(card);
 37:     return `${card.productId}_${cardNumber}`;
 38:   }
 39: 
 40:   private isNonCardProduct(card: CardProduct): boolean {
 41:     const cardType = card.extendedData.find((data) => data.name === "CardType")?.value;
 42:     return !cardType || cardType.toLowerCase() === "sealed product";
 43:   }
 44: 
 45:   private updateTiming(timing: SyncTiming): void {
 46:     timing.lastUpdateTime = new Date();
 47:     if (timing.startTime) {
 48:       timing.duration = (timing.lastUpdateTime.getTime() - timing.startTime.getTime()) / 1000;
 49:     }
 50:   }
 51: 
 52:   private async processCardBatch(
 53:     cards: CardProduct[],
 54:     groupId: string,
 55:     options: { forceUpdate?: boolean } = {}
 56:   ): Promise<{
 57:     processed: number;
 58:     updated: number;
 59:     errors: string[];
 60:   }> {
 61:     const result = {
 62:       processed: 0,
 63:       updated: 0,
 64:       errors: [] as string[],
 65:     };
 66: 
 67:     const batches = [];
 68:     for (let i = 0; i < cards.length; i += this.BATCH_SIZE) {
 69:       batches.push(cards.slice(i, i + this.BATCH_SIZE));
 70:     }
 71: 
 72:     for (const batch of batches) {
 73:       try {
 74:         await Promise.all(
 75:           batch.map(async (card) => {
 76:             try {
 77:               result.processed++;
 78: 
 79:               const relevantData: CardHashData = {
 80:                 name: card.name,
 81:                 cleanName: card.cleanName,
 82:                 modifiedOn: card.modifiedOn,
 83:                 extendedData: card.extendedData,
 84:               };
 85:               const currentHash = this.calculateHash(relevantData);
 86:               const storedHash = await this.getStoredHash(card.productId);
 87: 
 88:               if (currentHash === storedHash && !options.forceUpdate) {
 89:                 logger.info(`Skipping card ${card.productId} - no changes`);
 90:                 return;
 91:               }
 92: 
 93:               const cardNumber = this.getCardNumber(card);
 94:               const documentId = this.getDocumentId(card);
 95: 
 96:               const imageResult = await storageService.processAndStoreImage(
 97:                 card.imageUrl,
 98:                 card.productId,
 99:                 groupId,
100:                 cardNumber
101:               );
102: 
103:               const cardDoc = {
104:                 ...card,
105:                 imageUrl: undefined,
106:                 highResUrl: imageResult.highResUrl,
107:                 lowResUrl: imageResult.lowResUrl,
108:                 imageMetadata: imageResult.metadata,
109:                 lastUpdated: new Date(),
110:                 groupId: parseInt(groupId),
111:                 isNonCard: this.isNonCardProduct(card),
112:                 cardNumber: cardNumber,
113:               };
114: 
115:               await db.collection(this.CARDS_COLLECTION).doc(documentId).set(cardDoc, { merge: true });
116:               await this.updateStoredHash(card.productId, currentHash);
117: 
118:               result.updated++;
119:               logger.info(`Updated card ${card.productId}: ${card.name}`);
120:             } catch (error) {
121:               const errorMessage = error instanceof Error ? error.message : "Unknown error";
122:               result.errors.push(`Error processing card ${card.productId}: ${errorMessage}`);
123:               logger.error(`Error processing card ${card.productId}`, { error: errorMessage });
124:             }
125:           })
126:         );
127:       } catch (error) {
128:         const errorMessage = error instanceof Error ? error.message : "Unknown error";
129:         result.errors.push(`Error processing batch: ${errorMessage}`);
130:         logger.error("Error processing batch", { error: errorMessage });
131:       }
132:     }
133: 
134:     return result;
135:   }
136: 
137:   async syncCards(options: { groupId?: string; forceUpdate?: boolean } = {}): Promise<SyncResult> {
138:     const result: SyncResult = {
139:       success: true,
140:       itemsProcessed: 0,
141:       itemsUpdated: 0,
142:       errors: [],
143:       timing: {
144:         startTime: new Date(),
145:       },
146:     };
147: 
148:     try {
149:       logger.info("Starting card sync", { options });
150: 
151:       const groups = options.groupId ? [{ groupId: options.groupId }] : await tcgcsvApi.getGroups();
152:       logger.info(`Found ${groups.length} groups to process`);
153: 
154:       for (const group of groups) {
155:         result.timing.groupStartTime = new Date();
156:         try {
157:           const cards = await tcgcsvApi.getGroupProducts(group.groupId);
158:           logger.info(`Retrieved ${cards.length} cards for group ${group.groupId}`);
159: 
160:           const batchResult = await this.processCardBatch(cards, group.groupId, options);
161: 
162:           result.itemsProcessed += batchResult.processed;
163:           result.itemsUpdated += batchResult.updated;
164:           result.errors.push(...batchResult.errors);
165: 
166:           this.updateTiming(result.timing);
167:         } catch (error) {
168:           const errorMessage = error instanceof Error ? error.message : "Unknown error";
169:           result.errors.push(`Error processing group ${group.groupId}: ${errorMessage}`);
170:           logger.error(`Error processing group ${group.groupId}`, { error: errorMessage });
171:         }
172:       }
173:     } catch (error) {
174:       result.success = false;
175:       const errorMessage = error instanceof Error ? error.message : "Unknown error";
176:       result.errors.push(`Card sync failed: ${errorMessage}`);
177:       logger.error("Card sync failed", { error: errorMessage });
178:     }
179: 
180:     result.timing.endTime = new Date();
181:     result.timing.duration = (result.timing.endTime.getTime() - result.timing.startTime.getTime()) / 1000;
182: 
183:     logger.logSyncStats({
184:       startTime: result.timing.startTime,
185:       endTime: result.timing.endTime,
186:       totalItems: result.itemsProcessed,
187:       successCount: result.itemsUpdated,
188:       errorCount: result.errors.length,
189:       duration: result.timing.duration,
190:     });
191: 
192:     return result;
193:   }
194: }
195: 
196: export const cardSync = new CardSyncService();
</file>

<file path="src/services/priceSync.ts">
  1: import { db } from "../config/firebase";
  2: import { tcgcsvApi } from "../utils/api";
  3: import { CardPrice, SyncResult, SyncTiming } from "../types";
  4: import { logger } from "../utils/logger";
  5: import * as crypto from "crypto";
  6: 
  7: export class PriceSyncService {
  8:   private readonly PRICES_COLLECTION = "prices";
  9:   private readonly HISTORICAL_PRICES_COLLECTION = "historicalPrices";
 10:   private readonly HASH_COLLECTION = "priceHashes";
 11: 
 12:   private calculateHash(price: CardPrice): string {
 13:     const relevantData = {
 14:       normal: price.normal,
 15:       foil: price.foil,
 16:       lastUpdated: price.lastUpdated,
 17:     };
 18:     return crypto.createHash("md5").update(JSON.stringify(relevantData)).digest("hex");
 19:   }
 20: 
 21:   private async getStoredHash(productId: number): Promise<string | null> {
 22:     const doc = await db.collection(this.HASH_COLLECTION).doc(productId.toString()).get();
 23:     return doc.exists ? doc.data()?.hash : null;
 24:   }
 25: 
 26:   private async updateStoredHash(productId: number, hash: string): Promise<void> {
 27:     await db.collection(this.HASH_COLLECTION).doc(productId.toString()).set({
 28:       hash,
 29:       lastUpdated: new Date(),
 30:     });
 31:   }
 32: 
 33:   private updateTiming(timing: SyncTiming): void {
 34:     timing.lastUpdateTime = new Date();
 35:     if (timing.startTime) {
 36:       timing.duration = (timing.lastUpdateTime.getTime() - timing.startTime.getTime()) / 1000;
 37:     }
 38:     logger.info(`Price sync progress - Duration: ${timing.duration}s`, {
 39:       lastUpdate: timing.lastUpdateTime,
 40:       duration: timing.duration,
 41:     });
 42:   }
 43: 
 44:   private async saveHistoricalPrice(price: CardPrice, groupId: string): Promise<void> {
 45:     const today = new Date();
 46:     today.setHours(0, 0, 0, 0);
 47:     const docId = `${price.productId}_${today.toISOString().split("T")[0]}`;
 48: 
 49:     // Check if we already have today's record
 50:     const docRef = db.collection(this.HISTORICAL_PRICES_COLLECTION).doc(docId);
 51:     const doc = await docRef.get();
 52: 
 53:     if (doc.exists) {
 54:       logger.info(`Historical price for ${price.productId} already exists for today, skipping`);
 55:       return;
 56:     }
 57: 
 58:     const historicalPrice = {
 59:       productId: price.productId,
 60:       groupId,
 61:       date: today,
 62:       ...(price.normal && {
 63:         normal: {
 64:           directLow: price.normal.directLowPrice,
 65:           high: price.normal.highPrice,
 66:           low: price.normal.lowPrice,
 67:           market: price.normal.marketPrice,
 68:           mid: price.normal.midPrice,
 69:         },
 70:       }),
 71:       ...(price.foil && {
 72:         foil: {
 73:           directLow: price.foil.directLowPrice,
 74:           high: price.foil.highPrice,
 75:           low: price.foil.lowPrice,
 76:           market: price.foil.marketPrice,
 77:           mid: price.foil.midPrice,
 78:         },
 79:       }),
 80:     };
 81: 
 82:     await docRef.set(historicalPrice);
 83:     logger.info(`Saved historical price for product ${price.productId} for date ${today.toISOString().split("T")[0]}`);
 84:   }
 85: 
 86:   async syncPrices(options: { groupId?: string; forceUpdate?: boolean } = {}): Promise<SyncResult> {
 87:     const result: SyncResult = {
 88:       success: true,
 89:       itemsProcessed: 0,
 90:       itemsUpdated: 0,
 91:       errors: [],
 92:       timing: {
 93:         startTime: new Date(),
 94:       },
 95:     };
 96: 
 97:     try {
 98:       logger.info("Starting price sync", { options });
 99: 
100:       // Use options.groupId if provided, otherwise get all groups
101:       const groups = options.groupId ? [{ groupId: options.groupId }] : await tcgcsvApi.getGroups();
102: 
103:       logger.info(`Found ${groups.length} groups to process`);
104: 
105:       for (const group of groups) {
106:         result.timing.groupStartTime = new Date();
107:         try {
108:           logger.info(`Processing prices for group ${group.groupId}`);
109:           const prices = await tcgcsvApi.getGroupPrices(group.groupId);
110:           logger.info(`Retrieved ${prices.length} prices for group ${group.groupId}`);
111: 
112:           for (const price of prices) {
113:             try {
114:               result.itemsProcessed++;
115:               this.updateTiming(result.timing);
116: 
117:               // Always save historical price data
118:               await this.saveHistoricalPrice(price, group.groupId);
119: 
120:               // Check if current price has changed
121:               const currentHash = this.calculateHash(price);
122:               const storedHash = await this.getStoredHash(price.productId);
123: 
124:               // Skip updating current price if unchanged
125:               if (currentHash === storedHash) {
126:                 logger.info(`Skipping price update for ${price.productId} - no changes`);
127:                 continue;
128:               }
129: 
130:               // Update current price
131:               const priceDoc = {
132:                 ...price,
133:                 lastUpdated: new Date(),
134:               };
135: 
136:               await db
137:                 .collection(this.PRICES_COLLECTION)
138:                 .doc(price.productId.toString())
139:                 .set(priceDoc, { merge: true });
140: 
141:               // Update hash
142:               await this.updateStoredHash(price.productId, currentHash);
143: 
144:               result.itemsUpdated++;
145:               logger.info(`Updated current price for product ${price.productId}`);
146:             } catch (error) {
147:               const errorMessage = error instanceof Error ? error.message : "Unknown error";
148:               result.errors.push(`Error processing price for product ${price.productId}: ${errorMessage}`);
149:               logger.error(`Error processing price for product ${price.productId}`, { error: errorMessage });
150:             }
151:           }
152:         } catch (error) {
153:           const errorMessage = error instanceof Error ? error.message : "Unknown error";
154:           result.errors.push(`Error processing prices for group ${group.groupId}: ${errorMessage}`);
155:           logger.error(`Error processing prices for group ${group.groupId}`, { error: errorMessage });
156:         }
157:       }
158:     } catch (error) {
159:       result.success = false;
160:       const errorMessage = error instanceof Error ? error.message : "Unknown error";
161:       result.errors.push(`Price sync failed: ${errorMessage}`);
162:       logger.error("Price sync failed", { error: errorMessage });
163:     }
164: 
165:     result.timing.endTime = new Date();
166:     result.timing.duration = (result.timing.endTime.getTime() - result.timing.startTime.getTime()) / 1000;
167: 
168:     logger.info(`Price sync completed in ${result.timing.duration}s`, {
169:       processed: result.itemsProcessed,
170:       updated: result.itemsUpdated,
171:       errors: result.errors.length,
172:       timing: result.timing,
173:     });
174: 
175:     return result;
176:   }
177: }
178: 
179: export const priceSync = new PriceSyncService();
</file>

<file path="src/services/storageService.ts">
  1: // src/services/storageService.ts
  2: import { S3Client, PutObjectCommand } from "@aws-sdk/client-s3";
  3: import axios from "axios";
  4: import { R2_CONFIG } from "../config/r2";
  5: import { logger } from "../utils/logger";
  6: import * as path from "path";
  7: import * as fs from "fs/promises";
  8: 
  9: interface ImageResult {
 10:   highResUrl: string;
 11:   lowResUrl: string;
 12:   metadata: {
 13:     contentType: string;
 14:     productId: string;
 15:     groupId: string;
 16:     lastUpdated: string;
 17:     isPlaceholder?: boolean;
 18:   };
 19: }
 20: 
 21: export class StorageService {
 22:   private client: S3Client;
 23:   private readonly bucket: string;
 24:   private readonly customDomain: string;
 25:   private readonly storagePath: string;
 26:   private readonly placeholderPath: string;
 27: 
 28:   constructor() {
 29:     this.client = new S3Client({
 30:       region: "auto",
 31:       endpoint: `https://${R2_CONFIG.ACCOUNT_ID}.r2.cloudflarestorage.com`,
 32:       credentials: {
 33:         accessKeyId: R2_CONFIG.ACCESS_KEY_ID,
 34:         secretAccessKey: R2_CONFIG.SECRET_ACCESS_KEY,
 35:       },
 36:     });
 37: 
 38:     this.bucket = R2_CONFIG.BUCKET_NAME;
 39:     this.customDomain = R2_CONFIG.CUSTOM_DOMAIN;
 40:     this.storagePath = R2_CONFIG.STORAGE_PATH;
 41:     this.placeholderPath = path.join(process.cwd(), "functions/public/assets/image-coming-soon.jpeg");
 42:   }
 43: 
 44:   private async getPlaceholderImage(): Promise<Buffer> {
 45:     try {
 46:       return await fs.readFile(this.placeholderPath);
 47:     } catch (error) {
 48:       logger.error("Failed to load placeholder image", { error });
 49:       throw new Error("Failed to load placeholder image");
 50:     }
 51:   }
 52: 
 53:   private shouldUsePlaceholder(imageUrl?: string): boolean {
 54:     if (!imageUrl) return true;
 55:     return imageUrl.includes("image-missing.svg") || !imageUrl.match(/_(200w|400w)\.jpg$/);
 56:   }
 57: 
 58:   // Simplified retry logic for image downloads/uploads
 59:   private async downloadImage(url: string, retries = 2): Promise<Buffer> {
 60:     for (let attempt = 0; attempt <= retries; attempt++) {
 61:       try {
 62:         const response = await axios.get(url, {
 63:           responseType: "arraybuffer",
 64:           timeout: 10000,
 65:           headers: {
 66:             "User-Agent": "FFTCG-Sync-Service/1.0",
 67:             "Accept": "image/jpeg,image/png,image/*",
 68:           },
 69:         });
 70:         return Buffer.from(response.data);
 71:       } catch (error) {
 72:         if (attempt === retries) throw error;
 73:         await new Promise((resolve) => setTimeout(resolve, 1000 * (attempt + 1)));
 74:       }
 75:     }
 76:     throw new Error("Download failed after retries");
 77:   }
 78: 
 79:   private async uploadToR2(buffer: Buffer, path: string, metadata: Record<string, string>): Promise<string> {
 80:     try {
 81:       await this.client.send(
 82:         new PutObjectCommand({
 83:           Bucket: this.bucket,
 84:           Key: path,
 85:           Body: buffer,
 86:           ContentType: "image/jpeg",
 87:           Metadata: metadata,
 88:           ContentLength: buffer.length,
 89:           CacheControl: "public, max-age=31536000",
 90:         })
 91:       );
 92:       return `${this.customDomain}/${path}`;
 93:     } catch (error) {
 94:       logger.error(`Failed to upload to R2: ${path}`, { error });
 95:       throw error;
 96:     }
 97:   }
 98: 
 99:   private getImagePath(groupId: string, cardNumber: string, resolution: "200w" | "400w"): string {
100:     return `${this.storagePath}/${groupId}/${cardNumber}_${resolution}.jpg`;
101:   }
102: 
103:   public async processAndStoreImage(
104:     imageUrl: string | undefined,
105:     productId: number,
106:     groupId: string,
107:     cardNumber: string
108:   ): Promise<ImageResult> {
109:     const metadata = {
110:       productId: productId.toString(),
111:       groupId,
112:       lastUpdated: new Date().toISOString(),
113:     };
114: 
115:     // Handle placeholder case
116:     if (this.shouldUsePlaceholder(imageUrl)) {
117:       try {
118:         const placeholderBuffer = await this.getPlaceholderImage();
119:         const placeholderMetadata = {
120:           ...metadata,
121:           isPlaceholder: "true",
122:         };
123: 
124:         // Store placeholder in both resolutions
125:         const [highResUrl, lowResUrl] = await Promise.all([
126:           this.uploadToR2(placeholderBuffer, this.getImagePath(groupId, cardNumber, "400w"), placeholderMetadata),
127:           this.uploadToR2(placeholderBuffer, this.getImagePath(groupId, cardNumber, "200w"), placeholderMetadata),
128:         ]);
129: 
130:         return {
131:           highResUrl,
132:           lowResUrl,
133:           metadata: {
134:             ...metadata,
135:             contentType: "image/jpeg",
136:             isPlaceholder: true,
137:           },
138:         };
139:       } catch (error) {
140:         logger.error("Failed to process placeholder image", { error, productId });
141:         throw error;
142:       }
143:     }
144: 
145:     // Handle normal image case
146:     try {
147:       if (!imageUrl) {
148:         throw new Error("No image URL provided");
149:       }
150: 
151:       // Convert URLs
152:       const lowResUrl = imageUrl;
153:       const highResUrl = imageUrl.replace("_200w.jpg", "_400w.jpg");
154: 
155:       // Download both versions
156:       const [highResBuffer, lowResBuffer] = await Promise.all([
157:         this.downloadImage(highResUrl),
158:         this.downloadImage(lowResUrl),
159:       ]);
160: 
161:       // Upload both versions
162:       const [storedHighResUrl, storedLowResUrl] = await Promise.all([
163:         this.uploadToR2(highResBuffer, this.getImagePath(groupId, cardNumber, "400w"), metadata),
164:         this.uploadToR2(lowResBuffer, this.getImagePath(groupId, cardNumber, "200w"), metadata),
165:       ]);
166: 
167:       return {
168:         highResUrl: storedHighResUrl,
169:         lowResUrl: storedLowResUrl,
170:         metadata: {
171:           ...metadata,
172:           contentType: "image/jpeg",
173:         },
174:       };
175:     } catch (error) {
176:       logger.error(`Failed to process images for ${productId}`, { error });
177: 
178:       // Fallback to placeholder on error
179:       return this.processAndStoreImage(undefined, productId, groupId, cardNumber);
180:     }
181:   }
182: }
183: 
184: export const storageService = new StorageService();
</file>

<file path="src/types/index.ts">
 1: export interface CardProduct {
 2:   productId: number;
 3:   name: string;
 4:   cleanName: string;
 5:   imageUrl?: string;
 6:   categoryId: number;
 7:   groupId: number;
 8:   url: string;
 9:   modifiedOn: string;
10:   imageCount: number;
11:   extendedData: Array<{
12:     name: string;
13:     displayName: string;
14:     value: string;
15:   }>;
16: }
17: 
18: export interface CardPrice {
19:   productId: number;
20:   normal?: {
21:     directLowPrice: number | null;
22:     highPrice: number;
23:     lowPrice: number;
24:     marketPrice: number;
25:     midPrice: number;
26:     subTypeName: "Normal";
27:   };
28:   foil?: {
29:     directLowPrice: number | null;
30:     highPrice: number;
31:     lowPrice: number;
32:     marketPrice: number;
33:     midPrice: number;
34:     subTypeName: "Foil";
35:   };
36:   lastUpdated: Date;
37: }
38: 
39: export interface HistoricalPrice {
40:   productId: number;
41:   date: Date;
42:   normal?: {
43:     directLow: number | null;
44:     high: number;
45:     low: number;
46:     market: number;
47:     mid: number;
48:   };
49:   foil?: {
50:     directLow: number | null;
51:     high: number;
52:     low: number;
53:     market: number;
54:     mid: number;
55:   };
56:   groupId: string;
57: }
58: 
59: export interface SyncTiming {
60:   startTime: Date;
61:   endTime?: Date;
62:   duration?: number;
63:   groupStartTime?: Date;
64:   imageStartTime?: Date;
65:   lastUpdateTime?: Date;
66: }
67: 
68: export interface SyncResult {
69:   success: boolean;
70:   itemsProcessed: number;
71:   itemsUpdated: number;
72:   errors: string[];
73:   timing: SyncTiming;
74: }
75: 
76: export interface CardHashData {
77:   name: string;
78:   cleanName: string;
79:   modifiedOn: string;
80:   extendedData: Array<{
81:     name: string;
82:     displayName: string;
83:     value: string;
84:   }>;
85: }
</file>

<file path="src/utils/api.ts">
 1: import axios, { AxiosError } from "axios";
 2: import { CardProduct, CardPrice } from "../types";
 3: import { logger } from "./logger";
 4: 
 5: export class TcgcsvApi {
 6:   private readonly baseUrl = "https://tcgcsv.com/tcgplayer";
 7:   private readonly categoryId = "24"; // Final Fantasy TCG
 8: 
 9:   private async makeRequest<T>(endpoint: string): Promise<T> {
10:     const url = `${this.baseUrl}/${endpoint}`;
11:     logger.info(`Making request to: ${url}`);
12: 
13:     try {
14:       const response = await axios.get<T>(url, {
15:         timeout: 30000,
16:         headers: {
17:           "Accept": "application/json",
18:           "User-Agent": "FFTCG-Sync-Service/1.0",
19:         },
20:       });
21:       return response.data;
22:     } catch (error) {
23:       if (error instanceof AxiosError && error.response?.status === 403) {
24:         throw new Error(`Access denied to TCGCSV API at path: ${endpoint}`);
25:       }
26:       throw error;
27:     }
28:   }
29: 
30:   async getGroups(): Promise<Array<{ groupId: string }>> {
31:     const response = await this.makeRequest<{ results: Array<{ groupId: string }> }>(`${this.categoryId}/groups`);
32:     logger.info(`Retrieved ${response.results.length} groups`);
33:     return response.results;
34:   }
35: 
36:   async getGroupProducts(groupId: string): Promise<CardProduct[]> {
37:     const response = await this.makeRequest<{ results: CardProduct[] }>(`${this.categoryId}/${groupId}/products`);
38:     logger.info(`Retrieved ${response.results.length} products for group ${groupId}`);
39:     return response.results;
40:   }
41: 
42:   async getGroupPrices(groupId: string): Promise<CardPrice[]> {
43:     interface PriceResponse {
44:       results: {
45:         productId: number;
46:         timestamp: string;
47:         normal?: {
48:           directLowPrice: number | null;
49:           highPrice: number;
50:           lowPrice: number;
51:           marketPrice: number;
52:           midPrice: number;
53:         };
54:         foil?: {
55:           directLowPrice: number | null;
56:           highPrice: number;
57:           lowPrice: number;
58:           marketPrice: number;
59:           midPrice: number;
60:         };
61:       }[];
62:     }
63: 
64:     const response = await this.makeRequest<PriceResponse>(`${this.categoryId}/${groupId}/prices`);
65:     logger.info(`Retrieved ${response.results.length} prices for group ${groupId}`);
66: 
67:     return response.results.map((price) => ({
68:       productId: price.productId,
69:       lastUpdated: new Date(price.timestamp),
70:       ...(price.normal && {
71:         normal: {
72:           directLowPrice: price.normal.directLowPrice,
73:           highPrice: price.normal.highPrice,
74:           lowPrice: price.normal.lowPrice,
75:           marketPrice: price.normal.marketPrice,
76:           midPrice: price.normal.midPrice,
77:           subTypeName: "Normal",
78:         },
79:       }),
80:       ...(price.foil && {
81:         foil: {
82:           directLowPrice: price.foil.directLowPrice,
83:           highPrice: price.foil.highPrice,
84:           lowPrice: price.foil.lowPrice,
85:           marketPrice: price.foil.marketPrice,
86:           midPrice: price.foil.midPrice,
87:           subTypeName: "Foil",
88:         },
89:       }),
90:     }));
91:   }
92: }
93: 
94: export const tcgcsvApi = new TcgcsvApi();
</file>

<file path="src/utils/logger.ts">
 1: // src/utils/logger.ts
 2: import { db } from "../config/firebase";
 3: import { environment } from "../config/environment";
 4: import { SyncResult } from "../types";
 5: 
 6: export type LogData = Record<string, unknown>;
 7: 
 8: export interface SyncStats {
 9:   startTime: Date;
10:   endTime?: Date;
11:   totalItems: number;
12:   successCount: number;
13:   errorCount: number;
14:   duration?: number;
15: }
16: 
17: export class Logger {
18:   private readonly COLLECTION = "logs";
19: 
20:   async info(message: string, data?: LogData | SyncResult): Promise<void> {
21:     await this.log("INFO", message, data);
22:   }
23: 
24:   async error(message: string, data?: LogData | { error: unknown }): Promise<void> {
25:     await this.log("ERROR", message, data);
26:   }
27: 
28:   async logSyncStats(stats: SyncStats): Promise<void> {
29:     const duration = stats.endTime ? (stats.endTime.getTime() - stats.startTime.getTime()) / 1000 : undefined;
30: 
31:     const successRate = ((stats.successCount / stats.totalItems) * 100).toFixed(1);
32: 
33:     console.log({
34:       duration: duration ? `${duration}s` : "unknown",
35:       successRate: `${successRate}%`,
36:       totalItems: stats.totalItems,
37:       successful: stats.successCount,
38:       errors: stats.errorCount,
39:     });
40: 
41:     if (!environment.isLocal) {
42:       await db.collection(this.COLLECTION).add({
43:         type: "SYNC_STATS",
44:         timestamp: new Date(),
45:         stats: {
46:           ...stats,
47:           duration,
48:           successRate: parseFloat(successRate),
49:         },
50:       });
51:     }
52:   }
53: 
54:   async log(
55:     level: "INFO" | "ERROR",
56:     message: string,
57:     metadata?: LogData | SyncResult | { error: unknown }
58:   ): Promise<void> {
59:     const entry = {
60:       timestamp: new Date(),
61:       level,
62:       message,
63:       metadata: metadata || null,
64:       environment: environment.nodeEnv,
65:     };
66: 
67:     // Always log to console with appropriate level
68:     const logFn = level === "ERROR" ? console.error : console.log;
69:     logFn(`[${level}] ${message}`, metadata || "");
70: 
71:     // Only log to Firestore if not in local development
72:     if (!environment.isLocal) {
73:       try {
74:         await db.collection(this.COLLECTION).add(entry);
75:       } catch (error) {
76:         console.error("Failed to write log to Firestore:", error);
77:         // Don't throw the error to prevent disrupting the application
78:       }
79:     }
80:   }
81: }
82: 
83: export const logger = new Logger();
</file>

<file path="src/utils/retention.ts">
 1: import { db } from "../config/firebase";
 2: import { logger } from "./logger";
 3: 
 4: export class RetentionService {
 5:   private readonly RETENTION_CONFIG = {
 6:     logs: 7,
 7:     cardHashes: 7,
 8:     priceHashes: 7,
 9:     syncMetadata: 7,
10:   };
11: 
12:   async cleanOldData(): Promise<void> {
13:     try {
14:       logger.info("Starting data retention cleanup");
15: 
16:       for (const [collection, days] of Object.entries(this.RETENTION_CONFIG)) {
17:         const cutoff = new Date();
18:         cutoff.setDate(cutoff.getDate() - days);
19: 
20:         const snapshot = await db.collection(collection).where("lastUpdated", "<", cutoff).get();
21: 
22:         if (!snapshot.empty) {
23:           const batch = db.batch();
24:           snapshot.docs.forEach((doc) => batch.delete(doc.ref));
25:           await batch.commit();
26: 
27:           logger.info(`Cleaned up ${snapshot.size} documents from ${collection}`);
28:         }
29:       }
30: 
31:       logger.info("Data retention cleanup completed");
32:     } catch (error) {
33:       const errorMessage = error instanceof Error ? error.message : "Unknown error";
34:       logger.error("Data retention cleanup failed", { error: errorMessage });
35:       throw error;
36:     }
37:   }
38: }
39: 
40: export const retention = new RetentionService();
</file>

<file path="src/utils/timeout.ts">
 1: // src/utils/timeout.ts
 2: export class TimeoutError extends Error {
 3:   constructor(message: string) {
 4:     super(message);
 5:     this.name = "TimeoutError";
 6:   }
 7: }
 8: 
 9: export function withTimeout<T>(promise: Promise<T>, timeoutMs: number): Promise<T> {
10:   return Promise.race([
11:     promise,
12:     new Promise<T>((_, reject) => {
13:       setTimeout(() => {
14:         reject(new TimeoutError(`Operation timed out after ${timeoutMs}ms`));
15:       }, timeoutMs);
16:     }),
17:   ]);
18: }
</file>

<file path="tsconfig.dev.json">
1: {
2:   "include": [
3:     ".eslintrc.js"
4:   ]
5: }
</file>

<file path="tsconfig.json">
 1: {
 2:   "compilerOptions": {
 3:     "module": "commonjs",
 4:     "moduleResolution": "node",
 5:     "noImplicitReturns": true,
 6:     "noUnusedLocals": true,
 7:     "outDir": "lib",
 8:     "sourceMap": true,
 9:     "strict": true,
10:     "target": "es2017",
11:     "skipLibCheck": true, // Add this line
12:     "esModuleInterop": true, // Make sure this is present
13:     "resolveJsonModule": true, // Add this line
14:     "baseUrl": "./src", // Add this line
15:     "paths": {
16:       // Add this section
17:       "*": ["*"]
18:     }
19:   },
20:   "compileOnSave": true,
21:   "include": ["src"],
22:   "exclude": ["node_modules", "lib"]
23: }
</file>

</repository_files>
