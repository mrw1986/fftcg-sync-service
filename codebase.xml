This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-01T04:45:01.922Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

- Line numbers have been added to the beginning of each line.
</notes>

<additional_info>

For more information about Repomix, visit: https://github.com/yamadashy/repomix
</additional_info>

</file_summary>

<repository_structure>
.eslintignore
.eslintrc.base.cjs
.eslintrc.fix.js
.eslintrc.js
package.json
src/config/firebase.ts
src/config/r2.ts
src/index.ts
src/services/cardSync.ts
src/services/historicalPriceSync.ts
src/services/priceSync.ts
src/services/r2Storage.ts
src/test/testEndpoints.ts
src/test/testHistoricalPrices.ts
src/test/testImageHandler.ts
src/test/testScheduledFunctions.ts
src/test/testSync.ts
src/test/validateSync.ts
src/test/verifyMigration.ts
src/types/index.ts
src/utils/backup.ts
src/utils/cache.ts
src/utils/databaseBackup.ts
src/utils/databaseCleanup.ts
src/utils/databaseMigration.ts
src/utils/databaseRefresh.ts
src/utils/databaseReset.ts
src/utils/error.ts
src/utils/imageAccessibilityChecker.ts
src/utils/imageCache.ts
src/utils/imageCompressor.ts
src/utils/imageHandler.ts
src/utils/imageMigration.ts
src/utils/imageValidator.ts
src/utils/logger.ts
src/utils/productValidation.ts
src/utils/progress.ts
src/utils/syncLogger.ts
src/utils/syncUtils.ts
tsconfig.dev.json
tsconfig.json
</repository_structure>

<repository_files>
This section contains the contents of the repository's files.

<file path=".eslintignore">
1: node_modules/
2: lib/
3: coverage/
4: *.d.ts
5: *.cjs
</file>

<file path=".eslintrc.base.cjs">
1: module.exports = {
2:     rules: {
3:       "valid-jsdoc": "off",
4:       "require-jsdoc": "off"
5:     }
6:   };
</file>

<file path=".eslintrc.fix.js">
 1: module.exports = {
 2:   extends: "./.eslintrc.js",
 3:   rules: {
 4:     "max-len": ["error", {"code": 120}],
 5:     "valid-jsdoc": 0,
 6:     "require-jsdoc": 0,
 7:     "@typescript-eslint/no-explicit-any": 0,
 8:     "@typescript-eslint/explicit-function-return-type": 0,
 9:     "@typescript-eslint/explicit-module-boundary-types": 0,
10:     "@typescript-eslint/no-unused-vars": ["error", {
11:       "argsIgnorePattern": "^_",
12:       "varsIgnorePattern": "^_",
13:     }],
14:     // Add these additional rules to be extra sure
15:     "jsdoc/require-jsdoc": 0,
16:     "jsdoc/valid-jsdoc": 0,
17:     "jsdoc/require-param-type": 0,
18:     "jsdoc/require-returns": 0,
19:   },
20: };
</file>

<file path=".eslintrc.js">
 1: module.exports = {
 2:   root: true,
 3:   env: {
 4:     es6: true,
 5:     node: true,
 6:   },
 7:   extends: [
 8:     "eslint:recommended",
 9:     "plugin:import/errors",
10:     "plugin:import/warnings",
11:     "plugin:import/typescript",
12:     "google",
13:     "plugin:@typescript-eslint/recommended",
14:   ],
15:   parser: "@typescript-eslint/parser",
16:   parserOptions: {
17:     project: ["tsconfig.json", "tsconfig.dev.json"],
18:     tsconfigRootDir: __dirname,
19:     sourceType: "module",
20:     createDefaultProgram: true,
21:   },
22:   ignorePatterns: [
23:     "/lib/**/*",
24:     "/generated/**/*",
25:     "node_modules/",
26:     "*.cjs",
27:   ],
28:   plugins: [
29:     "@typescript-eslint",
30:     "import",
31:   ],
32:   rules: {
33:     "quotes": ["error", "double"],
34:     "import/no-unresolved": 0,
35:     "indent": ["error", 2],
36:     "max-len": ["error", {"code": 120}],
37:     "@typescript-eslint/no-explicit-any": "off",
38:     "@typescript-eslint/no-unused-vars": ["error", {
39:       "argsIgnorePattern": "^_",
40:       "varsIgnorePattern": "^_",
41:     }],
42:     "valid-jsdoc": 0,
43:     "require-jsdoc": 0,
44:   },
45:   overrides: [
46:     {
47:       files: ["*.js", "*.cjs"],
48:       rules: {
49:         "@typescript-eslint/no-var-requires": "off",
50:       },
51:     },
52:   ],
53: };
</file>

<file path="package.json">
 1: {
 2:   "name": "functions",
 3:   "scripts": {
 4:     "clean": "rimraf lib",
 5:     "lint": "eslint --ext .js,.ts .",
 6:     "lint:fix": "eslint --ext .js,.ts . --fix",
 7:     "build": "npm run clean && tsc",
 8:     "build:watch": "tsc --watch",
 9:     "serve": "npm run build && firebase emulators:start --only functions,firestore,storage",
10:     "shell": "npm run build && firebase functions:shell",
11:     "start": "npm run shell",
12:     "deploy": "npm run lint:fix && firebase deploy --only functions",
13:     "logs": "firebase functions:log",
14:     "lint:fix:force": "eslint . --ext .js,.ts --fix --config .eslintrc.fix.js",
15:     "test:images": "ts-node src/test/testImageHandler.ts",
16:     "test:sync": "ts-node src/test/testSync.ts",
17:     "test:all": "npm run test:images && npm run test:sync",
18:     "backup-db": "ts-node src/utils/databaseBackup.ts",
19:     "clear-db": "ts-node src/utils/databaseReset.ts",
20:     "test:sync:cards": "ts-node src/test/validateSync.ts --type cards",
21:     "test:sync:prices": "ts-node src/test/validateSync.ts --type prices",
22:     "test:sync:all": "ts-node src/test/validateSync.ts --type all",
23:     "test:sync:group": "ts-node src/test/validateSync.ts --type all --group-id",
24:     "test:sync:storage": "ts-node src/test/validateSync.ts --type storage",
25:     "test:scheduled": "ts-node src/test/testScheduledFunctions.ts",
26:     "test:scheduled:card": "ts-node src/test/testScheduledFunctions.ts --type card",
27:     "test:scheduled:price": "ts-node src/test/testScheduledFunctions.ts --type price",
28:     "test:scheduled:dry": "ts-node src/test/testScheduledFunctions.ts --dry-run",
29:     "sync:group": "curl -X POST \"https://us-central1-fftcg-sync-service.cloudfunctions.net/manualGroupSync\" -H \"Content-Type: application/json\" -d \"{\\\"groupId\\\": \\\"%npm_config_groupid%\\\"}\"",
30:     "sync:group:dry": "curl -X POST \"https://us-central1-fftcg-sync-service.cloudfunctions.net/manualGroupSync\" -H \"Content-Type: application/json\" -d \"{\\\"groupId\\\": \\\"%npm_config_groupid%\\\", \\\"dryRun\\\": true}\"",
31:     "sync:historical": "ts-node src/test/testHistoricalPrices.ts",
32:     "sync:historical:date": "ts-node src/test/testHistoricalPrices.ts --date",
33:     "sync:historical:range": "ts-node src/test/testHistoricalPrices.ts --start-date --end-date"
34:   },
35:   "engines": {
36:     "node": "18"
37:   },
38:   "main": "lib/index.js",
39:   "dependencies": {
40:     "@aws-sdk/client-s3": "^3.485.0",
41:     "@aws-sdk/s3-request-presigner": "^3.485.0",
42:     "axios": "^1.7.7",
43:     "cors": "^2.8.5",
44:     "dotenv": "^16.4.7",
45:     "firebase-admin": "^13.0.2",
46:     "firebase-functions": "^6.2.0",
47:     "glob": "^10.4.5",
48:     "lru-cache": "^7.14.1",
49:     "sharp": "^0.33.1"
50:   },
51:   "devDependencies": {
52:     "@types/cors": "^2.8.17",
53:     "@types/express": "^4.17.21",
54:     "@types/node": "^18.19.64",
55:     "@typescript-eslint/eslint-plugin": "^6.0.0",
56:     "@typescript-eslint/parser": "^6.0.0",
57:     "eslint": "^8.0.0",
58:     "eslint-config-google": "^0.14.0",
59:     "eslint-plugin-import": "^2.25.4",
60:     "firebase-functions-test": "^3.4.0",
61:     "rimraf": "^5.0.0",
62:     "typescript": "^4.9.5"
63:   },
64:   "private": true
65: }
</file>

<file path="src/config/firebase.ts">
 1: // functions/src/config/firebase.ts
 2: 
 3: import * as admin from "firebase-admin";
 4: 
 5: const app = !admin.apps.length ? admin.initializeApp() : admin.app();
 6: const db = admin.firestore(app);
 7: 
 8: // Enable ignoreUndefinedProperties and other settings
 9: db.settings({
10:   ignoreUndefinedProperties: true,
11:   timestampsInSnapshots: true,
12: });
13: 
14: export {db};
15: 
16: export const COLLECTION = {
17:   CARDS: "cards",
18:   PRICES: "prices",
19:   SYNC_METADATA: "syncMetadata",
20:   LOGS: "logs",
21:   CARD_HASHES: "cardHashes",
22:   PRICE_HASHES: "priceHashes",
23:   IMAGE_METADATA: "imageMetadata",
24:   HISTORICAL_PRICES: "historicalPrices",
25:   PRICE_ARCHIVES: "priceArchives",
26: };
27: 
28: export const BASE_URL = "https://tcgcsv.com/tcgplayer";
29: export const FFTCG_CATEGORY_ID = "24";
30: 
31: export const runtimeOpts = {
32:   timeoutSeconds: 540,
33:   memory: "1GiB",
34: } as const;
</file>

<file path="src/config/r2.ts">
 1: // src/config/r2.ts
 2: 
 3: import * as dotenv from "dotenv";
 4: dotenv.config();
 5: 
 6: export const R2_CONFIG = {
 7:   ACCOUNT_ID: process.env.R2_ACCOUNT_ID || "",
 8:   ACCESS_KEY_ID: process.env.R2_ACCESS_KEY_ID || "",
 9:   SECRET_ACCESS_KEY: process.env.R2_SECRET_ACCESS_KEY || "",
10:   BUCKET_NAME: process.env.R2_BUCKET_NAME || "",
11:   STORAGE_PATH: process.env.R2_STORAGE_PATH || "",
12:   CUSTOM_DOMAIN: process.env.R2_CUSTOM_DOMAIN || "",
13: } as const;
14: 
15: if (!R2_CONFIG.ACCOUNT_ID) {
16:   console.warn("Missing R2_ACCOUNT_ID in .env file");
17: }
18: if (!R2_CONFIG.ACCESS_KEY_ID) {
19:   console.warn("Missing R2_ACCESS_KEY_ID in .env file");
20: }
21: if (!R2_CONFIG.SECRET_ACCESS_KEY) {
22:   console.warn("Missing R2_SECRET_ACCESS_KEY in .env file");
23: }
24: if (!R2_CONFIG.BUCKET_NAME) {
25:   console.warn("Missing R2_BUCKET_NAME in .env file");
26: }
27: if (!R2_CONFIG.STORAGE_PATH) {
28:   console.warn("Missing R2_STORAGE_PATH in .env file");
29: }
30: if (!R2_CONFIG.CUSTOM_DOMAIN) {
31:   console.warn("Missing R2_CUSTOM_DOMAIN in .env file");
32: }
33: 
34: console.log("R2 Config:", R2_CONFIG);
</file>

<file path="src/index.ts">
  1: // src/index.ts
  2: 
  3: import {onRequest} from "firebase-functions/v2/https";
  4: import {onSchedule} from "firebase-functions/v2/scheduler";
  5: import {Request, Response} from "express";
  6: import {syncCards} from "./services/cardSync";
  7: import {syncPrices} from "./services/priceSync";
  8: import {runtimeOpts} from "./config/firebase";
  9: import {SyncOptions} from "./types";
 10: import cors = require("cors");
 11: import * as dotenv from "dotenv";
 12: dotenv.config();
 13: 
 14: // Initialize CORS middleware with appropriate typing
 15: const corsMiddleware = cors({
 16:   origin: true,
 17:   methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
 18:   allowedHeaders: ["Content-Type", "Authorization"],
 19:   credentials: true,
 20: });
 21: 
 22: // Wrap async function with CORS and error handling
 23: const withCorsAndErrors = (
 24:   handler: (req: Request, res: Response) => Promise<void>
 25: ) => {
 26:   return async (req: Request, res: Response): Promise<void> => {
 27:     // Handle CORS preflight requests
 28:     if (req.method === "OPTIONS") {
 29:       return new Promise((resolve) => {
 30:         corsMiddleware(req, res, () => {
 31:           res.status(204).send("");
 32:           resolve();
 33:         });
 34:       });
 35:     }
 36: 
 37:     // Handle actual request with CORS
 38:     return new Promise((resolve, reject) => {
 39:       corsMiddleware(req, res, async () => {
 40:         try {
 41:           await handler(req, res);
 42:           resolve();
 43:         } catch (error) {
 44:           console.error("Function error:", error);
 45:           res.status(500).json({
 46:             error:
 47:               error instanceof Error ? error.message : "Internal server error",
 48:             timestamp: new Date().toISOString(),
 49:           });
 50:           reject(error);
 51:         }
 52:       });
 53:     });
 54:   };
 55: };
 56: 
 57: export const scheduledCardSync = onSchedule(
 58:   {
 59:     schedule: "0 21 * * *", // Daily at 21:00 UTC
 60:     timeZone: "UTC",
 61:     memory: runtimeOpts.memory,
 62:     timeoutSeconds: runtimeOpts.timeoutSeconds,
 63:     retryCount: 3,
 64:   },
 65:   async (_context) => {
 66:     try {
 67:       console.log("Starting scheduled card sync...");
 68: 
 69:       // Use syncCards with specific options for scheduled run
 70:       const result = await syncCards({
 71:         dryRun: false,
 72:         skipImages: false,
 73:         imagesOnly: false,
 74:         silent: false,
 75:         force: false,
 76:         // No groupId specified means it will process all groups
 77:       });
 78: 
 79:       console.log(`Sync completed. Processed ${result.cardCount} cards`);
 80:       console.log(`Images processed: ${result.imagesProcessed || 0}`);
 81:       console.log(`Images updated: ${result.imagesUpdated || 0}`);
 82: 
 83:       if (result.errors.length > 0) {
 84:         console.error("Errors during sync:", result.errors);
 85:       }
 86:     } catch (error) {
 87:       console.error("Card sync failed:", error);
 88:       throw error; // Allow Firebase to handle retry
 89:     }
 90:   }
 91: );
 92: 
 93: export const manualGroupSync = onRequest(
 94:   {
 95:     timeoutSeconds: runtimeOpts.timeoutSeconds,
 96:     memory: runtimeOpts.memory,
 97:     maxInstances: 1,
 98:   },
 99:   withCorsAndErrors(async (req: Request, res: Response): Promise<void> => {
100:     if (req.method !== "POST") {
101:       res.status(405).send("Method Not Allowed");
102:       return;
103:     }
104: 
105:     const {groupId, dryRun = false} = req.body;
106: 
107:     if (!groupId) {
108:       res.status(400).json({error: "groupId is required in request body"});
109:       return;
110:     }
111: 
112:     console.log(`Starting manual sync for group ${groupId}...`);
113:     console.log(`Dry run: ${dryRun}`);
114: 
115:     const result = await syncCards({
116:       dryRun,
117:       skipImages: false,
118:       imagesOnly: false,
119:       silent: false,
120:       force: false,
121:       groupId,
122:     });
123: 
124:     res.json({
125:       status: "success",
126:       groupId,
127:       dryRun,
128:       result: {
129:         cardsProcessed: result.cardCount,
130:         imagesProcessed: result.imagesProcessed || 0,
131:         imagesUpdated: result.imagesUpdated || 0,
132:         errors: result.errors,
133:       },
134:     });
135:   })
136: );
137: 
138: export const testCardSync = onRequest(
139:   {
140:     timeoutSeconds: runtimeOpts.timeoutSeconds,
141:     memory: runtimeOpts.memory,
142:     maxInstances: 1,
143:   },
144:   withCorsAndErrors(async (req: Request, res: Response): Promise<void> => {
145:     const options: SyncOptions = {
146:       dryRun: req.query.dryRun !== "false", // default to true
147:       limit: req.query.limit ? parseInt(req.query.limit as string) : 5,
148:       groupId: req.query.groupId as string,
149:     };
150: 
151:     const result = await syncCards(options);
152:     res.json(result);
153:   })
154: );
155: 
156: export const manualCardSync = onRequest(
157:   {
158:     timeoutSeconds: runtimeOpts.timeoutSeconds,
159:     memory: runtimeOpts.memory,
160:     maxInstances: 1,
161:   },
162:   withCorsAndErrors(async (_req: Request, res: Response): Promise<void> => {
163:     const result = await syncCards({dryRun: false});
164:     res.json(result);
165:   })
166: );
167: 
168: export const scheduledPriceSync = onSchedule(
169:   {
170:     schedule: "30 21 * * *", // Daily at 21:30 UTC
171:     timeZone: "UTC",
172:     memory: runtimeOpts.memory,
173:     timeoutSeconds: runtimeOpts.timeoutSeconds,
174:     retryCount: 3,
175:   },
176:   async (_context) => {
177:     await syncPrices();
178:   }
179: );
180: 
181: export const testPriceSync = onRequest(
182:   {
183:     timeoutSeconds: runtimeOpts.timeoutSeconds,
184:     memory: runtimeOpts.memory,
185:     maxInstances: 1,
186:   },
187:   withCorsAndErrors(async (req: Request, res: Response): Promise<void> => {
188:     const options: SyncOptions = {
189:       dryRun: req.query.dryRun === "true",
190:       limit: req.query.limit ? parseInt(req.query.limit as string) : undefined,
191:       groupId: req.query.groupId as string,
192:       productId: req.query.productId ?
193:         parseInt(req.query.productId as string) :
194:         undefined,
195:       showAll: req.query.showAll === "true",
196:     };
197: 
198:     const result = await syncPrices(options);
199:     res.json(result);
200:   })
201: );
202: 
203: export const manualPriceSync = onRequest(
204:   {
205:     timeoutSeconds: runtimeOpts.timeoutSeconds,
206:     memory: runtimeOpts.memory,
207:     maxInstances: 1,
208:   },
209:   withCorsAndErrors(async (_req: Request, res: Response): Promise<void> => {
210:     const result = await syncPrices();
211:     res.json(result);
212:   })
213: );
214: 
215: export const healthCheck = onRequest(
216:   {
217:     timeoutSeconds: 10,
218:     memory: "128MiB",
219:   },
220:   withCorsAndErrors(async (_req: Request, res: Response): Promise<void> => {
221:     res.json({
222:       status: "healthy",
223:       timestamp: new Date().toISOString(),
224:       version: "1.0.0",
225:     });
226:   })
227: );
</file>

<file path="src/services/cardSync.ts">
  1: // src/services/cardSync.ts
  2: 
  3: import {makeRequest, validateAndFixDocumentId} from "../utils/syncUtils";
  4: import {db, COLLECTION} from "../config/firebase";
  5: import {
  6:   CardProduct,
  7:   SyncOptions,
  8:   SyncMetadata,
  9:   GenericError,
 10:   GenericObject,
 11: } from "../types";
 12: import {logInfo, logError, logWarning} from "../utils/logger";
 13: import {imageHandler} from "../utils/imageHandler";
 14: import {FieldValue} from "firebase-admin/firestore";
 15: import {isAxiosError} from "axios";
 16: import {
 17:   validateFFTCGProduct,
 18:   isNonCardProduct,
 19: } from "../utils/productValidation";
 20: 
 21: /**
 22:  * Extract card number from a product.
 23:  */
 24: function getCardNumber(product: CardProduct): string {
 25:   // For non-card products, use productId and add a prefix
 26:   if (isNonCardProduct(product.name)) {
 27:     return `P${product.productId}`; // Add 'P' prefix to distinguish from card numbers
 28:   }
 29: 
 30:   const numberField = product.extendedData.find(
 31:     (data) => data.name === "Number"
 32:   );
 33:   if (!numberField) {
 34:     throw new Error(`Missing card number for productId: ${product.productId}`);
 35:   }
 36:   return numberField.value;
 37: }
 38: 
 39: /**
 40:  * Generate a document ID for a product.
 41:  */
 42: function getDocumentId(product: CardProduct): string {
 43:   if (isNonCardProduct(product.name)) {
 44:     // For non-card products, use productId as the base
 45:     return product.productId.toString();
 46:   }
 47: 
 48:   const cardNumber = getCardNumber(product);
 49:   return validateAndFixDocumentId(product.productId, cardNumber);
 50: }
 51: 
 52: /**
 53:  * Handle promo cards to ensure proper document ID generation.
 54:  */
 55: function getPromoDocumentId(product: CardProduct): string {
 56:   const extNumber = product.extendedData.find(
 57:     (data) => data.name === "extNumber"
 58:   );
 59:   if (!extNumber) {
 60:     throw new Error(
 61:       `Missing extNumber for promo productId: ${product.productId}`
 62:     );
 63:   }
 64: 
 65:   const [promoCardNumber] = extNumber.value.split("/");
 66:   return validateAndFixDocumentId(product.productId, promoCardNumber);
 67: }
 68: 
 69: /**
 70:  * Process images for a card product
 71:  */
 72: async function processImages(card: CardProduct): Promise<void> {
 73:   if (!card.imageUrl) {
 74:     await logWarning(`No image URL for card ${card.productId}`, {
 75:       cardName: card.name,
 76:       groupId: card.groupId,
 77:     });
 78:     return;
 79:   }
 80: 
 81:   try {
 82:     const isNonCard = isNonCardProduct(card.name);
 83:     const cardNumber = isNonCard ?
 84:       card.productId.toString() :
 85:       getCardNumber(card);
 86: 
 87:     const result = await imageHandler.processAndStoreImage(
 88:       card.imageUrl,
 89:       card.productId,
 90:       card.groupId.toString(),
 91:       cardNumber,
 92:       isNonCard
 93:     );
 94: 
 95:     const documentId = getDocumentId(card);
 96:     const docRef = db.collection(COLLECTION.CARDS).doc(documentId);
 97: 
 98:     // Check if document exists
 99:     const doc = await docRef.get();
100: 
101:     const updateData = {
102:       highResUrl: result.highResUrl,
103:       lowResUrl: result.lowResUrl,
104:       imageMetadata: result.metadata,
105:       lastUpdated: new Date(),
106:       isNonCard: isNonCard,
107:     };
108: 
109:     if (card.imageUrl) {
110:       Object.assign(updateData, {
111:         imageUrl: FieldValue.delete(),
112:       });
113:     }
114: 
115:     if (!doc.exists) {
116:       // Create new document if it doesn't exist
117:       await docRef.set({
118:         ...card,
119:         ...updateData,
120:       });
121:     } else {
122:       // Update existing document
123:       await docRef.update(updateData);
124:     }
125: 
126:     await logInfo(
127:       `Processed images for ${isNonCard ? "product" : "card"} ${
128:         card.productId
129:       }`,
130:       {
131:         cardName: card.name,
132:         groupId: card.groupId,
133:         highResUrl: result.highResUrl,
134:         lowResUrl: result.lowResUrl,
135:         updated: result.updated,
136:         isNonCard,
137:       }
138:     );
139:   } catch (error) {
140:     await logError(
141:       {
142:         message: error instanceof Error ? error.message : "Unknown error",
143:         name: error instanceof Error ? error.name : "UnknownError",
144:         code: "IMAGE_PROCESSING_ERROR",
145:       },
146:       `Failed to process images for ${card.productId}`
147:     );
148:     throw error;
149:   }
150: }
151: 
152: /**
153:  * Fetch products for a specific group.
154:  */
155: async function fetchProductsForGroup(groupId: string): Promise<CardProduct[]> {
156:   const categoryId = "24"; // FFTCG category ID
157:   let allProducts: CardProduct[] = [];
158: 
159:   try {
160:     if (!groupId) {
161:       // First fetch all groups
162:       const groupsResponse = await makeRequest<{
163:         results: Array<{ groupId: string }>;
164:       }>(`${categoryId}/groups`);
165: 
166:       await logInfo("Fetched groups", {
167:         count: groupsResponse.results.length,
168:       });
169: 
170:       // Process all groups
171:       for (const group of groupsResponse.results) {
172:         const productsResponse = await makeRequest<{ results: CardProduct[] }>(
173:           `${categoryId}/${group.groupId}/products`
174:         );
175:         allProducts = allProducts.concat(productsResponse.results);
176:       }
177:     } else {
178:       // Fetch products for specific group
179:       const productsResponse = await makeRequest<{ results: CardProduct[] }>(
180:         `${categoryId}/${groupId}/products`
181:       );
182:       allProducts = productsResponse.results;
183:     }
184: 
185:     await logInfo("Fetched products", {
186:       groupId: groupId || "all",
187:       count: allProducts.length,
188:     });
189: 
190:     return allProducts;
191:   } catch (error) {
192:     if (isAxiosError(error) && error.response?.status === 403) {
193:       await logError(
194:         error,
195:         `Access denied when fetching products for group ${groupId}`
196:       );
197:       throw new Error(
198:         "Access denied to TCGCSV API. Please check API access and paths."
199:       );
200:     }
201:     throw error;
202:   }
203: }
204: 
205: /**
206:  * Main function to sync cards.
207:  */
208: export async function syncCards(
209:   options: SyncOptions = {}
210: ): Promise<SyncMetadata> {
211:   await logInfo("Starting card sync", {
212:     options,
213:     endpoint: options.groupId ? `24/${options.groupId}/products` : "24/groups",
214:   });
215:   console.log("syncCards received options:", {
216:     dryRun: options.dryRun,
217:     limit: options.limit,
218:     groupId: options.groupId,
219:     skipImages: options.skipImages,
220:     imagesOnly: options.imagesOnly,
221:     silent: options.silent,
222:     force: options.force,
223:   });
224:   const metadata: SyncMetadata = {
225:     lastSync: new Date(),
226:     status: "in_progress",
227:     cardCount: 0,
228:     type: options.dryRun ? "manual" : "scheduled",
229:     groupsProcessed: 0,
230:     groupsUpdated: 0,
231:     errors: [],
232:     imagesProcessed: 0,
233:     imagesUpdated: 0,
234:   };
235: 
236:   await logInfo("Starting card sync", {options});
237: 
238:   try {
239:     const products = await fetchProductsForGroup(options.groupId || "");
240:     const writeBatch = db.batch();
241:     let batchCount = 0;
242: 
243:     for (const card of products) {
244:       try {
245:         // Add validation check
246:         const validation = validateFFTCGProduct(card);
247:         const isNonCard = isNonCardProduct(card.name);
248: 
249:         // Allow both valid cards and non-card products to be processed
250:         if (!validation.isValid && !isNonCard) {
251:           await logInfo(`Skipping invalid product: ${card.name}`, {
252:             productId: card.productId,
253:             reason: validation.reason,
254:           });
255:           continue;
256:         }
257: 
258:         const documentId = card.extendedData.some(
259:           (data) => data.name === "extNumber"
260:         ) ?
261:           getPromoDocumentId(card) :
262:           getDocumentId(card);
263: 
264:         await logInfo("Processing card", {
265:           productId: card.productId,
266:           documentId,
267:           groupId: card.groupId,
268:           isNonCard,
269:         });
270: 
271:         // Process card data
272:         writeBatch.set(db.collection(COLLECTION.CARDS).doc(documentId), {
273:           ...card,
274:           lastUpdated: new Date(),
275:           isNonCard,
276:         });
277: 
278:         batchCount++;
279:         metadata.cardCount++;
280: 
281:         // Commit batch if it reaches the limit
282:         if (batchCount >= 500) {
283:           await writeBatch.commit();
284:           batchCount = 0;
285:         }
286: 
287:         // Process images if not skipped
288:         if (!options.skipImages && card.imageUrl) {
289:           metadata.imagesProcessed = (metadata.imagesProcessed || 0) + 1;
290:           await processImages(card);
291:           metadata.imagesUpdated = (metadata.imagesUpdated || 0) + 1;
292:         }
293: 
294:         // Break if limit reached
295:         if (options.limit && metadata.cardCount >= options.limit) {
296:           break;
297:         }
298:       } catch (error) {
299:         const errorMessage =
300:           error instanceof Error ? error.message : "Unknown error";
301:         metadata.errors.push(
302:           `Error processing card ${card.productId}: ${errorMessage}`
303:         );
304:         await logError(error as GenericError, "syncCards");
305:       }
306:     }
307: 
308:     // Commit any remaining batch operations
309:     if (batchCount > 0) {
310:       await writeBatch.commit();
311:     }
312: 
313:     metadata.status =
314:       metadata.errors.length > 0 ? "completed_with_errors" : "success";
315:     await logInfo("Card sync completed", {metadata});
316:   } catch (error) {
317:     metadata.status = "failed";
318:     metadata.errors.push(
319:       error instanceof Error ? error.message : "Unknown error"
320:     );
321:     await logError(error as GenericError | GenericObject, "syncCards");
322:     throw error;
323:   }
324: 
325:   return metadata;
326: }
</file>

<file path="src/services/historicalPriceSync.ts">
  1: import axios from "axios";
  2: import * as sevenZip from "7zip-min";
  3: import { promisify } from "util";
  4: import { db, COLLECTION } from "../config/firebase";
  5: import { HistoricalPrice, PriceArchive } from "../types";
  6: import { logInfo, logError } from "../utils/logger";
  7: import { processInBatches } from "../utils/syncUtils";
  8: import * as fs from "fs";
  9: import * as path from "path";
 10: 
 11: const extract = promisify(sevenZip.unpack);
 12: 
 13: export class HistoricalPriceSync {
 14:   private readonly ARCHIVE_BASE_URL = "https://tcgcsv.com/archive/tcgplayer";
 15:   private readonly TEMP_DIR = path.join(__dirname, "../../temp");
 16: 
 17:   constructor() {
 18:     if (!fs.existsSync(this.TEMP_DIR)) {
 19:       fs.mkdirSync(this.TEMP_DIR, { recursive: true });
 20:     }
 21:   }
 22: 
 23:   private async downloadArchive(date: string): Promise<string> {
 24:     const fileName = `prices-${date}.ppmd.7z`;
 25:     const localPath = path.join(this.TEMP_DIR, fileName);
 26:     const url = `${this.ARCHIVE_BASE_URL}/${fileName}`;
 27: 
 28:     const response = await axios({
 29:       method: "GET",
 30:       url: url,
 31:       responseType: "stream",
 32:     });
 33: 
 34:     const writer = fs.createWriteStream(localPath);
 35:     response.data.pipe(writer);
 36: 
 37:     return new Promise((resolve, reject) => {
 38:       writer.on("finish", () => resolve(localPath));
 39:       writer.on("error", reject);
 40:     });
 41:   }
 42: 
 43:   private async extractArchive(archivePath: string): Promise<string> {
 44:     const extractPath = path.join(this.TEMP_DIR, "extracted");
 45:     await extract(archivePath, extractPath);
 46:     return extractPath;
 47:   }
 48: 
 49:   private async processPriceFile(
 50:     filePath: string,
 51:     date: string
 52:   ): Promise<HistoricalPrice[]> {
 53:     const content = await fs.promises.readFile(filePath, "utf8");
 54:     const prices: HistoricalPrice[] = [];
 55: 
 56:     const lines = content.split("\n").filter((line) => line.trim());
 57:     for (const line of lines) {
 58:       try {
 59:         const priceData = JSON.parse(line);
 60:         prices.push({
 61:           productId: priceData.productId,
 62:           date: new Date(date),
 63:           prices: {
 64:             normal: priceData.normal,
 65:             foil: priceData.foil,
 66:           },
 67:           groupId: priceData.groupId,
 68:           cardNumber: priceData.cardNumber,
 69:         });
 70:       } catch (error) {
 71:         await logError(error, `Error processing price line: ${line}`);
 72:       }
 73:     }
 74: 
 75:     return prices;
 76:   }
 77: 
 78:   async syncHistoricalPrices(date: string): Promise<void> {
 79:     try {
 80:       // Check if already processed
 81:       const archiveRef = db.collection(COLLECTION.PRICE_ARCHIVES).doc(date);
 82:       const archiveDoc = await archiveRef.get();
 83: 
 84:       if (archiveDoc.exists && archiveDoc.data()?.processed) {
 85:         await logInfo(`Archive for ${date} already processed`);
 86:         return;
 87:       }
 88: 
 89:       await logInfo(`Starting historical price sync for ${date}`);
 90: 
 91:       const archivePath = await this.downloadArchive(date);
 92:       const extractPath = await this.extractArchive(archivePath);
 93: 
 94:       // Process all price files in the extracted directory
 95:       const files = await fs.promises.readdir(extractPath);
 96:       for (const file of files) {
 97:         if (file.endsWith("prices")) {
 98:           const prices = await this.processPriceFile(
 99:             path.join(extractPath, file),
100:             date
101:           );
102: 
103:           // Store prices in batches
104:           await processInBatches(
105:             prices,
106:             async (batch) => {
107:               const writeBatch = db.batch();
108: 
109:               batch.forEach((price) => {
110:                 const docId = `${price.productId}_${date}`;
111:                 const docRef = db
112:                   .collection(COLLECTION.HISTORICAL_PRICES)
113:                   .doc(docId);
114:                 writeBatch.set(docRef, price);
115:               });
116: 
117:               await writeBatch.commit();
118:             },
119:             { batchSize: 500 }
120:           );
121:         }
122:       }
123: 
124:       // Mark archive as processed
125:       await archiveRef.set({
126:         date,
127:         url: `${this.ARCHIVE_BASE_URL}/prices-${date}.ppmd.7z`,
128:         processed: true,
129:         processedAt: new Date(),
130:       });
131: 
132:       // Cleanup
133:       await fs.promises.rm(archivePath);
134:       await fs.promises.rm(extractPath, { recursive: true });
135: 
136:       await logInfo(`Completed historical price sync for ${date}`);
137:     } catch (error) {
138:       await logError(error, `Failed to sync historical prices for ${date}`);
139:       throw error;
140:     }
141:   }
142: 
143:   async getLatestProcessedDate(): Promise<string | null> {
144:     const snapshot = await db
145:       .collection(COLLECTION.PRICE_ARCHIVES)
146:       .orderBy("date", "desc")
147:       .limit(1)
148:       .get();
149: 
150:     if (snapshot.empty) return null;
151:     return snapshot.docs[0].data().date;
152:   }
153: }
154: 
155: export const historicalPriceSync = new HistoricalPriceSync();
</file>

<file path="src/services/priceSync.ts">
  1: import {makeRequest, validateAndFixDocumentId} from "../utils/syncUtils";
  2: import {db, COLLECTION} from "../config/firebase";
  3: import {
  4:   CardPrice,
  5:   SyncOptions,
  6:   SyncMetadata,
  7:   GenericError,
  8:   GenericObject,
  9:   PriceData,
 10: } from "../types";
 11: import {logInfo, logError} from "../utils/logger";
 12: import {isAxiosError} from "axios";
 13: import { historicalPriceSync } from "./historicalPriceSync";
 14: 
 15: /**
 16:  * Fetch prices for a specific group.
 17:  */
 18: async function fetchPricesForGroup(groupId: string): Promise<CardPrice[]> {
 19:   const categoryId = "24"; // FFTCG category ID
 20:   let allPrices: CardPrice[] = [];
 21: 
 22:   try {
 23:     if (!groupId) {
 24:       // First fetch all groups
 25:       const groupsResponse = await makeRequest<{
 26:         results: Array<{ groupId: string }>;
 27:       }>(`${categoryId}/groups`);
 28: 
 29:       await logInfo("Fetched groups", {
 30:         count: groupsResponse.results.length,
 31:       });
 32: 
 33:       // Process all groups
 34:       for (const group of groupsResponse.results) {
 35:         const pricesResponse = await makeRequest<{ results: CardPrice[] }>(
 36:           `${categoryId}/${group.groupId}/prices`
 37:         );
 38:         allPrices = allPrices.concat(pricesResponse.results);
 39:       }
 40:     } else {
 41:       // Fetch prices for specific group
 42:       const pricesResponse = await makeRequest<{ results: CardPrice[] }>(
 43:         `${categoryId}/${groupId}/prices`
 44:       );
 45:       allPrices = pricesResponse.results;
 46:     }
 47: 
 48:     await logInfo("Fetched prices", {
 49:       groupId: groupId || "all",
 50:       count: allPrices.length,
 51:     });
 52: 
 53:     return allPrices;
 54:   } catch (error) {
 55:     if (isAxiosError(error) && error.response?.status === 403) {
 56:       await logError(
 57:         error,
 58:         `Access denied when fetching prices for group ${groupId}`
 59:       );
 60:       throw new Error(
 61:         "Access denied to TCGCSV API. Please check API access and paths."
 62:       );
 63:     }
 64:     throw error;
 65:   }
 66: }
 67: 
 68: /**
 69:  * Process and organize price data
 70:  */
 71: function organizePriceData(prices: CardPrice[]): Map<number, PriceData> {
 72:   const priceMap = new Map<number, PriceData>();
 73: 
 74:   for (const price of prices) {
 75:     const existingData = priceMap.get(price.productId) || {
 76:       lastUpdated: new Date(),
 77:       productId: price.productId,
 78:     };
 79: 
 80:     if (price.subTypeName === "Normal") {
 81:       existingData.normal = price;
 82:     } else if (price.subTypeName === "Foil") {
 83:       existingData.foil = price;
 84:     }
 85: 
 86:     priceMap.set(price.productId, existingData);
 87:   }
 88: 
 89:   return priceMap;
 90: }
 91: 
 92: /**
 93:  * Main function to sync prices.
 94:  */
 95: export async function syncPrices(
 96:   options: SyncOptions = {}
 97: ): Promise<SyncMetadata> {
 98:   await logInfo("Starting price sync", {
 99:     options,
100:     endpoint: options.groupId ? `24/${options.groupId}/prices` : "24/groups",
101:   });
102:   const metadata: SyncMetadata = {
103:     lastSync: new Date(),
104:     status: "in_progress",
105:     cardCount: 0,
106:     type: options.dryRun ? "manual" : "scheduled",
107:     groupsProcessed: 0,
108:     groupsUpdated: 0,
109:     errors: [],
110:   };
111: 
112:   await logInfo("Starting price sync", {options});
113: 
114:   try {
115:     const prices = await fetchPricesForGroup(options.groupId || "");
116:     const priceMap = organizePriceData(prices);
117:     const writeBatch = db.batch();
118:     let batchCount = 0;
119: 
120:     for (const [productId, priceData] of priceMap) {
121:       try {
122:         const documentId = validateAndFixDocumentId(
123:           productId,
124:           productId.toString()
125:         );
126: 
127:         await logInfo("Processing price", {
128:           productId,
129:           documentId,
130:         });
131: 
132:         writeBatch.set(db.collection(COLLECTION.PRICES).doc(documentId), {
133:           ...priceData,
134:           lastUpdated: new Date(),
135:         });
136: 
137:         batchCount++;
138:         metadata.cardCount++;
139: 
140:         // Commit batch if it reaches the limit
141:         if (batchCount >= 500) {
142:           await writeBatch.commit();
143:           batchCount = 0;
144:         }
145: 
146:         // Break if limit reached
147:         if (options.limit && metadata.cardCount >= options.limit) {
148:           break;
149:         }
150: 
151:         // Save historical data after processing current prices
152:         await historicalPriceSync.saveDailyPrices(prices);
153:       } catch (error) {
154:         const errorMessage =
155:           error instanceof Error ? error.message : "Unknown error";
156:         metadata.errors.push(
157:           `Error processing price for product ${productId}: ${errorMessage}`
158:         );
159:         await logError(error as GenericError, "syncPrices");
160:       }
161:     }
162: 
163:     // Commit any remaining batch operations
164:     if (batchCount > 0) {
165:       await writeBatch.commit();
166:     }
167: 
168:     metadata.status =
169:       metadata.errors.length > 0 ? "completed_with_errors" : "success";
170:     await logInfo("Price sync completed", {metadata});
171:   } catch (error) {
172:     metadata.status = "failed";
173:     metadata.errors.push(
174:       error instanceof Error ? error.message : "Unknown error"
175:     );
176:     await logError(error as GenericError | GenericObject, "syncPrices");
177:     throw error;
178:   }
179: 
180:   return metadata;
181: }
</file>

<file path="src/services/r2Storage.ts">
  1: import {
  2:   S3Client,
  3:   PutObjectCommand,
  4:   HeadObjectCommand,
  5:   DeleteObjectCommand,
  6: } from "@aws-sdk/client-s3";
  7: import {R2_CONFIG} from "../config/r2";
  8: import {logInfo, logWarning} from "../utils/logger";
  9: import {ImageMetadata} from "../types";
 10: 
 11: export class R2Storage {
 12:   private client: S3Client;
 13:   private bucket: string;
 14:   private storagePath: string;
 15:   private customDomain: string;
 16: 
 17:   constructor() {
 18:     this.client = new S3Client({
 19:       region: "auto",
 20:       endpoint: `https://${R2_CONFIG.ACCOUNT_ID}.r2.cloudflarestorage.com`,
 21:       credentials: {
 22:         accessKeyId: R2_CONFIG.ACCESS_KEY_ID,
 23:         secretAccessKey: R2_CONFIG.SECRET_ACCESS_KEY,
 24:       },
 25:     });
 26:     this.bucket = R2_CONFIG.BUCKET_NAME;
 27:     this.storagePath = R2_CONFIG.STORAGE_PATH;
 28:     this.customDomain = R2_CONFIG.CUSTOM_DOMAIN;
 29:   }
 30: 
 31:   private getFullPath(path: string): string {
 32:     return `${this.storagePath}/${path}`;
 33:   }
 34: 
 35:   async uploadImage(
 36:     buffer: Buffer,
 37:     path: string,
 38:     metadata: ImageMetadata
 39:   ): Promise<string> {
 40:     const fullPath = this.getFullPath(path);
 41: 
 42:     try {
 43:       // Pre-upload validation
 44:       if (!buffer || buffer.length === 0) {
 45:         throw new Error("Empty buffer provided for upload");
 46:       }
 47: 
 48:       // Convert metadata to string values for S3 compatibility
 49:       const stringMetadata: Record<string, string> = Object.entries(
 50:         metadata
 51:       ).reduce((acc, [key, value]) => {
 52:         if (value !== undefined && value !== null) {
 53:           if (value instanceof Date) {
 54:             acc[key] = value.toISOString();
 55:           } else {
 56:             acc[key] = String(value);
 57:           }
 58:         }
 59:         return acc;
 60:       }, {} as Record<string, string>);
 61: 
 62:       // Upload to R2
 63:       await this.client.send(
 64:         new PutObjectCommand({
 65:           Bucket: this.bucket,
 66:           Key: fullPath,
 67:           Body: buffer,
 68:           ContentType: "image/jpeg",
 69:           ContentLength: buffer.length,
 70:           Metadata: stringMetadata,
 71:           CacheControl: "public, max-age=31536000",
 72:         })
 73:       );
 74: 
 75:       // Verify upload
 76:       const exists = await this.fileExists(path);
 77:       if (!exists) {
 78:         throw new Error("Upload verification failed - file not found");
 79:       }
 80: 
 81:       const publicUrl = this.getPublicUrl(fullPath);
 82: 
 83:       await logInfo("Image upload successful", {
 84:         path: fullPath,
 85:         size: buffer.length,
 86:         url: publicUrl,
 87:       });
 88: 
 89:       return publicUrl;
 90:     } catch (error) {
 91:       await logWarning("Image upload failed", {
 92:         path: fullPath,
 93:         error: error instanceof Error ? error.message : "Unknown error",
 94:       });
 95:       throw error;
 96:     }
 97:   }
 98: 
 99:   async getImageMetadata(path: string): Promise<Record<string, string> | null> {
100:     const fullPath = this.getFullPath(path);
101:     try {
102:       const response = await this.client.send(
103:         new HeadObjectCommand({
104:           Bucket: this.bucket,
105:           Key: fullPath,
106:         })
107:       );
108: 
109:       return response.Metadata || null;
110:     } catch (error) {
111:       if ((error as any).name === "NotFound") {
112:         return null;
113:       }
114:       throw error;
115:     }
116:   }
117: 
118:   async fileExists(path: string): Promise<boolean> {
119:     const fullPath = this.getFullPath(path);
120:     try {
121:       await this.client.send(
122:         new HeadObjectCommand({
123:           Bucket: this.bucket,
124:           Key: fullPath,
125:         })
126:       );
127:       return true;
128:     } catch (error) {
129:       if ((error as any).name === "NotFound") {
130:         return false;
131:       }
132:       throw error;
133:     }
134:   }
135: 
136:   async deleteFile(path: string): Promise<void> {
137:     const fullPath = this.getFullPath(path);
138:     try {
139:       await this.client.send(
140:         new DeleteObjectCommand({
141:           Bucket: this.bucket,
142:           Key: fullPath,
143:         })
144:       );
145: 
146:       await logInfo("File deleted successfully", {path: fullPath});
147:     } catch (error) {
148:       await logWarning("File deletion failed", {
149:         path: fullPath,
150:         error: error instanceof Error ? error.message : "Unknown error",
151:       });
152:       throw error;
153:     }
154:   }
155: 
156:   getPublicUrl(path: string): string {
157:     // Ensure path starts without a slash and storagePath is included
158:     const cleanPath = path.replace(/^\/+/, "");
159:     return `${this.customDomain}/${cleanPath}`;
160:   }
161: 
162:   async validateStorageSetup(): Promise<boolean> {
163:     try {
164:       const testKey = `test/validate-${Date.now()}.txt`;
165:       const testContent = Buffer.from("Storage validation test");
166: 
167:       // Test write
168:       await this.uploadImage(testContent, testKey, {
169:         contentType: "text/plain",
170:         size: testContent.length,
171:         updated: new Date(),
172:         hash: "test",
173:       });
174: 
175:       // Test read
176:       const exists = await this.fileExists(testKey);
177: 
178:       // Test delete
179:       await this.deleteFile(testKey);
180: 
181:       return exists;
182:     } catch (error) {
183:       await logWarning("Storage validation failed", {
184:         error: error instanceof Error ? error.message : "Unknown error",
185:       });
186:       return false;
187:     }
188:   }
189: }
190: 
191: export const r2Storage = new R2Storage();
</file>

<file path="src/test/testEndpoints.ts">
 1: import axios, {isAxiosError} from "axios";
 2: 
 3: const FIREBASE_REGION = "us-central1";
 4: const PROJECT_ID = "fftcg-sync-service";
 5: const BASE_URL = `https://${FIREBASE_REGION}-${PROJECT_ID}.cloudfunctions.net`;
 6: 
 7: interface SyncResponse {
 8:   lastSync: Date;
 9:   status: string;
10:   cardCount: number;
11:   type: string;
12:   groupsProcessed: number;
13:   groupsUpdated: number;
14:   errors: string[];
15:   duration?: number;
16: }
17: 
18: async function testEndpoints() {
19:   try {
20:     // Test card sync
21:     console.log("\nTesting card sync...");
22:     const cardResponse = await axios.get<SyncResponse>(
23:       `${BASE_URL}/testCardSync`,
24:       {
25:         params: {
26:           limit: 5,
27:           dryRun: true,
28:           groupId: "23783",
29:           productId: 477236, // Added specific product ID
30:         },
31:       }
32:     );
33:     console.log(
34:       "Card sync results:",
35:       JSON.stringify(cardResponse.data, null, 2)
36:     );
37: 
38:     // Test price sync
39:     console.log("\nTesting price sync...");
40:     const priceResponse = await axios.get<SyncResponse>(
41:       `${BASE_URL}/testPriceSync`,
42:       {
43:         params: {
44:           groupId: "23783",
45:           dryRun: true,
46:           limit: 5,
47:           productId: 477236, // Added specific product ID
48:         },
49:       }
50:     );
51:     console.log(
52:       "Price sync results:",
53:       JSON.stringify(priceResponse.data, null, 2)
54:     );
55: 
56:     // Test health check
57:     console.log("\nTesting health check...");
58:     const healthResponse = await axios.get(`${BASE_URL}/healthCheck`);
59:     console.log(
60:       "Health check response:",
61:       JSON.stringify(healthResponse.data, null, 2)
62:     );
63:   } catch (error) {
64:     if (isAxiosError(error)) {
65:       console.error("Test failed:", error.response?.data || error.message);
66:       console.error("Status:", error.response?.status);
67:       console.error("Headers:", error.response?.headers);
68:     } else {
69:       console.error("Test failed:", error);
70:     }
71:     process.exit(1);
72:   }
73: }
74: 
75: // Execute tests
76: console.log("Starting endpoint tests...");
77: testEndpoints()
78:   .then(() => {
79:     console.log("All tests completed!");
80:   })
81:   .catch(console.error);
</file>

<file path="src/test/testHistoricalPrices.ts">
 1: import { historicalPriceSync } from "../services/historicalPriceSync";
 2: import { db, COLLECTION } from "../config/firebase";
 3: 
 4: async function testHistoricalPriceSync() {
 5:   try {
 6:     console.log("\n=== Testing Historical Price Sync ===");
 7: 
 8:     // Test specific date
 9:     const testDate = "2024-02-08";
10:     console.log(`\nTesting sync for date: ${testDate}`);
11: 
12:     await historicalPriceSync.syncHistoricalPrices(testDate);
13: 
14:     // Verify data
15:     const snapshot = await db
16:       .collection(COLLECTION.HISTORICAL_PRICES)
17:       .where("date", "==", new Date(testDate))
18:       .limit(5)
19:       .get();
20: 
21:     console.log("\nSample of synced prices:");
22:     snapshot.docs.forEach((doc) => {
23:       const data = doc.data();
24:       console.log(`\nProduct ID: ${data.productId}`);
25:       if (data.prices.normal) {
26:         console.log("Normal prices:", data.prices.normal);
27:       }
28:       if (data.prices.foil) {
29:         console.log("Foil prices:", data.prices.foil);
30:       }
31:     });
32: 
33:     // Check archive status
34:     const archiveDoc = await db
35:       .collection(COLLECTION.PRICE_ARCHIVES)
36:       .doc(testDate)
37:       .get();
38: 
39:     console.log("\nArchive status:", archiveDoc.data());
40:   } catch (error) {
41:     console.error("Test failed:", error);
42:     throw error;
43:   }
44: }
45: 
46: // Execute if run directly
47: if (require.main === module) {
48:   testHistoricalPriceSync()
49:     .then(() => {
50:       console.log("\nHistorical price sync test completed!");
51:       process.exit(0);
52:     })
53:     .catch((error) => {
54:       console.error("\nTest failed:", error);
55:       process.exit(1);
56:     });
57: }
</file>

<file path="src/test/testImageHandler.ts">
  1: // src/test/testImageHandler.ts
  2: process.env.NODE_ENV = "test";
  3: process.env.FORCE_UPDATE = "true";
  4: 
  5: import {ImageHandler} from "../utils/imageHandler";
  6: 
  7: const TEST_CASES = [
  8:   {
  9:     imageUrl: "https://tcgplayer-cdn.tcgplayer.com/product/477236_200w.jpg",
 10:     groupId: "23783",
 11:     productId: 477236,
 12:     cardNumber: "P477236", // Using the new prefix format
 13:     description: "FFVII Boss Deck",
 14:     isNonCard: true,
 15:   },
 16:   {
 17:     imageUrl: "https://tcgplayer-cdn.tcgplayer.com/product/478471_200w.jpg",
 18:     groupId: "23783",
 19:     productId: 478471,
 20:     cardNumber: "23783-001L",
 21:     description: "FFVII Cloud - Legend",
 22:     isNonCard: false,
 23:   },
 24: ];
 25: 
 26: async function testImageProcessing() {
 27:   try {
 28:     console.log("\n=== Testing Image Handler ===");
 29:     const imageHandler = new ImageHandler();
 30: 
 31:     for (const testCase of TEST_CASES) {
 32:       console.log(`\nProcessing: ${testCase.description}`);
 33: 
 34:       // Test URL generation
 35:       console.log("\nURL Structure Test:");
 36:       console.log(`Original (TCGPlayer): ${testCase.imageUrl}`);
 37:       console.log(
 38:         `Expected High-res: ${testCase.imageUrl.replace(
 39:           "_200w.jpg",
 40:           "_400w.jpg"
 41:         )}`
 42:       );
 43:       console.log(
 44:         `Expected Low-res: ${testCase.imageUrl.replace(".jpg", "_200w.jpg")}`
 45:       );
 46: 
 47:       // Test full image processing
 48:       console.log("\n=== Processing Test ===");
 49:       const result = await imageHandler.processAndStoreImage(
 50:         testCase.imageUrl,
 51:         testCase.productId,
 52:         testCase.groupId,
 53:         testCase.cardNumber,
 54:         testCase.isNonCard // Pass the isNonCard flag
 55:       );
 56: 
 57:       console.log("\nProcessing Results:");
 58:       console.log(`Status: ${result.updated ? "Updated" : "Unchanged"}`);
 59:       console.log("\nURL Structure:");
 60:       console.log(`High-res URL: ${result.highResUrl}`);
 61:       console.log(`Low-res URL: ${result.lowResUrl}`);
 62: 
 63:       console.log("\nMetadata:");
 64:       console.log(`Content Type: ${result.metadata.contentType}`);
 65:       console.log(
 66:         `Original Size: ${(result.metadata.originalSize || 0) / 1024}KB`
 67:       );
 68:       console.log(
 69:         `High-res Size: ${(result.metadata.highResSize || 0) / 1024}KB`
 70:       );
 71:       console.log(
 72:         `Low-res Size: ${(result.metadata.lowResSize || 0) / 1024}KB`
 73:       );
 74:       console.log(`Last Updated: ${result.metadata.updated.toISOString()}`);
 75: 
 76:       // Verify URL accessibility
 77:       console.log("\nVerifying URL accessibility:");
 78:       const urlsToTest = [
 79:         {type: "High-res", url: result.highResUrl},
 80:         {type: "Low-res", url: result.lowResUrl},
 81:       ];
 82: 
 83:       for (const {type, url} of urlsToTest) {
 84:         if (url) {
 85:           try {
 86:             const response = await fetch(url, {method: "HEAD"});
 87:             console.log(
 88:               `${type} URL accessible: ${response.ok} (${response.status})`
 89:             );
 90:             if (response.ok) {
 91:               console.log(
 92:                 `Cache-Control: ${response.headers.get("cache-control")}`
 93:               );
 94:             }
 95:           } catch (error) {
 96:             console.error(`${type} URL not accessible:`, error);
 97:           }
 98:         } else {
 99:           console.log(`${type} URL not generated`);
100:         }
101:       }
102: 
103:       // Test metadata storage
104:       console.log("\nVerifying metadata structure:");
105:       console.log(
106:         "- No URLs in metadata:",
107:         !Object.keys(result.metadata).some((key) =>
108:           key.toLowerCase().includes("url")
109:         )
110:       );
111:       console.log(
112:         "- Has required fields:",
113:         result.metadata.contentType &&
114:           result.metadata.size !== undefined &&
115:           result.metadata.updated instanceof Date
116:       );
117:     }
118: 
119:     // Test cleanup (dry run)
120:     console.log("\n=== Cleanup Test (Dry Run) ===");
121:   } catch (error) {
122:     console.error("\nTest failed:", error);
123:     process.exit(1);
124:   }
125: }
126: 
127: async function runTests() {
128:   console.log("Starting Image Handler tests...");
129:   console.log("Testing new URL structure and public access...");
130: 
131:   try {
132:     await testImageProcessing();
133:     console.log("\nAll Image Handler tests completed successfully!");
134:   } catch (error) {
135:     console.error("\nTests failed:", error);
136:     process.exit(1);
137:   }
138: }
139: 
140: // Execute the tests
141: runTests().catch(console.error);
</file>

<file path="src/test/testScheduledFunctions.ts">
  1: // src/test/testScheduledFunctions.ts
  2: import {syncCards} from "../services/cardSync";
  3: import {syncPrices} from "../services/priceSync";
  4: 
  5: interface TestOptions {
  6:   type?: "card" | "price" | "both";
  7:   dryRun?: boolean;
  8:   groupId?: string | number; // Update to allow both string and number
  9:   limit?: number;
 10: }
 11: 
 12: async function testScheduledFunctions(options: TestOptions = {}) {
 13:   const {type = "both", dryRun = false, groupId, limit} = options;
 14: 
 15:   try {
 16:     console.log("\nTest Configuration:");
 17:     console.log("------------------");
 18:     console.log(`Type: ${type}`);
 19:     console.log(`Dry Run: ${dryRun}`);
 20:     if (groupId) console.log(`Group ID: ${groupId}`);
 21:     if (limit) console.log(`Limit: ${limit}`);
 22:     console.log("");
 23: 
 24:     if (type === "both" || type === "card") {
 25:       console.log("Testing card sync functionality...");
 26:       const cardResult = await syncCards({
 27:         dryRun,
 28:         limit,
 29:         groupId: groupId?.toString(), // Ensure groupId is passed as string
 30:         skipImages: false,
 31:         imagesOnly: false,
 32:         silent: false,
 33:         force: false,
 34:       });
 35:       console.log("Card sync completed");
 36:       console.log("Results:", {
 37:         cardsProcessed: cardResult.cardCount,
 38:         imagesProcessed: cardResult.imagesProcessed,
 39:         imagesUpdated: cardResult.imagesUpdated,
 40:         errors: cardResult.errors,
 41:       });
 42:     }
 43: 
 44:     if (type === "both" || type === "price") {
 45:       console.log("\nTesting price sync functionality...");
 46:       const priceResult = await syncPrices({
 47:         dryRun,
 48:         limit,
 49:         groupId: groupId?.toString(), // Ensure groupId is passed as string
 50:         silent: false,
 51:         force: false,
 52:       });
 53:       console.log("Price sync completed");
 54:       console.log("Results:", {
 55:         pricesProcessed: priceResult.cardCount,
 56:         groupsUpdated: priceResult.groupsUpdated,
 57:         errors: priceResult.errors,
 58:       });
 59:     }
 60:   } catch (error) {
 61:     console.error("Test failed:", error);
 62:     throw error;
 63:   }
 64: }
 65: 
 66: // Parse command line arguments if running directly
 67: // src/test/testScheduledFunctions.ts
 68: if (require.main === module) {
 69:   const args = process.argv.slice(2);
 70:   const options: TestOptions = {
 71:     type: "both",
 72:     dryRun: false,
 73:     groupId: undefined,
 74:     limit: undefined,
 75:   };
 76: 
 77:   // First, check for positional arguments (for backward compatibility)
 78:   if (args.length > 0 && !args[0].startsWith("--")) {
 79:     options.groupId = args[0];
 80:   }
 81: 
 82:   // Then check for named arguments
 83:   for (let i = 0; i < args.length; i++) {
 84:     const arg = args[i];
 85:     const nextArg = args[i + 1];
 86: 
 87:     switch (arg) {
 88:     case "--type":
 89:       if (nextArg && ["card", "price", "both"].includes(nextArg)) {
 90:         options.type = nextArg as "card" | "price" | "both";
 91:         i++;
 92:       }
 93:       break;
 94:     case "--group-id":
 95:       if (nextArg && !nextArg.startsWith("--")) {
 96:         options.groupId = nextArg;
 97:         i++;
 98:       }
 99:       break;
100:     case "--dry-run":
101:       options.dryRun = true;
102:       break;
103:     case "--limit":
104:       if (nextArg && !isNaN(Number(nextArg))) {
105:         options.limit = parseInt(nextArg, 10);
106:         i++;
107:       }
108:       break;
109:     }
110:   }
111: 
112:   // Debug logging
113:   console.log("\nCommand line parsing:");
114:   console.log("Raw arguments:", args);
115:   console.log("Parsed options:", JSON.stringify(options, null, 2));
116: 
117:   testScheduledFunctions(options)
118:     .then(() => {
119:       console.log("\nAll sync function tests completed successfully!");
120:       process.exit(0);
121:     })
122:     .catch((error) => {
123:       console.error("\nTest execution failed:", error);
124:       process.exit(1);
125:     });
126: }
127: 
128: export {testScheduledFunctions};
</file>

<file path="src/test/testSync.ts">
 1: // src/test/testSync.ts
 2: 
 3: // Force test mode and updates
 4: process.env.NODE_ENV = "test";
 5: process.env.FORCE_UPDATE = "true";
 6: 
 7: import {syncCards} from "../services/cardSync";
 8: 
 9: async function testSync() {
10:   console.log("\n=== Testing Card Sync ===");
11: 
12:   const testGroups = [
13:     {id: "23783", name: "Hidden Legends"},
14:     {id: "1939", name: "Opus I"},
15:     {id: "23568", name: "Hidden Trials"},
16:   ];
17: 
18:   for (const group of testGroups) {
19:     console.log(`\nTesting sync for ${group.name} (${group.id})`);
20: 
21:     try {
22:       const options = {
23:         groupId: group.id,
24:         limit: 5,
25:         dryRun: false, // Changed to false to actually process updates
26:         showAll: true,
27:         force: true,
28:         skipImages: false,
29:       };
30: 
31:       const result = await syncCards(options);
32: 
33:       console.log("\nSync Results:");
34:       console.log(`Status: ${result.status}`);
35:       console.log(`Cards Processed: ${result.cardCount}`);
36:       console.log(`Groups Updated: ${result.groupsUpdated}`);
37:       console.log(`Images Processed: ${result.imagesProcessed}`);
38:       console.log(`Images Updated: ${result.imagesUpdated}`);
39: 
40:       if (result.errors.length > 0) {
41:         console.log("\nErrors:");
42:         result.errors.forEach((error) => console.log(`- ${error}`));
43:       }
44:     } catch (error) {
45:       console.error(`Error syncing ${group.name}:`, error);
46:     }
47:   }
48: }
49: 
50: // Execute the test
51: console.log("Starting Card Sync tests...");
52: testSync()
53:   .then(() => console.log("\nAll Card Sync tests completed!"))
54:   .catch(console.error);
</file>

<file path="src/test/validateSync.ts">
 1: // src/test/validateSync.ts
 2: 
 3: import {db, COLLECTION} from "../config/firebase";
 4: import {r2Storage} from "../services/r2Storage";
 5: import {syncCards} from "../services/cardSync";
 6: import {syncPrices} from "../services/priceSync";
 7: 
 8: async function validateSync(options = {limit: 5, groupId: ""}) {
 9:   try {
10:     console.log("\nStarting validation sync...");
11: 
12:     // Test card sync
13:     console.log("\nTesting card sync...");
14:     const cardResult = await syncCards({
15:       dryRun: false,
16:       limit: options.limit,
17:       groupId: options.groupId,
18:       skipImages: false,
19:     });
20: 
21:     // Validate card data and images
22:     const cardDocs = await db
23:       .collection(COLLECTION.CARDS)
24:       .limit(options.limit)
25:       .get();
26: 
27:     for (const doc of cardDocs.docs) {
28:       const data = doc.data();
29:       console.log(`\nValidating card: ${data.name}`);
30:       console.log(`Document ID: ${doc.id}`);
31: 
32:       // Validate image URLs
33:       if (data.highResUrl && data.lowResUrl) {
34:         console.log("Checking image URLs...");
35: 
36:         // Check R2 storage
37:         const highResExists = await r2Storage.fileExists(
38:           data.highResUrl.replace(process.env.R2_CUSTOM_DOMAIN as string, "")
39:         );
40:         const lowResExists = await r2Storage.fileExists(
41:           data.lowResUrl.replace(process.env.R2_CUSTOM_DOMAIN as string, "")
42:         );
43: 
44:         console.log(`High-res image exists: ${highResExists}`);
45:         console.log(`Low-res image exists: ${lowResExists}`);
46:       } else {
47:         console.log("Warning: Missing image URLs");
48:       }
49:     }
50: 
51:     // Test price sync
52:     console.log("\nTesting price sync...");
53:     const priceResult = await syncPrices({
54:       dryRun: false,
55:       limit: options.limit,
56:       groupId: options.groupId,
57:     });
58: 
59:     console.log("\nSync Results:");
60:     console.log("Cards processed:", cardResult.cardCount);
61:     console.log("Images processed:", cardResult.imagesProcessed);
62:     console.log("Images updated:", cardResult.imagesUpdated);
63:     console.log("Prices processed:", priceResult.cardCount);
64: 
65:     if (cardResult.errors.length > 0) {
66:       console.log("\nCard Sync Errors:", cardResult.errors);
67:     }
68:     if (priceResult.errors.length > 0) {
69:       console.log("\nPrice Sync Errors:", priceResult.errors);
70:     }
71:   } catch (error) {
72:     console.error("Validation failed:", error);
73:     throw error;
74:   }
75: }
76: 
77: // Run validation if executed directly
78: if (require.main === module) {
79:   const args = process.argv.slice(2);
80:   const options = {
81:     limit: args.includes("--limit") ?
82:       parseInt(args[args.indexOf("--limit") + 1]) :
83:       5,
84:     groupId: args.includes("--group-id") ?
85:       args[args.indexOf("--group-id") + 1] :
86:       "",
87:   };
88: 
89:   validateSync(options)
90:     .then(() => process.exit(0))
91:     .catch((error) => {
92:       console.error("Fatal error:", error);
93:       process.exit(1);
94:     });
95: }
</file>

<file path="src/test/verifyMigration.ts">
  1: // src/test/verifyMigration.ts
  2: 
  3: import {db, COLLECTION} from "../config/firebase";
  4: import {r2Storage} from "../services/r2Storage";
  5: import {logInfo} from "../utils/logger";
  6: import type {
  7:   Query,
  8:   DocumentData,
  9:   CollectionReference,
 10: } from "@google-cloud/firestore";
 11: 
 12: interface VerificationStats {
 13:   total: number;
 14:   withHighRes: number;
 15:   withLowRes: number;
 16:   withOldImageUrl: number;
 17:   withValidR2Urls: number;
 18:   errors: string[];
 19: }
 20: 
 21: interface ExtendedData {
 22:   name: string;
 23:   value: string;
 24: }
 25: 
 26: async function verifyMigration(groupId?: string, limit?: number) {
 27:   const stats: VerificationStats = {
 28:     total: 0,
 29:     withHighRes: 0,
 30:     withLowRes: 0,
 31:     withOldImageUrl: 0,
 32:     withValidR2Urls: 0,
 33:     errors: [],
 34:   };
 35: 
 36:   try {
 37:     console.log("\nStarting migration verification...");
 38: 
 39:     const cardsCollection = db.collection(
 40:       COLLECTION.CARDS
 41:     ) as CollectionReference<DocumentData>;
 42:     let query: Query<DocumentData> = cardsCollection;
 43: 
 44:     if (groupId) {
 45:       query = query.where("groupId", "==", groupId);
 46:     }
 47:     if (limit) {
 48:       query = query.limit(limit);
 49:     }
 50: 
 51:     const snapshot = await query.get();
 52:     stats.total = snapshot.size;
 53: 
 54:     console.log(`Found ${stats.total} cards to verify`);
 55: 
 56:     for (const doc of snapshot.docs) {
 57:       const data = doc.data();
 58:       const extendedData = data.extendedData as ExtendedData[];
 59:       const cardNumber = extendedData?.find(
 60:         (field) => field.name === "Number"
 61:       )?.value;
 62:       const cardName = data.name || "Unknown Card";
 63:       const cardId = cardNumber ?
 64:         `${data.productId}_${cardNumber}` :
 65:         `${data.productId}`;
 66: 
 67:       console.log(`\nVerifying card: ${cardName} (${cardId})`);
 68:       console.log(`Group ID: ${data.groupId}`);
 69:       console.log(`Card Number: ${cardNumber || "Not found"}`);
 70: 
 71:       // Check URLs
 72:       if (data.highResUrl) {
 73:         stats.withHighRes++;
 74:         console.log(`High-res URL: ${data.highResUrl}`);
 75:       }
 76:       if (data.lowResUrl) {
 77:         stats.withLowRes++;
 78:         console.log(`Low-res URL: ${data.lowResUrl}`);
 79:       }
 80:       if (data.imageUrl) {
 81:         stats.withOldImageUrl++;
 82:         console.log(`Old image URL found: ${data.imageUrl}`);
 83:       }
 84: 
 85:       if (!cardNumber) {
 86:         stats.errors.push(
 87:           `Missing card number for ${cardName} (${data.productId})`
 88:         );
 89:         continue;
 90:       }
 91: 
 92:       // Verify R2 files exist
 93:       if (data.highResUrl && data.lowResUrl) {
 94:         try {
 95:           const sanitizedCardNumber = cardNumber.replace(/\//g, "_");
 96:           const highResPath = `${data.groupId}/${data.productId}_${sanitizedCardNumber}_400w.jpg`;
 97:           const lowResPath = `${data.groupId}/${data.productId}_${sanitizedCardNumber}_200w.jpg`;
 98: 
 99:           console.log("Checking R2 paths:");
100:           console.log(`High-res: ${highResPath}`);
101:           console.log(`Low-res: ${lowResPath}`);
102: 
103:           const [highResExists, lowResExists] = await Promise.all([
104:             r2Storage.fileExists(highResPath),
105:             r2Storage.fileExists(lowResPath),
106:           ]);
107: 
108:           if (highResExists && lowResExists) {
109:             stats.withValidR2Urls++;
110:             console.log("✅ R2 files verified successfully");
111:           } else {
112:             stats.errors.push(
113:               `Missing R2 files for ${cardName} (${cardId}): ` +
114:                 `High-res: ${highResExists}, Low-res: ${lowResExists}`
115:             );
116:             console.log("❌ R2 files verification failed");
117:           }
118: 
119:           // Verify URLs are accessible
120:           const [highResResponse, lowResResponse] = await Promise.all([
121:             fetch(data.highResUrl, {method: "HEAD"}),
122:             fetch(data.lowResUrl, {method: "HEAD"}),
123:           ]);
124: 
125:           console.log("URL Accessibility:");
126:           console.log(
127:             `High-res (${highResResponse.status}): ${
128:               highResResponse.ok ? "✅" : "❌"
129:             }`
130:           );
131:           console.log(
132:             `Low-res (${lowResResponse.status}): ${
133:               lowResResponse.ok ? "✅" : "❌"
134:             }`
135:           );
136: 
137:           if (!highResResponse.ok || !lowResResponse.ok) {
138:             stats.errors.push(
139:               `Invalid URLs for ${cardName} (${cardId}): ` +
140:                 `High-res: ${highResResponse.status}, ` +
141:                 `Low-res: ${lowResResponse.status}`
142:             );
143:           }
144:         } catch (error) {
145:           const errorMessage =
146:             error instanceof Error ? error.message : "Unknown error";
147:           stats.errors.push(
148:             `Error verifying ${cardName} (${cardId}): ${errorMessage}`
149:           );
150:           console.log(`❌ Verification error: ${errorMessage}`);
151:         }
152:       } else {
153:         console.log("⚠️ Missing image URLs");
154:         if (!data.highResUrl) {
155:           stats.errors.push(`Missing high-res URL for ${cardName} (${cardId})`);
156:         }
157:         if (!data.lowResUrl) {
158:           stats.errors.push(`Missing low-res URL for ${cardName} (${cardId})`);
159:         }
160:       }
161:     }
162: 
163:     // Print summary
164:     console.log("\n=== Verification Summary ===");
165:     console.log(`Total cards checked: ${stats.total}`);
166:     console.log(`Cards with high-res URLs: ${stats.withHighRes}`);
167:     console.log(`Cards with low-res URLs: ${stats.withLowRes}`);
168:     console.log(`Cards with old image URLs: ${stats.withOldImageUrl}`);
169:     console.log(`Cards with verified R2 URLs: ${stats.withValidR2Urls}`);
170: 
171:     if (stats.errors.length > 0) {
172:       console.log("\nErrors found:");
173:       stats.errors.forEach((error) => console.log(`- ${error}`));
174:     }
175: 
176:     await logInfo("Migration verification completed", {stats});
177:   } catch (error) {
178:     console.error("Verification failed:", error);
179:     throw error;
180:   }
181: }
182: 
183: // Execute if run directly
184: if (require.main === module) {
185:   const args = process.argv.slice(2);
186:   const options = {
187:     groupId: args.includes("--group-id") ?
188:       args[args.indexOf("--group-id") + 1] :
189:       undefined,
190:     limit: args.includes("--limit") ?
191:       parseInt(args[args.indexOf("--limit") + 1]) :
192:       undefined,
193:   };
194: 
195:   verifyMigration(options.groupId, options.limit)
196:     .then(() => {
197:       console.log("\nVerification completed!");
198:       process.exit(0);
199:     })
200:     .catch((error) => {
201:       console.error("Verification failed:", error);
202:       process.exit(1);
203:     });
204: }
</file>

<file path="src/types/index.ts">
  1: // src/types/index.ts
  2: 
  3: import type * as express from "express";
  4: 
  5: export {express};
  6: 
  7: export interface GenericError extends Error {
  8:   code?: string;
  9:   message: string;
 10:   stack?: string;
 11: }
 12: 
 13: export interface MigrationResult {
 14:   success: boolean;
 15:   error?: string;
 16:   stats: {
 17:     processed: number;
 18:     skipped: number;
 19:     errors: string[];
 20:   };
 21: }
 22: 
 23: export interface CardProduct {
 24:   productId: number;
 25:   name: string;
 26:   cleanName: string;
 27:   imageUrl?: string; // TCGPlayer URL (from API)
 28:   highResUrl: string; // R2 Storage URL (_400w)
 29:   lowResUrl: string; // R2 Storage URL (_200w)
 30:   categoryId: number;
 31:   groupId: number;
 32:   url: string;
 33:   modifiedOn: string;
 34:   imageCount: number;
 35:   imageMetadata?: ImageMetadata;
 36:   isPlaceholder?: boolean;
 37:   extendedData: Array<{
 38:     name: string;
 39:     displayName: string;
 40:     value: string;
 41:   }>;
 42: }
 43: 
 44: export interface CardPrice {
 45:   productId: number;
 46:   lowPrice: number;
 47:   midPrice: number;
 48:   highPrice: number;
 49:   marketPrice: number | null;
 50:   directLowPrice: number | null;
 51:   subTypeName: "Normal" | "Foil";
 52:   cardNumber?: string;
 53: }
 54: 
 55: export interface SyncOptions {
 56:   dryRun?: boolean;
 57:   limit?: number;
 58:   groupId?: string;
 59:   productId?: number;
 60:   showAll?: boolean;
 61:   skipImages?: boolean;
 62:   imagesOnly?: boolean;
 63:   silent?: boolean;
 64:   force?: boolean;
 65:   maxRetries?: number;
 66:   retryDelay?: number;
 67: }
 68: 
 69: export interface SyncMetadata {
 70:   lastSync: Date;
 71:   status: "in_progress" | "success" | "failed" | "completed_with_errors";
 72:   cardCount: number;
 73:   type: "manual" | "scheduled";
 74:   groupsProcessed: number;
 75:   groupsUpdated: number;
 76:   errors: string[];
 77:   duration?: number;
 78:   imagesProcessed?: number;
 79:   imagesUpdated?: number;
 80:   placeholderImages?: number;
 81:   retryAttempts?: number;
 82: }
 83: 
 84: export type CacheType = "card" | "price" | "image";
 85: 
 86: export interface PriceData {
 87:   normal?: CardPrice;
 88:   foil?: CardPrice;
 89:   lastUpdated: Date;
 90:   productId: number;
 91:   cardNumber?: string; // Made optional
 92:   retryCount?: number;
 93: }
 94: 
 95: export interface ImageMetadata {
 96:   contentType: string;
 97:   size: number;
 98:   updated: Date;
 99:   hash: string;
100:   groupId?: string;
101:   productId?: number;
102:   cardNumber?: string;
103:   lastUpdated?: Date;
104:   originalSize?: number;
105:   highResSize?: number;
106:   lowResSize?: number;
107:   isPlaceholder?: boolean;
108: }
109: 
110: export interface PlaceholderImageRecord {
111:   productId: number;
112:   groupId: string;
113:   name: string;
114:   timestamp: Date;
115:   originalUrl?: string;
116: }
117: 
118: export interface ImageProcessingResult {
119:   highResUrl: string;
120:   lowResUrl: string;
121:   metadata: ImageMetadata;
122:   updated: boolean;
123:   isPlaceholder?: boolean;
124: }
125: 
126: export interface ImageSyncStats {
127:   processed: number;
128:   updated: number;
129:   failed: number;
130:   skipped: number;
131:   placeholders: number;
132: }
133: 
134: export interface LogData {
135:   imageMetadata?: ImageMetadata;
136:   imageSyncStats?: ImageSyncStats;
137:   [key: string]: any;
138: }
139: 
140: export interface CacheOptions {
141:   max: number;
142:   ttl: number;
143: }
144: 
145: export interface CacheEntry<T> {
146:   data: T;
147:   timestamp: number;
148:   expires: number;
149: }
150: 
151: export interface ImageProcessingError extends GenericError {
152:   productId: number;
153:   groupId: string;
154:   originalUrl: string;
155:   type: "download" | "upload" | "metadata" | "unknown";
156: }
157: 
158: export type GenericObject = Record<string, any>;
159: 
160: export interface BatchProcessingStats {
161:   total: number;
162:   processed: number;
163:   successful: number;
164:   failed: number;
165:   skipped: number;
166:   placeholders: number;
167: }
168: 
169: export interface BatchOptions {
170:   batchSize?: number;
171:   delayBetweenBatches?: number;
172:   onBatchComplete?: (stats: BatchProcessingStats) => Promise<void>;
173:   skipImages?: boolean;
174:   retryFailedImages?: boolean;
175:   maxRetries?: number;
176:   retryDelay?: number;
177: }
178: 
179: export interface BatchProgress {
180:   totalBatches: number;
181:   currentBatch: number;
182:   processedCount: number;
183:   totalItems: number;
184: }
185: 
186: export interface ImageLogEntry {
187:   timestamp: Date;
188:   level: "INFO" | "WARNING" | "ERROR";
189:   message: string;
190:   context?: string;
191:   metadata?: ImageMetadata;
192:   error?: ImageProcessingError;
193:   stats?: ImageSyncStats;
194: }
195: 
196: export interface StoragePaths {
197:   original: string;
198:   processed: string;
199: }
200: 
201: export interface StorageOptions {
202:   contentType: string;
203:   metadata?: Record<string, string>;
204:   cacheControl?: string;
205: }
206: 
207: export interface ImageProcessingProgress {
208:   total: number;
209:   current: number;
210:   updated: number;
211:   failed: number;
212:   startTime: number;
213:   estimatedTimeRemaining?: number;
214: }
215: 
216: export interface ImageValidationError {
217:   code: "FILE_TOO_LARGE" | "INVALID_FORMAT" | "VALIDATION_ERROR";
218:   message: string;
219: }
220: 
221: export interface SyncMode {
222:   type: "data" | "images" | "full";
223:   isForced: boolean;
224:   isDryRun: boolean;
225: }
226: 
227: export interface RefreshOptions {
228:   isDryRun: boolean;
229:   isVerbose: boolean;
230:   isForce: boolean;
231:   groupId?: string;
232:   skipImages: boolean;
233:   imagesOnly: boolean;
234: }
235: 
236: export interface RetryOptions {
237:   maxRetries: number;
238:   baseDelay: number;
239:   maxDelay: number;
240:   shouldRetry?: (error: Error) => boolean;
241: }
242: 
243: export interface HistoricalPrice {
244:   productId: number;
245:   date: Date;
246:   prices: {
247:     normal?: {
248:       low: number;
249:       mid: number;
250:       high: number;
251:       market: number | null;
252:       directLow: number | null;
253:     };
254:     foil?: {
255:       low: number;
256:       mid: number;
257:       high: number;
258:       market: number | null;
259:       directLow: number | null;
260:     };
261:   };
262:   groupId: string;
263:   cardNumber?: string;
264: }
265: 
266: export interface PriceArchive {
267:   date: string;
268:   url: string;
269:   processed: boolean;
270:   processedAt?: Date;
271:   error?: string;
272: }
</file>

<file path="src/utils/backup.ts">
  1: // src/utils/backup.ts
  2: 
  3: import {db, COLLECTION} from "../config/firebase";
  4: import * as fs from "fs";
  5: import * as path from "path";
  6: 
  7: interface BackupMetadata {
  8:   timestamp: string;
  9:   collections: string[];
 10:   documentCounts: { [key: string]: number };
 11: }
 12: 
 13: export async function backup(): Promise<void> {
 14:   const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
 15:   const backupDir = path.join(__dirname, "..", "..", "backups");
 16:   const backupPath = path.join(backupDir, `backup_${timestamp}`);
 17: 
 18:   // Create backup directory if it doesn't exist
 19:   if (!fs.existsSync(backupDir)) {
 20:     fs.mkdirSync(backupDir, {recursive: true});
 21:   }
 22: 
 23:   const collections = [
 24:     COLLECTION.CARDS,
 25:     COLLECTION.PRICES,
 26:     COLLECTION.SYNC_METADATA,
 27:     COLLECTION.CARD_HASHES,
 28:     COLLECTION.PRICE_HASHES,
 29:     COLLECTION.IMAGE_METADATA,
 30:   ];
 31: 
 32:   const metadata: BackupMetadata = {
 33:     timestamp,
 34:     collections,
 35:     documentCounts: {},
 36:   };
 37: 
 38:   try {
 39:     console.log("Starting database backup...");
 40: 
 41:     for (const collectionName of collections) {
 42:       console.log(`Backing up collection: ${collectionName}`);
 43: 
 44:       const snapshot = await db.collection(collectionName).get();
 45:       const documents = snapshot.docs.map((doc) => ({
 46:         id: doc.id,
 47:         data: doc.data(),
 48:       }));
 49: 
 50:       metadata.documentCounts[collectionName] = documents.length;
 51: 
 52:       // Save collection to its own file
 53:       const collectionPath = `${backupPath}_${collectionName}.json`;
 54:       fs.writeFileSync(collectionPath, JSON.stringify(documents, null, 2));
 55: 
 56:       console.log(`- Backed up ${documents.length} documents`);
 57:     }
 58: 
 59:     // Save metadata
 60:     const metadataPath = `${backupPath}_metadata.json`;
 61:     fs.writeFileSync(metadataPath, JSON.stringify(metadata, null, 2));
 62: 
 63:     console.log("\nBackup completed successfully");
 64:     console.log(`Location: ${backupDir}`);
 65:     console.log("Files:");
 66:     collections.forEach((collection) => {
 67:       console.log(`- backup_${timestamp}_${collection}.json`);
 68:     });
 69:     console.log(`- backup_${timestamp}_metadata.json`);
 70:   } catch (error) {
 71:     console.error("Backup failed:", error);
 72:     throw error;
 73:   }
 74: }
 75: 
 76: export async function restore(timestamp: string): Promise<void> {
 77:   const backupDir = path.join(__dirname, "..", "..", "backups");
 78:   const metadataPath = path.join(
 79:     backupDir,
 80:     `backup_${timestamp}_metadata.json`
 81:   );
 82: 
 83:   if (!fs.existsSync(metadataPath)) {
 84:     throw new Error(`Backup metadata not found: ${metadataPath}`);
 85:   }
 86: 
 87:   const metadata: BackupMetadata = JSON.parse(
 88:     fs.readFileSync(metadataPath, "utf8")
 89:   );
 90: 
 91:   try {
 92:     console.log("Starting database restore...");
 93: 
 94:     for (const collectionName of metadata.collections) {
 95:       console.log(`Restoring collection: ${collectionName}`);
 96: 
 97:       const collectionPath = path.join(
 98:         backupDir,
 99:         `backup_${timestamp}_${collectionName}.json`
100:       );
101:       const documents = JSON.parse(fs.readFileSync(collectionPath, "utf8"));
102: 
103:       const batch = db.batch();
104:       let batchCount = 0;
105:       let totalRestored = 0;
106: 
107:       for (const doc of documents) {
108:         const ref = db.collection(collectionName).doc(doc.id);
109:         batch.set(ref, doc.data);
110:         batchCount++;
111: 
112:         if (batchCount >= 500) {
113:           // Firestore batch limit
114:           await batch.commit();
115:           totalRestored += batchCount;
116:           batchCount = 0;
117:         }
118:       }
119: 
120:       if (batchCount > 0) {
121:         await batch.commit();
122:         totalRestored += batchCount;
123:       }
124: 
125:       console.log(`- Restored ${totalRestored} documents`);
126:     }
127: 
128:     console.log("\nRestore completed successfully");
129:   } catch (error) {
130:     console.error("Restore failed:", error);
131:     throw error;
132:   }
133: }
134: 
135: // If run directly, perform backup
136: if (require.main === module) {
137:   backup()
138:     .then(() => process.exit(0))
139:     .catch((error) => {
140:       console.error("Fatal error:", error);
141:       process.exit(1);
142:     });
143: }
</file>

<file path="src/utils/cache.ts">
 1: import LRUCache from "lru-cache";
 2: import {CacheType, CardProduct} from "../types";
 3: 
 4: const options = {
 5:   max: 500,
 6:   ttl: 1000 * 60 * 60, // 1 hour
 7: };
 8: 
 9: export const cardCache = new LRUCache<string, CardProduct>(options);
10: 
11: export const getCacheKey = (
12:   type: CacheType,
13:   id: number,
14:   cardNumber?: string
15: ): string => {
16:   return cardNumber ? `${type}:${id}:${cardNumber}` : `${type}:${id}`;
17: };
</file>

<file path="src/utils/databaseBackup.ts">
 1: import {db, COLLECTION} from "../config/firebase";
 2: import * as fs from "fs/promises";
 3: import * as path from "path";
 4: 
 5: async function backupCollection(collectionName: string): Promise<void> {
 6:   console.log(`Backing up ${collectionName}...`);
 7:   const snapshot = await db.collection(collectionName).get();
 8:   const data = snapshot.docs.map((doc) => ({
 9:     id: doc.id,
10:     data: doc.data(),
11:   }));
12: 
13:   const backupDir = path.join(__dirname, "../../backups");
14:   await fs.mkdir(backupDir, {recursive: true});
15: 
16:   const timestamp = new Date().toISOString().replace(/[:]/g, "-");
17:   const filename = `${collectionName}_${timestamp}.json`;
18:   await fs.writeFile(
19:     path.join(backupDir, filename),
20:     JSON.stringify(data, null, 2)
21:   );
22: 
23:   console.log(`Backed up ${data.length} documents from ${collectionName}`);
24: }
25: 
26: export async function backupDatabase(): Promise<void> {
27:   try {
28:     console.log("Starting database backup...");
29: 
30:     await Promise.all([
31:       backupCollection(COLLECTION.CARDS),
32:       backupCollection(COLLECTION.PRICES),
33:       backupCollection(COLLECTION.SYNC_METADATA),
34:       backupCollection(COLLECTION.CARD_HASHES),
35:       backupCollection(COLLECTION.PRICE_HASHES),
36:       backupCollection(COLLECTION.IMAGE_METADATA),
37:     ]);
38: 
39:     console.log("Backup completed successfully!");
40:   } catch (error) {
41:     console.error("Backup failed:", error);
42:     throw error;
43:   }
44: }
</file>

<file path="src/utils/databaseCleanup.ts">
 1: import {db, COLLECTION} from "../config/firebase";
 2: import {logInfo} from "./logger";
 3: import {FieldValue} from "firebase-admin/firestore";
 4: 
 5: export async function cleanupImageUrls(): Promise<void> {
 6:   let count = 0;
 7:   let batchCount = 0;
 8:   let batch = db.batch(); // Initialize first batch
 9: 
10:   const snapshot = await db.collection(COLLECTION.CARDS).get();
11: 
12:   for (const doc of snapshot.docs) {
13:     const data = doc.data();
14: 
15:     if (data.imageUrl) {
16:       const updates: any = {
17:         originalUrl: data.imageUrl,
18:         lastUpdated: new Date(),
19:       };
20: 
21:       // Remove imageUrl field
22:       updates.imageUrl = FieldValue.delete();
23: 
24:       batch.update(doc.ref, updates);
25:       count++;
26:       batchCount++;
27: 
28:       if (batchCount >= 500) {
29:         // Firestore batch limit
30:         await batch.commit();
31:         await logInfo(`Processed ${count} documents`);
32:         // Create a new batch after commit
33:         batch = db.batch();
34:         batchCount = 0;
35:       }
36:     }
37:   }
38: 
39:   // Commit any remaining updates
40:   if (batchCount > 0) {
41:     await batch.commit();
42:     await logInfo(`Processed final batch of ${batchCount} documents`);
43:   }
44: 
45:   await logInfo(`Cleanup completed. Updated ${count} documents`);
46: }
47: 
48: // Execute if run directly
49: if (require.main === module) {
50:   cleanupImageUrls()
51:     .then(() => {
52:       console.log("Cleanup completed successfully!");
53:       process.exit(0);
54:     })
55:     .catch((error) => {
56:       console.error("Cleanup failed:", error);
57:       process.exit(1);
58:     });
59: }
</file>

<file path="src/utils/databaseMigration.ts">
 1: import {db, COLLECTION} from "../config/firebase";
 2: import {processBatch} from "./syncUtils";
 3: import {FieldValue} from "firebase-admin/firestore";
 4: import type {QueryDocumentSnapshot} from "@google-cloud/firestore";
 5: 
 6: interface BatchStats {
 7:   processed: number;
 8:   total: number;
 9: }
10: 
11: /**
12:  * Migrates image URLs by processing documents in batches.
13:  * Removes the `imageUrl` field from documents and updates high-res and low-res URLs.
14:  */
15: export async function migrateImageUrls(
16:   _options: { dryRun?: boolean; limit?: number; groupId?: string } = {}
17: ): Promise<void> {
18:   // Query the cards collection
19:   const query = db.collection(COLLECTION.CARDS);
20:   const snapshot = await query.get();
21: 
22:   console.log(`Found ${snapshot.size} documents to process.`);
23: 
24:   // Process documents in batches
25:   await processBatch<QueryDocumentSnapshot>(
26:     snapshot.docs,
27:     async (batch: QueryDocumentSnapshot[]) => {
28:       const writeBatch = db.batch();
29: 
30:       for (const doc of batch) {
31:         const data = doc.data();
32:         const updates: any = {lastUpdated: new Date()};
33: 
34:         // Remove the `imageUrl` field if it exists
35:         if (data.imageUrl) {
36:           updates.imageUrl = FieldValue.delete();
37:         }
38: 
39:         // Update the document in Firestore
40:         writeBatch.update(doc.ref, updates);
41:         console.log(`Prepared updates for document: ${doc.id}`);
42:       }
43: 
44:       // Commit the batch
45:       if (batch.length > 0) {
46:         await writeBatch.commit();
47:         console.log(`Committed batch of ${batch.length} documents.`);
48:       }
49:     },
50:     {
51:       batchSize: 500, // Firestore supports up to 500 operations per batch
52:       onBatchComplete: async (batchStats: BatchStats) => {
53:         console.log(
54:           `Processed ${batchStats.processed} out of ${batchStats.total} documents.`
55:         );
56:       },
57:     }
58:   );
59: 
60:   console.log("Migration completed successfully.");
61: }
62: 
63: // If run directly, execute the migration
64: if (require.main === module) {
65:   const args = process.argv.slice(2);
66: 
67:   const options: {
68:     dryRun?: boolean;
69:     limit?: number;
70:     groupId?: string;
71:   } = {
72:     dryRun: args.includes("--dry-run"),
73:     limit: args.includes("--limit") ?
74:       parseInt(args[args.indexOf("--limit") + 1]) :
75:       undefined,
76:     groupId: args.includes("--group-id") ?
77:       args[args.indexOf("--group-id") + 1] :
78:       undefined,
79:   };
80: 
81:   migrateImageUrls(options)
82:     .then(() => {
83:       console.log("Image URL migration completed!");
84:       process.exit(0);
85:     })
86:     .catch((error) => {
87:       console.error("Migration failed:", error);
88:       process.exit(1);
89:     });
90: }
</file>

<file path="src/utils/databaseRefresh.ts">
  1: // src/utils/databaseRefresh.ts
  2: 
  3: import {syncCards} from "../services/cardSync";
  4: import {syncPrices} from "../services/priceSync";
  5: import {backup} from "../utils/backup";
  6: import {logError} from "./logger";
  7: import {GenericError, SyncMode} from "../types";
  8: import {db, COLLECTION} from "../config/firebase";
  9: 
 10: interface RefreshSetSummary {
 11:   name: string;
 12:   cards: {
 13:     total: number;
 14:     toUpdate: number;
 15:     unchanged: number;
 16:   };
 17:   prices: {
 18:     total: number;
 19:     toUpdate: number;
 20:     unchanged: number;
 21:   };
 22:   images: {
 23:     total: number;
 24:     toUpdate: number;
 25:     unchanged: number;
 26:   };
 27: }
 28: 
 29: interface RefreshSummary {
 30:   sets: RefreshSetSummary[];
 31:   mode: SyncMode;
 32:   duration?: number;
 33: }
 34: 
 35: interface RefreshOptions {
 36:   isDryRun: boolean;
 37:   isVerbose: boolean;
 38:   isForce: boolean;
 39:   groupId?: string;
 40:   skipImages: boolean;
 41:   imagesOnly: boolean;
 42:   limit?: number; // Add this line
 43: }
 44: 
 45: async function parseCommandLineArgs(): Promise<RefreshOptions> {
 46:   const args = process.argv.slice(2);
 47:   console.log("Raw command line arguments:", args);
 48: 
 49:   const options: RefreshOptions = {
 50:     isDryRun: false,
 51:     isVerbose: false,
 52:     isForce: false,
 53:     skipImages: false,
 54:     imagesOnly: false,
 55:     limit: undefined,
 56:     groupId: undefined,
 57:   };
 58: 
 59:   for (let i = 0; i < args.length; i++) {
 60:     const arg = args[i];
 61:     const nextArg = args[i + 1];
 62: 
 63:     switch (arg) {
 64:     case "--dry-run":
 65:       options.isDryRun = true;
 66:       break;
 67:     case "--verbose":
 68:       options.isVerbose = true;
 69:       break;
 70:     case "--force":
 71:       options.isForce = true;
 72:       break;
 73:     case "--skip-images":
 74:       options.skipImages = true;
 75:       break;
 76:     case "--images-only":
 77:       options.imagesOnly = true;
 78:       break;
 79:     case "--group-id":
 80:       if (nextArg && !nextArg.startsWith("--")) {
 81:         options.groupId = nextArg;
 82:         i++; // Skip next argument since we used it
 83:       }
 84:       break;
 85:     case "--limit":
 86:       if (nextArg && !nextArg.startsWith("--")) {
 87:         options.limit = parseInt(nextArg, 10);
 88:         i++; // Skip next argument since we used it
 89:       }
 90:       break;
 91:     }
 92:   }
 93: 
 94:   return options;
 95: }
 96: 
 97: async function resetDatabase(): Promise<void> {
 98:   await backup();
 99: }
100: 
101: async function clearHashes(): Promise<void> {
102:   console.log("Clearing existing hashes...");
103:   const batch = db.batch();
104: 
105:   const cardHashes = await db.collection(COLLECTION.CARD_HASHES).get();
106:   cardHashes.docs.forEach((doc) => {
107:     batch.delete(doc.ref);
108:   });
109: 
110:   const priceHashes = await db.collection(COLLECTION.PRICE_HASHES).get();
111:   priceHashes.docs.forEach((doc) => {
112:     batch.delete(doc.ref);
113:   });
114: 
115:   await batch.commit();
116:   console.log("Hashes cleared");
117: }
118: 
119: function validateOptions(options: RefreshOptions): void {
120:   if (options.skipImages && options.imagesOnly) {
121:     throw new Error("Cannot use both --skip-images and --images-only flags");
122:   }
123: }
124: 
125: function getSyncMode(options: RefreshOptions): SyncMode {
126:   return {
127:     type: options.imagesOnly ? "images" : options.skipImages ? "data" : "full",
128:     isForced: options.isForce,
129:     isDryRun: options.isDryRun,
130:   };
131: }
132: 
133: async function displayInitialSummary(
134:   options: RefreshOptions,
135:   mode: SyncMode
136: ): Promise<void> {
137:   console.log(`\nFFTCG Database ${options.isDryRun ? "Analysis" : "Refresh"}`);
138:   console.log("==========================");
139:   console.log(`Mode: ${mode.type.toUpperCase()}`);
140:   if (options.groupId) console.log(`Processing group: ${options.groupId}`);
141:   if (options.limit) console.log(`Limit: ${options.limit} items`); // Add this line
142:   console.log("Force mode:", options.isForce ? "enabled" : "disabled");
143:   console.log("Verbose mode:", options.isVerbose ? "enabled" : "disabled");
144:   console.log("Dry run:", options.isDryRun ? "yes" : "no");
145:   console.log("\nStarting process...");
146: }
147: 
148: export async function refreshDatabase(): Promise<void> {
149:   const startTime = Date.now();
150:   const options = await parseCommandLineArgs();
151: 
152:   try {
153:     validateOptions(options);
154:     const mode = getSyncMode(options);
155: 
156:     // Add detailed options logging
157:     console.log("\nParsed Options:");
158:     console.log("==============");
159:     console.log({
160:       isDryRun: options.isDryRun,
161:       isVerbose: options.isVerbose,
162:       isForce: options.isForce,
163:       groupId: options.groupId,
164:       skipImages: options.skipImages,
165:       imagesOnly: options.imagesOnly,
166:       limit: options.limit,
167:     });
168:     console.log(); // Add blank line for readability
169: 
170:     await displayInitialSummary(options, mode);
171: 
172:     const summary: RefreshSummary = {
173:       sets: [],
174:       mode,
175:     };
176: 
177:     // Analysis Phase
178:     console.log("\nAnalyzing current state...");
179:     console.log("Applied query parameters:");
180:     console.log("- Group ID:", options.groupId || "all groups");
181:     console.log("- Limit:", options.limit || "no limit");
182:     console.log("- Images Only:", options.imagesOnly);
183:     console.log(); // Add blank line for readability
184: 
185:     if (options.isForce && !options.isDryRun) {
186:       await clearHashes();
187:     }
188: 
189:     // Card/Image Sync Analysis
190:     const cardResult = await syncCards({
191:       dryRun: true,
192:       skipImages: options.skipImages,
193:       imagesOnly: options.imagesOnly,
194:       silent: !options.isVerbose,
195:       force: options.isForce,
196:       groupId: options.groupId,
197:       limit: options.limit,
198:     });
199: 
200:     // Log the results of the card sync
201:     console.log("\nCard Sync Configuration:");
202:     console.log("======================");
203:     console.log({
204:       dryRun: true,
205:       skipImages: options.skipImages,
206:       imagesOnly: options.imagesOnly,
207:       silent: !options.isVerbose,
208:       force: options.isForce,
209:       groupId: options.groupId,
210:       limit: options.limit,
211:       cardsFound: cardResult.cardCount,
212:     });
213:     console.log(); // Add blank line for readability
214: 
215:     // Price Sync Analysis (skip if images-only)
216:     const priceResult = !options.imagesOnly ?
217:       await syncPrices({
218:         dryRun: true,
219:         silent: !options.isVerbose,
220:         force: options.isForce,
221:         groupId: options.groupId,
222:       }) :
223:       {
224:         cardCount: 0,
225:         groupsUpdated: 0,
226:         errors: [],
227:       };
228: 
229:     // Display Analysis Results
230:     console.log("\nAnalysis Results:");
231:     console.log("----------------");
232: 
233:     if (options.imagesOnly) {
234:       console.log("\nImage Processing:");
235:       console.log(`Images to Process: ${cardResult.imagesProcessed || 0}`);
236:       console.log(`Images to Update: ${cardResult.imagesUpdated || 0}`);
237:     } else if (options.skipImages) {
238:       console.log("\nData Processing:");
239:       console.log(`Cards to Update: ${cardResult.cardCount}`);
240:       console.log(`Prices to Update: ${priceResult.cardCount}`);
241:     } else {
242:       console.log("\nFull Sync Processing:");
243:       console.log(`Cards to Update: ${cardResult.cardCount}`);
244:       console.log(`Prices to Update: ${priceResult.cardCount}`);
245:       console.log(`Images to Process: ${cardResult.imagesProcessed || 0}`);
246:       console.log(`Images to Update: ${cardResult.imagesUpdated || 0}`);
247:     }
248: 
249:     // Perform Updates if not dry run
250:     if (!options.isDryRun) {
251:       console.log("\nPerforming Updates:");
252:       console.log("------------------");
253: 
254:       console.log("Creating backup...");
255:       await resetDatabase();
256: 
257:       // Perform Card/Image Updates
258:       const cardUpdateResult = await syncCards({
259:         dryRun: false,
260:         skipImages: options.skipImages,
261:         imagesOnly: options.imagesOnly,
262:         silent: !options.isVerbose,
263:         force: options.isForce,
264:         groupId: options.groupId,
265:       });
266: 
267:       // Perform Price Updates (skip if images-only)
268:       const priceUpdateResult = !options.imagesOnly ?
269:         await syncPrices({
270:           dryRun: false,
271:           silent: !options.isVerbose,
272:           force: options.isForce,
273:           groupId: options.groupId,
274:         }) :
275:         {
276:           cardCount: 0,
277:           groupsUpdated: 0,
278:           errors: [],
279:         };
280: 
281:       // Display Update Results
282:       console.log("\nUpdate Results:");
283:       console.log("--------------");
284: 
285:       if (options.imagesOnly) {
286:         console.log(
287:           `Images Processed: ${cardUpdateResult.imagesProcessed || 0}`
288:         );
289:         console.log(`Images Updated: ${cardUpdateResult.imagesUpdated || 0}`);
290:       } else if (options.skipImages) {
291:         console.log(`Cards Updated: ${cardUpdateResult.cardCount}`);
292:         console.log(`Groups Updated: ${cardUpdateResult.groupsUpdated}`);
293:         console.log(`Price Records Updated: ${priceUpdateResult.cardCount}`);
294:       } else {
295:         console.log(`Cards Updated: ${cardUpdateResult.cardCount}`);
296:         console.log(`Groups Updated: ${cardUpdateResult.groupsUpdated}`);
297:         console.log(`Price Records Updated: ${priceUpdateResult.cardCount}`);
298:         console.log(
299:           `Images Processed: ${cardUpdateResult.imagesProcessed || 0}`
300:         );
301:         console.log(`Images Updated: ${cardUpdateResult.imagesUpdated || 0}`);
302:       }
303: 
304:       // Display any errors encountered
305:       if (
306:         cardUpdateResult.errors.length > 0 ||
307:         priceUpdateResult.errors.length > 0
308:       ) {
309:         console.log("\nErrors encountered:");
310:         [...cardUpdateResult.errors, ...priceUpdateResult.errors].forEach(
311:           (error) => {
312:             console.log(`- ${error}`);
313:           }
314:         );
315:       }
316:     } else {
317:       console.log("\nThis was a dry run - no changes were made");
318:       console.log("Run without --dry-run flag to perform updates");
319:     }
320: 
321:     // Calculate and display duration
322:     const duration = (Date.now() - startTime) / 1000;
323:     console.log("\nOperation Summary:");
324:     console.log("-----------------");
325:     console.log(`Total Duration: ${duration.toFixed(2)} seconds`);
326:     console.log(`Mode: ${summary.mode.type.toUpperCase()}`);
327:     console.log(`Operation Type: ${options.isDryRun ? "Analysis" : "Update"}`);
328:     if (options.groupId) {
329:       console.log(`Processed Group: ${options.groupId}`);
330:     }
331:     if (options.limit) {
332:       console.log(`Limit Applied: ${options.limit}`);
333:     }
334:     console.log(`Total Cards Processed: ${cardResult.cardCount}`);
335:     if (cardResult.imagesProcessed) {
336:       console.log(`Images Processed: ${cardResult.imagesProcessed}`);
337:       console.log(`Images Updated: ${cardResult.imagesUpdated || 0}`);
338:     }
339:   } catch (error) {
340:     const genericError: GenericError = {
341:       message: error instanceof Error ? error.message : "Unknown error",
342:       name: error instanceof Error ? error.name : "UnknownError",
343:       code: error instanceof Error ? error.name : "UNKNOWN_ERROR",
344:       stack: error instanceof Error ? error.stack : undefined,
345:     };
346:     console.error("\nError:", genericError.message);
347:     await logError(genericError, "Database refresh failed");
348:     throw error;
349:   }
350: }
351: 
352: // Function to handle environment checks
353: function checkEnvironment(): void {
354:   if (!process.env.FUNCTIONS_EMULATOR && !process.env.NODE_ENV) {
355:     console.warn("\nWarning: Running in production environment");
356:     console.warn("Set NODE_ENV=development for local testing");
357:   }
358: 
359:   if (process.env.RESTRICT_BANDWIDTH === "true") {
360:     console.warn("\nWarning: Bandwidth restrictions are enabled");
361:     console.warn("Image processing may be limited");
362:   }
363: }
364: 
365: // Main execution
366: if (require.main === module) {
367:   checkEnvironment();
368:   refreshDatabase()
369:     .then(() => {
370:       console.log("\nOperation completed successfully!");
371:       process.exit(0);
372:     })
373:     .catch((error) => {
374:       console.error("\nFatal error:", error);
375:       process.exit(1);
376:     });
377: }
378: 
379: // Export additional utilities for testing and external use
380: export const utils = {
381:   parseCommandLineArgs,
382:   validateOptions,
383:   getSyncMode,
384:   checkEnvironment,
385: };
</file>

<file path="src/utils/databaseReset.ts">
 1: // src/utils/databaseReset.ts
 2: import {db, COLLECTION} from "../config/firebase";
 3: import {backupDatabase} from "./databaseBackup";
 4: import {logInfo, logError} from "./logger";
 5: import {GenericError} from "../types";
 6: 
 7: async function deleteCollection(collectionName: string): Promise<void> {
 8:   const batchSize = 500;
 9:   const query = db.collection(collectionName).limit(batchSize);
10:   let deletedCount = 0;
11:   let hasMore = true;
12: 
13:   try {
14:     while (hasMore) {
15:       const snapshot = await query.get();
16: 
17:       if (snapshot.empty) {
18:         hasMore = false;
19:         continue;
20:       }
21: 
22:       const batch = db.batch();
23:       snapshot.docs.forEach((doc) => {
24:         batch.delete(doc.ref);
25:         deletedCount++;
26:       });
27: 
28:       await batch.commit();
29:       await logInfo(`Deleted ${deletedCount} documents from ${collectionName}`);
30:     }
31: 
32:     await logInfo(`Finished deleting collection ${collectionName}`);
33:   } catch (error) {
34:     const genericError: GenericError = {
35:       message: error instanceof Error ? error.message : "Unknown error",
36:       name: error instanceof Error ? error.name : "UnknownError",
37:       code: error instanceof Error ? error.name : "UNKNOWN_ERROR",
38:       stack: error instanceof Error ? error.stack : undefined,
39:     };
40:     await logError(
41:       genericError,
42:       `Failed to delete collection ${collectionName}`
43:     );
44:     throw error;
45:   }
46: }
47: 
48: export async function resetDatabase(): Promise<void> {
49:   try {
50:     // First, create a backup
51:     await backupDatabase();
52: 
53:     // Then delete all collections
54:     await Promise.all([
55:       deleteCollection(COLLECTION.CARDS),
56:       deleteCollection(COLLECTION.PRICES),
57:       deleteCollection(COLLECTION.SYNC_METADATA),
58:       deleteCollection(COLLECTION.CARD_HASHES),
59:       deleteCollection(COLLECTION.PRICE_HASHES),
60:       deleteCollection(COLLECTION.IMAGE_METADATA),
61:     ]);
62: 
63:     await logInfo("Database reset completed successfully");
64:   } catch (error) {
65:     const genericError: GenericError = {
66:       message: error instanceof Error ? error.message : "Unknown error",
67:       name: error instanceof Error ? error.name : "UnknownError",
68:       code: error instanceof Error ? error.name : "UNKNOWN_ERROR",
69:       stack: error instanceof Error ? error.stack : undefined,
70:     };
71:     await logError(genericError, "Database reset failed");
72:     throw error;
73:   }
74: }
</file>

<file path="src/utils/error.ts">
 1: import {db, COLLECTION} from "../config/firebase";
 2: import {logError} from "./logger";
 3: 
 4: export interface ErrorReport {
 5:   timestamp: Date;
 6:   context: string;
 7:   error: string;
 8:   stackTrace?: string;
 9:   metadata?: Record<string, unknown>;
10:   severity: "ERROR" | "WARNING" | "CRITICAL";
11: }
12: 
13: export class DetailedError extends Error {
14:   constructor(
15:     message: string,
16:     public context: string,
17:     public metadata?: Record<string, unknown>,
18:     public severity: "ERROR" | "WARNING" | "CRITICAL" = "ERROR"
19:   ) {
20:     super(message);
21:     this.name = "DetailedError";
22:   }
23: }
24: 
25: export async function logDetailedError(
26:   error: Error,
27:   context: string,
28:   metadata?: Record<string, unknown>,
29:   severity: "ERROR" | "WARNING" | "CRITICAL" = "ERROR"
30: ): Promise<void> {
31:   const report: ErrorReport = {
32:     timestamp: new Date(),
33:     context,
34:     error: error.message,
35:     stackTrace: error.stack,
36:     metadata,
37:     severity,
38:   };
39: 
40:   // Log to Firestore
41:   await db.collection(COLLECTION.LOGS)
42:     .add(report);
43: 
44:   // Log using existing logger
45:   await logError(error, context);
46: }
</file>

<file path="src/utils/imageAccessibilityChecker.ts">
 1: // src/utils/imageAccessibilityChecker.ts
 2: import axios from "axios";
 3: import {logInfo, logWarning} from "./logger";
 4: 
 5: export interface AccessibilityResult {
 6:   isAccessible: boolean;
 7:   statusCode?: number;
 8:   error?: string;
 9:   headers?: Record<string, string>;
10: }
11: 
12: export class ImageAccessibilityChecker {
13:   static async checkUrl(url: string): Promise<AccessibilityResult> {
14:     try {
15:       const response = await axios.head(url, {
16:         timeout: 5000,
17:         validateStatus: () => true, // Don't throw on any status
18:       });
19: 
20:       const isAccessible = response.status === 200;
21:       const result: AccessibilityResult = {
22:         isAccessible,
23:         statusCode: response.status,
24:         headers: response.headers as Record<string, string>,
25:       };
26: 
27:       if (isAccessible) {
28:         await logInfo("URL accessibility check passed", {
29:           url,
30:           status: response.status,
31:           contentType: response.headers["content-type"],
32:           contentLength: response.headers["content-length"],
33:         });
34:       } else {
35:         await logWarning("URL accessibility check failed", {
36:           url,
37:           status: response.status,
38:         });
39:       }
40: 
41:       return result;
42:     } catch (error) {
43:       await logWarning("URL accessibility check error", {
44:         url,
45:         error: error instanceof Error ? error.message : "Unknown error",
46:       });
47: 
48:       return {
49:         isAccessible: false,
50:         error: error instanceof Error ? error.message : "Unknown error",
51:       };
52:     }
53:   }
54: }
</file>

<file path="src/utils/imageCache.ts">
  1: // src/utils/imageCache.ts
  2: 
  3: import LRUCache from "lru-cache";
  4: import {ImageMetadata} from "../types";
  5: import {logInfo} from "./logger";
  6: 
  7: interface CacheStats {
  8:   hits: number;
  9:   misses: number;
 10:   totalRequests: number;
 11: }
 12: 
 13: export class ImageCache {
 14:   private metadataCache: LRUCache<string, ImageMetadata>;
 15:   private bufferCache: LRUCache<string, Buffer>;
 16:   private existsCache: LRUCache<string, boolean>;
 17:   private stats: CacheStats = {
 18:     hits: 0,
 19:     misses: 0,
 20:     totalRequests: 0,
 21:   };
 22: 
 23:   constructor() {
 24:     this.metadataCache = new LRUCache<string, ImageMetadata>({
 25:       max: 1000,
 26:       ttl: 1000 * 60 * 60, // 1 hour
 27:       updateAgeOnGet: true,
 28:     });
 29: 
 30:     this.bufferCache = new LRUCache<string, Buffer>({
 31:       max: 100,
 32:       ttl: 1000 * 60 * 5, // 5 minutes
 33:       updateAgeOnGet: true,
 34:       maxSize: 50 * 1024 * 1024, // 50MB max cache size
 35:       sizeCalculation: (buffer) => buffer.length,
 36:     });
 37: 
 38:     this.existsCache = new LRUCache<string, boolean>({
 39:       max: 1000,
 40:       ttl: 1000 * 60 * 60, // 1 hour
 41:       updateAgeOnGet: true,
 42:     });
 43:   }
 44: 
 45:   getMetadataCacheKey(
 46:     groupId: string,
 47:     productId: number,
 48:     cardNumber: string,
 49:     isHighRes: boolean
 50:   ): string {
 51:     return `metadata:${groupId}:${productId}:${cardNumber}:${
 52:       isHighRes ? "high" : "original"
 53:     }`;
 54:   }
 55: 
 56:   getBufferCacheKey(url: string): string {
 57:     return `buffer:${url}`;
 58:   }
 59: 
 60:   getExistsCacheKey(
 61:     groupId: string,
 62:     productId: number,
 63:     cardNumber: string,
 64:     isHighRes: boolean
 65:   ): string {
 66:     return `exists:${groupId}:${productId}:${cardNumber}:${
 67:       isHighRes ? "high" : "original"
 68:     }`;
 69:   }
 70: 
 71:   async getMetadata(key: string): Promise<ImageMetadata | undefined> {
 72:     this.stats.totalRequests++;
 73:     const value = this.metadataCache.get(key);
 74:     if (value) {
 75:       this.stats.hits++;
 76:       await logInfo("Cache hit: metadata", {
 77:         key,
 78:         timestamp: new Date().toISOString(),
 79:       });
 80:     } else {
 81:       this.stats.misses++;
 82:     }
 83:     return value;
 84:   }
 85: 
 86:   async getBuffer(key: string): Promise<Buffer | undefined> {
 87:     this.stats.totalRequests++;
 88:     const value = this.bufferCache.get(key);
 89:     if (value) {
 90:       this.stats.hits++;
 91:       await logInfo("Cache hit: buffer", {
 92:         key,
 93:         size: value.length,
 94:         timestamp: new Date().toISOString(),
 95:       });
 96:     } else {
 97:       this.stats.misses++;
 98:     }
 99:     return value;
100:   }
101: 
102:   getExists(key: string): boolean | undefined {
103:     this.stats.totalRequests++;
104:     const value = this.existsCache.get(key);
105:     if (value !== undefined) {
106:       this.stats.hits++;
107:     } else {
108:       this.stats.misses++;
109:     }
110:     return value;
111:   }
112: 
113:   setMetadata(key: string, value: ImageMetadata): void {
114:     this.metadataCache.set(key, value);
115:   }
116: 
117:   setBuffer(key: string, value: Buffer): void {
118:     this.bufferCache.set(key, value);
119:   }
120: 
121:   setExists(key: string, value: boolean): void {
122:     this.existsCache.set(key, value);
123:   }
124: 
125:   clear(): void {
126:     this.metadataCache.clear();
127:     this.bufferCache.clear();
128:     this.existsCache.clear();
129:     this.stats = {
130:       hits: 0,
131:       misses: 0,
132:       totalRequests: 0,
133:     };
134:   }
135: 
136:   getStats(): CacheStats {
137:     return {...this.stats};
138:   }
139: }
140: 
141: export const imageCache = new ImageCache();
</file>

<file path="src/utils/imageCompressor.ts">
 1: // src/utils/imageCompressor.ts
 2: 
 3: import sharp from "sharp";
 4: import {logInfo} from "./logger";
 5: 
 6: export interface CompressionResult {
 7:   buffer: Buffer;
 8:   info: {
 9:     width: number;
10:     height: number;
11:     size: number;
12:     format: string;
13:     quality: number;
14:   };
15: }
16: 
17: export class ImageCompressor {
18:   private static readonly QUALITY = {
19:     HIGH_RES: 90,
20:     LOW_RES: 85,
21:   };
22: 
23:   private static readonly DIMENSIONS = {
24:     HIGH_RES: 400,
25:     LOW_RES: 200,
26:   };
27: 
28:   static async compress(
29:     buffer: Buffer,
30:     isHighRes: boolean = false
31:   ): Promise<CompressionResult> {
32:     try {
33:       const quality = isHighRes ? this.QUALITY.HIGH_RES : this.QUALITY.LOW_RES;
34:       const targetWidth = isHighRes ? this.DIMENSIONS.HIGH_RES : this.DIMENSIONS.LOW_RES;
35: 
36:       const originalInfo = await sharp(buffer).metadata();
37:       const originalSize = buffer.length;
38: 
39:       const image = sharp(buffer).jpeg({
40:         quality,
41:         progressive: true,
42:         mozjpeg: true,
43:       });
44: 
45:       if (originalInfo.width && originalInfo.width > targetWidth) {
46:         image.resize(targetWidth, null, {
47:           fit: "inside",
48:           withoutEnlargement: true,
49:         });
50:       }
51: 
52:       const compressedBuffer = await image.toBuffer();
53:       const compressedInfo = await sharp(compressedBuffer).metadata();
54: 
55:       await logInfo("Image compression complete", {
56:         originalSize,
57:         compressedSize: compressedBuffer.length,
58:         dimensions: `${compressedInfo.width}x${compressedInfo.height}`,
59:         quality,
60:         timestamp: new Date().toISOString(),
61:       });
62: 
63:       return {
64:         buffer: compressedBuffer,
65:         info: {
66:           width: compressedInfo.width || 0,
67:           height: compressedInfo.height || 0,
68:           size: compressedBuffer.length,
69:           format: compressedInfo.format || "jpeg",
70:           quality,
71:         },
72:       };
73:     } catch (error) {
74:       throw new Error(
75:         `Image compression failed: ${error instanceof Error ? error.message : "Unknown error"}`
76:       );
77:     }
78:   }
79: 
80:   static async isCompressible(buffer: Buffer): Promise<boolean> {
81:     try {
82:       const info = await sharp(buffer).metadata();
83:       return info.format === "jpeg" || info.format === "jpg";
84:     } catch {
85:       return false;
86:     }
87:   }
88: }
</file>

<file path="src/utils/imageHandler.ts">
  1: import axios, {AxiosError} from "axios";
  2: import {logError, logInfo, logWarning} from "./logger";
  3: import * as crypto from "crypto";
  4: import * as fs from "fs/promises";
  5: import * as path from "path";
  6: import {
  7:   ImageMetadata,
  8:   ImageProcessingResult,
  9:   PlaceholderImageRecord,
 10:   GenericError,
 11: } from "../types";
 12: import {r2Storage} from "../services/r2Storage";
 13: import {db, COLLECTION} from "../config/firebase";
 14: import sharp from "sharp";
 15: 
 16: export interface ImagePathOptions {
 17:   groupId: string;
 18:   productId: number;
 19:   cardNumber: string;
 20:   isHighRes?: boolean;
 21:   isLowRes?: boolean;
 22:   isNonCard?: boolean;
 23: }
 24: 
 25: export class ImageHandler {
 26:   private readonly PLACEHOLDER_IMAGE_PATH =
 27:     "/public/assets/image-coming-soon.jpeg";
 28:   private readonly MISSING_IMAGE_IDENTIFIER = "image-missing.svg";
 29:   private readonly MAX_IMAGE_SIZE = 10 * 1024 * 1024; // 10MB
 30: 
 31:   private async loadPlaceholderImage(): Promise<Buffer> {
 32:     try {
 33:       const imagePath = path.join(process.cwd(), this.PLACEHOLDER_IMAGE_PATH);
 34:       return await fs.readFile(imagePath);
 35:     } catch (error) {
 36:       throw new Error(
 37:         `Failed to load placeholder image: ${
 38:           error instanceof Error ? error.message : "Unknown error"
 39:         }`
 40:       );
 41:     }
 42:   }
 43: 
 44:   private async recordPlaceholderUse(
 45:     productId: number,
 46:     groupId: string,
 47:     cardNumber: string,
 48:     originalUrl?: string
 49:   ): Promise<void> {
 50:     const record: PlaceholderImageRecord = {
 51:       productId,
 52:       groupId,
 53:       name: cardNumber,
 54:       timestamp: new Date(),
 55:       originalUrl,
 56:     };
 57: 
 58:     try {
 59:       await db
 60:         .collection(COLLECTION.IMAGE_METADATA)
 61:         .doc(`placeholder_${productId}`)
 62:         .set(record);
 63:     } catch (error) {
 64:       await logWarning("Failed to record placeholder use", {
 65:         productId,
 66:         groupId,
 67:         error: error instanceof Error ? error.message : "Unknown error",
 68:       });
 69:     }
 70:   }
 71: 
 72:   private isPlaceholderNeeded(imageUrl: string): boolean {
 73:     return (
 74:       !imageUrl ||
 75:       imageUrl.includes("image-missing.svg") ||
 76:       imageUrl.endsWith(this.MISSING_IMAGE_IDENTIFIER)
 77:     );
 78:   }
 79: 
 80:   private sanitizeCardNumber(cardNumber: string | undefined): string {
 81:     if (!cardNumber) {
 82:       throw new Error("Card number is required");
 83:     }
 84:     return cardNumber.replace(/\//g, "_");
 85:   }
 86: 
 87:   private validateImageUrl(url: string): { isValid: boolean; error?: string } {
 88:     if (!url) {
 89:       return {isValid: false, error: "No URL provided"};
 90:     }
 91: 
 92:     if (!url.match(/.*\.(jpg|jpeg|svg)$/i)) {
 93:       return {
 94:         isValid: false,
 95:         error: "URL does not match expected format (.jpg, .jpeg, .svg)",
 96:       };
 97:     }
 98: 
 99:     return {isValid: true};
100:   }
101: 
102:   private getStoragePath(options: ImagePathOptions): string {
103:     let suffix = "_200w"; // default to low res
104:     if (options.isHighRes) {
105:       suffix = "_400w";
106:     }
107: 
108:     // For non-card products, use a different path structure
109:     if (options.isNonCard) {
110:       return `${options.groupId}/products/${options.productId}${suffix}.jpg`;
111:     }
112: 
113:     return `${options.groupId}/cards/${
114:       options.productId
115:     }_${this.sanitizeCardNumber(options.cardNumber)}${suffix}.jpg`;
116:   }
117: 
118:   private async getImageHash(imageBuffer: Buffer): Promise<string> {
119:     return crypto.createHash("md5").update(imageBuffer).digest("hex");
120:   }
121: 
122:   private async downloadImage(url: string): Promise<Buffer> {
123:     try {
124:       // Convert URL to high-res version if it's not already
125:       const highResUrl = url.replace("_200w.jpg", "_400w.jpg");
126: 
127:       const response = await axios.get(highResUrl, {
128:         responseType: "arraybuffer",
129:         timeout: 30000,
130:         maxContentLength: this.MAX_IMAGE_SIZE,
131:       });
132:       return Buffer.from(response.data, "binary");
133:     } catch (error) {
134:       // If 400w fails, try falling back to original URL
135:       if (error instanceof AxiosError && error.response?.status === 404) {
136:         const response = await axios.get(url, {
137:           responseType: "arraybuffer",
138:           timeout: 30000,
139:           maxContentLength: this.MAX_IMAGE_SIZE,
140:         });
141:         return Buffer.from(response.data, "binary");
142:       }
143:       if (error instanceof AxiosError) {
144:         if (error.response?.status === 404) {
145:           throw new Error(`Image not found at URL: ${url}`);
146:         }
147:         throw new Error(
148:           `Failed to download image: ${error.message} (Status: ${error.response?.status})`
149:         );
150:       }
151:       throw error;
152:     }
153:   }
154: 
155:   private async processImage(
156:     imageBuffer: Buffer,
157:     productId: number,
158:     groupId: string
159:   ): Promise<{
160:     highResBuffer: Buffer;
161:     lowResBuffer: Buffer;
162:     metadata: ImageMetadata;
163:   }> {
164:     // Validate image using sharp
165:     const metadata = await sharp(imageBuffer).metadata();
166:     if (!metadata.format || !["jpeg", "jpg"].includes(metadata.format)) {
167:       throw new Error("Invalid image format. Only JPEG images are supported.");
168:     }
169: 
170:     // Process high-res version (400px width)
171:     const highResBuffer = await sharp(imageBuffer)
172:       .resize(400, null, {fit: "inside", withoutEnlargement: true})
173:       .jpeg({quality: 85, progressive: true})
174:       .toBuffer();
175: 
176:     // Process low-res version (200px width)
177:     const lowResBuffer = await sharp(imageBuffer)
178:       .resize(200, null, {fit: "inside", withoutEnlargement: true})
179:       .jpeg({quality: 80, progressive: true})
180:       .toBuffer();
181: 
182:     const originalHash = await this.getImageHash(imageBuffer);
183: 
184:     const imageMetadata: ImageMetadata = {
185:       contentType: "image/jpeg",
186:       size: imageBuffer.length,
187:       updated: new Date(),
188:       hash: originalHash,
189:       groupId,
190:       productId,
191:       originalSize: imageBuffer.length,
192:       highResSize: highResBuffer.length,
193:       lowResSize: lowResBuffer.length,
194:     };
195: 
196:     return {
197:       highResBuffer,
198:       lowResBuffer,
199:       metadata: imageMetadata,
200:     };
201:   }
202: 
203:   public async processAndStoreImage(
204:     imageUrl: string,
205:     productId: number,
206:     groupId: string,
207:     cardNumber: string,
208:     isNonCard: boolean = false
209:   ): Promise<ImageProcessingResult> {
210:     try {
211:       // Check if placeholder is needed
212:       if (this.isPlaceholderNeeded(imageUrl)) {
213:         return await this.handlePlaceholderImage(
214:           productId,
215:           groupId,
216:           cardNumber
217:         );
218:       }
219: 
220:       // Validate URL
221:       const urlValidation = this.validateImageUrl(imageUrl);
222:       if (!urlValidation.isValid) {
223:         throw new Error(urlValidation.error);
224:       }
225: 
226:       // Download and process image
227:       const imageBuffer = await this.downloadImage(imageUrl);
228:       const {highResBuffer, lowResBuffer, metadata} = await this.processImage(
229:         imageBuffer,
230:         productId,
231:         groupId
232:       );
233: 
234:       // Upload to R2
235:       const [highResUrl, lowResUrl] = await Promise.all([
236:         r2Storage.uploadImage(
237:           highResBuffer,
238:           this.getStoragePath({
239:             groupId,
240:             productId,
241:             cardNumber,
242:             isHighRes: true,
243:             isNonCard,
244:           }),
245:           metadata
246:         ),
247:         r2Storage.uploadImage(
248:           lowResBuffer,
249:           this.getStoragePath({
250:             groupId,
251:             productId,
252:             cardNumber,
253:             isLowRes: true,
254:             isNonCard,
255:           }),
256:           metadata
257:         ),
258:       ]);
259: 
260:       await logInfo("Image processed and stored", {
261:         productId,
262:         groupId,
263:         cardNumber,
264:         highResUrl,
265:         lowResUrl,
266:       });
267: 
268:       return {
269:         highResUrl,
270:         lowResUrl,
271:         metadata,
272:         updated: true,
273:       };
274:     } catch (error) {
275:       const errorObj: GenericError = {
276:         message: error instanceof Error ? error.message : "Unknown error",
277:         name: error instanceof Error ? error.name : "UnknownError",
278:         code: "IMAGE_PROCESSING_ERROR",
279:       };
280:       await logError(errorObj, "Image processing failed");
281: 
282:       return this.handlePlaceholderImage(
283:         productId,
284:         groupId,
285:         cardNumber,
286:         imageUrl
287:       );
288:     }
289:   }
290: 
291:   private async handlePlaceholderImage(
292:     productId: number,
293:     groupId: string,
294:     cardNumber: string,
295:     originalUrl?: string
296:   ): Promise<ImageProcessingResult> {
297:     try {
298:       const placeholderBuffer = await this.loadPlaceholderImage();
299:       const {highResBuffer, lowResBuffer, metadata} = await this.processImage(
300:         placeholderBuffer,
301:         productId,
302:         groupId
303:       );
304: 
305:       metadata.isPlaceholder = true;
306: 
307:       const [highResUrl, lowResUrl] = await Promise.all([
308:         r2Storage.uploadImage(
309:           highResBuffer,
310:           this.getStoragePath({
311:             groupId,
312:             productId,
313:             cardNumber,
314:             isHighRes: true,
315:           }),
316:           metadata
317:         ),
318:         r2Storage.uploadImage(
319:           lowResBuffer,
320:           this.getStoragePath({
321:             groupId,
322:             productId,
323:             cardNumber,
324:             isLowRes: true,
325:           }),
326:           metadata
327:         ),
328:       ]);
329: 
330:       await this.recordPlaceholderUse(
331:         productId,
332:         groupId,
333:         cardNumber,
334:         originalUrl
335:       );
336: 
337:       return {
338:         highResUrl,
339:         lowResUrl,
340:         metadata,
341:         updated: true,
342:         isPlaceholder: true,
343:       };
344:     } catch (error) {
345:       const errorObj: GenericError = {
346:         message: error instanceof Error ? error.message : "Unknown error",
347:         name: error instanceof Error ? error.name : "UnknownError",
348:         code: "PLACEHOLDER_PROCESSING_ERROR",
349:       };
350:       await logError(errorObj, "Placeholder image processing failed");
351:       throw error;
352:     }
353:   }
354: 
355:   public async getPlaceholderStats(): Promise<{
356:     total: number;
357:     byGroup: Record<string, number>;
358:   }> {
359:     try {
360:       const snapshot = await db
361:         .collection(COLLECTION.IMAGE_METADATA)
362:         .where("isPlaceholder", "==", true)
363:         .get();
364: 
365:       const stats = {
366:         total: snapshot.size,
367:         byGroup: {} as Record<string, number>,
368:       };
369: 
370:       snapshot.forEach((doc) => {
371:         const data = doc.data() as PlaceholderImageRecord;
372:         stats.byGroup[data.groupId] = (stats.byGroup[data.groupId] || 0) + 1;
373:       });
374: 
375:       return stats;
376:     } catch (error) {
377:       const errorObj: GenericError = {
378:         message: error instanceof Error ? error.message : "Unknown error",
379:         name: error instanceof Error ? error.name : "UnknownError",
380:         code: "STATS_ERROR",
381:       };
382:       await logError(errorObj, "Failed to get placeholder stats");
383:       return {total: 0, byGroup: {}};
384:     }
385:   }
386: }
387: 
388: export const imageHandler = new ImageHandler();
</file>

<file path="src/utils/imageMigration.ts">
 1: import {db, COLLECTION} from "../config/firebase";
 2: import {logError, logInfo} from "./logger";
 3: import {imageHandler} from "./imageHandler";
 4: import {CardProduct} from "../types";
 5: import {isNonCardProduct} from "./productValidation";
 6: 
 7: function getCardNumber(product: CardProduct): string {
 8:   // Skip card number validation for non-card products
 9:   if (isNonCardProduct(product.name)) {
10:     return product.productId.toString();
11:   }
12: 
13:   const numberField = product.extendedData.find(
14:     (data) => data.name === "Number"
15:   );
16:   if (!numberField) {
17:     throw new Error(`Missing card number for productId: ${product.productId}`);
18:   }
19:   return numberField.value;
20: }
21: 
22: export async function migrateImages(): Promise<void> {
23:   try {
24:     const snapshot = await db.collection(COLLECTION.CARDS).get();
25:     let processed = 0;
26:     let failed = 0;
27: 
28:     for (const doc of snapshot.docs) {
29:       const card = doc.data() as CardProduct;
30: 
31:       try {
32:         if (!card.imageUrl) {
33:           continue;
34:         }
35: 
36:         const isNonCard = isNonCardProduct(card.name);
37:         const cardNumber = isNonCard ?
38:           card.productId.toString() :
39:           getCardNumber(card);
40: 
41:         // Use the new processAndStoreImage method
42:         const result = await imageHandler.processAndStoreImage(
43:           card.imageUrl,
44:           card.productId,
45:           card.groupId.toString(),
46:           cardNumber
47:         );
48: 
49:         // Update the document with new URLs
50:         await doc.ref.update({
51:           highResUrl: result.highResUrl,
52:           lowResUrl: result.lowResUrl,
53:           imageMetadata: result.metadata,
54:           lastUpdated: new Date(),
55:           imageUrl: null, // Remove the old imageUrl
56:         });
57: 
58:         await logInfo("Migrated image", {
59:           productId: card.productId,
60:           groupId: card.groupId,
61:           highResUrl: result.highResUrl,
62:           lowResUrl: result.lowResUrl,
63:           updated: result.updated,
64:         });
65: 
66:         processed++;
67:       } catch (error) {
68:         failed++;
69:         await logError(
70:           {
71:             message: error instanceof Error ? error.message : "Unknown error",
72:             name: error instanceof Error ? error.name : "UnknownError",
73:             code: "IMAGE_MIGRATION_ERROR",
74:           },
75:           `Failed to migrate image for ${card.productId}`
76:         );
77:       }
78:     }
79: 
80:     await logInfo("Migration completed", {
81:       processed,
82:       failed,
83:       total: snapshot.size,
84:     });
85:   } catch (error) {
86:     await logError(
87:       {
88:         message: error instanceof Error ? error.message : "Unknown error",
89:         name: error instanceof Error ? error.name : "UnknownError",
90:         code: "MIGRATION_ERROR",
91:       },
92:       "Failed to complete migration"
93:     );
94:     throw error;
95:   }
96: }
</file>

<file path="src/utils/imageValidator.ts">
 1: import {ImageMetadata} from "../types";
 2: import {logWarning} from "./logger";
 3: 
 4: export class ImageValidator {
 5:   static readonly MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB
 6:   static readonly ALLOWED_FORMATS = ["jpeg", "jpg"] as const;
 7:   static readonly REQUIRED_METADATA = [
 8:     "contentType",
 9:     "size",
10:     "updated",
11:     "hash",
12:   ] as const;
13: 
14:   static validateSize(size: number): boolean {
15:     if (size <= 0) {
16:       logWarning("Invalid file size", {size});
17:       return false;
18:     }
19: 
20:     if (size > ImageValidator.MAX_FILE_SIZE) {
21:       logWarning("File too large", {
22:         size,
23:         maxSize: ImageValidator.MAX_FILE_SIZE,
24:       });
25:       return false;
26:     }
27: 
28:     return true;
29:   }
30: 
31:   static validateFormat(format: string): boolean {
32:     const normalizedFormat = format.toLowerCase();
33:     if (!ImageValidator.ALLOWED_FORMATS.includes(normalizedFormat as any)) {
34:       logWarning("Invalid format", {
35:         format,
36:         allowedFormats: ImageValidator.ALLOWED_FORMATS,
37:       });
38:       return false;
39:     }
40:     return true;
41:   }
42: 
43:   static validateMetadata(metadata: Partial<ImageMetadata>): boolean {
44:     const missingFields = ImageValidator.REQUIRED_METADATA.filter(
45:       (field: keyof ImageMetadata) => !metadata[field]
46:     );
47: 
48:     if (missingFields.length > 0) {
49:       logWarning("Missing required metadata fields", {missingFields});
50:       return false;
51:     }
52: 
53:     return true;
54:   }
55: }
</file>

<file path="src/utils/logger.ts">
  1: import * as functions from "firebase-functions";
  2: import {db, COLLECTION} from "../config/firebase";
  3: import {GenericError, LogData, GenericObject} from "../types";
  4: 
  5: export const logger = functions.logger;
  6: 
  7: interface LogEntry {
  8:   timestamp: Date;
  9:   level: "INFO" | "WARNING" | "ERROR";
 10:   message: string;
 11:   context?: string;
 12:   data?: Record<string, unknown>;
 13: }
 14: 
 15: function cleanLogData(
 16:   data: Record<string, unknown>,
 17:   depth = 0
 18: ): Record<string, unknown> {
 19:   // Prevent infinite recursion
 20:   if (depth > 10) {
 21:     return {error: "Maximum recursion depth exceeded"};
 22:   }
 23: 
 24:   // Handle null or undefined
 25:   if (!data) {
 26:     return {};
 27:   }
 28: 
 29:   try {
 30:     return Object.entries(data).reduce((acc, [key, value]) => {
 31:       // Skip undefined and null values
 32:       if (value === undefined || value === null) {
 33:         return acc;
 34:       }
 35: 
 36:       // Handle different types of values
 37:       if (value instanceof Date) {
 38:         acc[key] = value.toISOString();
 39:       } else if (typeof value === "function") {
 40:         // Skip functions
 41:         return acc;
 42:       } else if (Array.isArray(value)) {
 43:         // Handle arrays
 44:         acc[key] = value.map((item) =>
 45:           typeof item === "object" && item !== null ?
 46:             cleanLogData(item as Record<string, unknown>, depth + 1) :
 47:             item
 48:         );
 49:       } else if (typeof value === "object") {
 50:         // Handle objects
 51:         try {
 52:           // Check if object can be safely converted to string
 53:           JSON.stringify(value);
 54:           acc[key] = cleanLogData(value as Record<string, unknown>, depth + 1);
 55:         } catch (e) {
 56:           // If circular reference is detected, return a simplified version
 57:           acc[key] = "[Circular]";
 58:         }
 59:       } else {
 60:         // Handle primitive values
 61:         acc[key] = value;
 62:       }
 63: 
 64:       return acc;
 65:     }, {} as Record<string, unknown>);
 66:   } catch (error) {
 67:     // If any error occurs during cleaning, return a simplified object
 68:     return {
 69:       error: "Error cleaning log data",
 70:       message: error instanceof Error ? error.message : "Unknown error",
 71:     };
 72:   }
 73: }
 74: 
 75: async function saveLogEntry(entry: LogEntry): Promise<void> {
 76:   try {
 77:     const cleanEntry = {
 78:       timestamp: entry.timestamp,
 79:       level: entry.level,
 80:       message: entry.message,
 81:       ...(entry.context && {context: entry.context}),
 82:       ...(entry.data && {data: cleanLogData(entry.data)}),
 83:     };
 84: 
 85:     await db.collection(COLLECTION.LOGS).add(cleanEntry);
 86:   } catch (error) {
 87:     console.error("Error saving log entry:", error);
 88:   }
 89: }
 90: 
 91: export const logError = async (
 92:   error: GenericError | GenericObject,
 93:   context: string
 94: ) => {
 95:   try {
 96:     const errorData = cleanLogData({
 97:       stack: error.stack,
 98:       code: error.code,
 99:       ...(error as GenericObject),
100:       timestamp: new Date().toISOString(),
101:     });
102: 
103:     const entry: LogEntry = {
104:       timestamp: new Date(),
105:       level: "ERROR",
106:       message: error.message || "Unknown error",
107:       context,
108:       data: errorData,
109:     };
110: 
111:     logger.error(entry.message, errorData);
112:     await saveLogEntry(entry);
113:   } catch (e) {
114:     console.error("Error in logError:", e);
115:   }
116: };
117: 
118: export const logInfo = async (message: string, data?: LogData) => {
119:   try {
120:     const cleanedData = data ?
121:       cleanLogData({
122:         ...data,
123:         timestamp: new Date().toISOString(),
124:       }) :
125:       undefined;
126: 
127:     const entry: LogEntry = {
128:       timestamp: new Date(),
129:       level: "INFO",
130:       message,
131:       ...(cleanedData &&
132:         Object.keys(cleanedData).length > 0 && {data: cleanedData}),
133:     };
134: 
135:     logger.info(message, cleanedData);
136:     await saveLogEntry(entry);
137:   } catch (e) {
138:     console.error("Error in logInfo:", e);
139:   }
140: };
141: 
142: export const logWarning = async (message: string, data?: LogData) => {
143:   try {
144:     const cleanedData = data ?
145:       cleanLogData({
146:         ...data,
147:         timestamp: new Date().toISOString(),
148:       }) :
149:       undefined;
150: 
151:     const entry: LogEntry = {
152:       timestamp: new Date(),
153:       level: "WARNING",
154:       message,
155:       ...(cleanedData &&
156:         Object.keys(cleanedData).length > 0 && {data: cleanedData}),
157:     };
158: 
159:     logger.warn(message, cleanedData);
160:     await saveLogEntry(entry);
161:   } catch (e) {
162:     console.error("Error in logWarning:", e);
163:   }
164: };
</file>

<file path="src/utils/productValidation.ts">
 1: // src/utils/productValidation.ts
 2: import {CardProduct} from "../types";
 3: 
 4: export interface ProductValidationResult {
 5:   isValid: boolean;
 6:   reason?: string;
 7:   isNonCard?: boolean;
 8: }
 9: 
10: const NON_CARD_KEYWORDS = [
11:   "booster",
12:   "box",
13:   "pack",
14:   "bundle",
15:   "collection",
16:   "starter deck",
17:   "boss deck",
18:   "display",
19:   "case",
20:   "kit",
21: ];
22: 
23: export function isNonCardProduct(name: string): boolean {
24:   return NON_CARD_KEYWORDS.some((keyword) =>
25:     name.toLowerCase().includes(keyword.toLowerCase())
26:   );
27: }
28: 
29: export function validateFFTCGProduct(
30:   product: CardProduct
31: ): ProductValidationResult {
32:   // Check if product name contains non-card keywords
33:   if (isNonCardProduct(product.name)) {
34:     return {
35:       isValid: true,
36:       isNonCard: true,
37:       reason: `Product is a ${NON_CARD_KEYWORDS.find((k) =>
38:         product.name.toLowerCase().includes(k.toLowerCase())
39:       )}`,
40:     };
41:   }
42: 
43:   // Try to extract and validate card number from extendedData
44:   try {
45:     const numberField = product.extendedData.find(
46:       (data) => data.name === "Number"
47:     );
48: 
49:     if (!numberField) {
50:       return {
51:         isValid: false,
52:         reason: `Missing card number for productId: ${product.productId}`,
53:       };
54:     }
55: 
56:     // Check if it's a promo card
57:     const isPromo = product.extendedData.some(
58:       (data) => data.name === "extNumber"
59:     );
60: 
61:     if (isPromo) {
62:       const extNumber = product.extendedData.find(
63:         (data) => data.name === "extNumber"
64:       );
65:       if (!extNumber) {
66:         return {
67:           isValid: false,
68:           reason: `Missing extNumber for promo productId: ${product.productId}`,
69:         };
70:       }
71:     }
72: 
73:     return {isValid: true, isNonCard: false};
74:   } catch (error) {
75:     return {
76:       isValid: false,
77:       reason: `Failed to validate card: ${
78:         error instanceof Error ? error.message : "Unknown error"
79:       }`,
80:     };
81:   }
82: }
</file>

<file path="src/utils/progress.ts">
 1: // src/utils/progress.ts
 2: 
 3: import {logInfo} from "./logger";
 4: 
 5: export interface ProgressStats {
 6:   current: number;
 7:   total: number;
 8:   percent: number;
 9:   elapsed: number;
10:   rate: number;
11:   remaining: number;
12:   eta: number;
13: }
14: 
15: export class EnhancedProgressTracker {
16:   private startTime: number;
17:   private current: number;
18:   private estimates: number[] = [];
19:   private lastUpdate: number;
20:   private updateInterval: number;
21: 
22:   constructor(
23:     private total: number,
24:     private description: string,
25:     options: { updateInterval?: number } = {}
26:   ) {
27:     this.startTime = Date.now();
28:     this.current = 0;
29:     this.lastUpdate = Date.now();
30:     this.updateInterval = options.updateInterval || 1000; // Default 1 second
31:   }
32: 
33:   private calculateStats(): ProgressStats {
34:     const now = Date.now();
35:     const elapsed = (now - this.startTime) / 1000;
36:     const percent = (this.current / this.total) * 100;
37:     const rate = this.current / elapsed;
38:     const remaining = this.total - this.current;
39:     const eta = remaining / rate;
40: 
41:     return {
42:       current: this.current,
43:       total: this.total,
44:       percent,
45:       elapsed,
46:       rate,
47:       remaining,
48:       eta,
49:     };
50:   }
51: 
52:   update(amount = 1): void {
53:     const now = Date.now();
54:     this.current += amount;
55: 
56:     // Only update log if enough time has passed
57:     if (now - this.lastUpdate >= this.updateInterval) {
58:       const stats = this.calculateStats();
59:       this.estimates.push(stats.eta);
60: 
61:       // Keep only last 10 estimates for averaging
62:       if (this.estimates.length > 10) {
63:         this.estimates.shift();
64:       }
65: 
66:       const avgEta = this.estimates.reduce((a, b) => a + b, 0) / this.estimates.length;
67: 
68:       logInfo(
69:         `${this.description}: ${stats.current}/${stats.total} ` +
70:         `(${stats.percent.toFixed(1)}%) - ${stats.remaining} remaining - ` +
71:         `ETA: ${avgEta.toFixed(1)}s - Rate: ${stats.rate.toFixed(1)}/s`
72:       );
73: 
74:       this.lastUpdate = now;
75:     }
76:   }
77: 
78:   getProgress(): ProgressStats {
79:     return this.calculateStats();
80:   }
81: }
</file>

<file path="src/utils/syncLogger.ts">
  1: interface CardDetails {
  2:   id: number;
  3:   name: string;
  4:   groupId: string;
  5:   cardNumber: string;
  6:   normalPrice?: number;
  7:   foilPrice?: number;
  8:   rawPrices: Array<{
  9:     type: string;
 10:     price: number;
 11:     groupId: string;
 12:   }>;
 13:   highResUrl?: string;
 14:   lowResUrl?: string;
 15: }
 16: 
 17: interface SyncLoggerOptions {
 18:   type: "manual" | "scheduled" | "both";
 19:   limit?: number;
 20:   dryRun?: boolean;
 21:   groupId?: string;
 22:   batchSize?: number;
 23: }
 24: 
 25: interface SyncResults {
 26:   success: number;
 27:   failures: number;
 28:   groupId?: string;
 29:   type: string;
 30:   imagesProcessed?: number;
 31:   imagesUpdated?: number;
 32: }
 33: 
 34: export class SyncLogger {
 35:   private startTime: number;
 36:   private cards: CardDetails[] = [];
 37:   private groups: Map<string, { products: number; prices: number }> = new Map();
 38: 
 39:   constructor(private options: SyncLoggerOptions) {
 40:     this.startTime = Date.now();
 41:   }
 42: 
 43:   async start(): Promise<void> {
 44:     console.log("\nStarting sync operation...");
 45:     console.log(`Type: ${this.options.type}`);
 46:     if (this.options.limit) console.log(`Limit: ${this.options.limit} cards`);
 47:     if (this.options.groupId) console.log(`Group ID: ${this.options.groupId}`);
 48:     console.log(`Dry Run: ${this.options.dryRun ? "Yes" : "No"}`);
 49:     console.log("\n=== Processing Data ===");
 50:   }
 51: 
 52:   async logGroupFound(totalGroups: number): Promise<void> {
 53:     if (this.options.groupId) {
 54:       console.log(`Processing group ${this.options.groupId}`);
 55:     } else {
 56:       console.log(`Found ${totalGroups} groups to process`);
 57:     }
 58:   }
 59: 
 60:   async logGroupDetails(
 61:     groupId: string,
 62:     products: number,
 63:     prices: number
 64:   ): Promise<void> {
 65:     if (!this.options.groupId || this.options.groupId === groupId) {
 66:       this.groups.set(groupId, {products, prices});
 67:       console.log(`Group ${groupId}: ${products} products, ${prices} prices`);
 68:     }
 69:   }
 70: 
 71:   async logCardDetails(details: CardDetails): Promise<void> {
 72:     if (!this.options.groupId || this.options.groupId === details.groupId) {
 73:       this.cards.push(details);
 74:       if (this.cards.length === 1) {
 75:         console.log("\n=== Card Details ===");
 76:       }
 77: 
 78:       console.log(`\nCard: ${details.name}`);
 79:       console.log(`ID: ${details.id}`);
 80:       if (details.cardNumber) console.log(`Number: ${details.cardNumber}`);
 81:       console.log(`Group: ${details.groupId}`);
 82: 
 83:       if (details.rawPrices.length > 0) {
 84:         console.log("Prices:");
 85:         details.rawPrices.forEach((price) => {
 86:           console.log(`  ${price.type}: $${price.price.toFixed(2)}`);
 87:         });
 88:       }
 89: 
 90:       if (details.highResUrl || details.lowResUrl) {
 91:         console.log("Images:");
 92:         if (details.highResUrl) {
 93:           console.log(`  High Res: ${details.highResUrl}`);
 94:         }
 95:         if (details.lowResUrl) {
 96:           console.log(`  Low Res: ${details.lowResUrl}`);
 97:         }
 98:       }
 99:     }
100:   }
101: 
102:   async logManualSyncStart(): Promise<void> {
103:     console.log("\n=== Starting Manual Sync ===");
104:     if (this.options.groupId) {
105:       console.log(`Filtering for group: ${this.options.groupId}`);
106:     }
107:     if (this.options.dryRun) {
108:       console.log("DRY RUN MODE - No data will be modified");
109:     }
110:     if (this.options.limit) {
111:       console.log(`Limited to ${this.options.limit} cards`);
112:     }
113:     if (this.options.batchSize) {
114:       console.log(`Batch size: ${this.options.batchSize}`);
115:     }
116:     console.log();
117:   }
118: 
119:   async logSyncResults(results: SyncResults): Promise<void> {
120:     const duration = (Date.now() - this.startTime) / 1000;
121: 
122:     console.log("\n=== Sync Results ===");
123:     console.log(`Operation: ${results.type}`);
124:     if (results.groupId) {
125:       console.log(`Group: ${results.groupId}`);
126:     }
127:     console.log(`Duration: ${duration.toFixed(1)} seconds`);
128:     console.log(`Successful Operations: ${results.success}`);
129:     console.log(`Failed Operations: ${results.failures}`);
130: 
131:     if (typeof results.imagesProcessed === "number") {
132:       console.log("\nImage Processing:");
133:       console.log(`Total Processed: ${results.imagesProcessed}`);
134:       console.log(`Updated: ${results.imagesUpdated || 0}`);
135:       console.log(
136:         `Unchanged: ${results.imagesProcessed - (results.imagesUpdated || 0)}`
137:       );
138:     }
139: 
140:     if (this.cards.length > 0) {
141:       console.log(`\nProcessed Cards: ${this.cards.length}`);
142:       const withImages = this.cards.filter(
143:         (card) => card.highResUrl || card.lowResUrl
144:       ).length;
145:       console.log(`Cards with Images: ${withImages}`);
146:       console.log(`Cards without Images: ${this.cards.length - withImages}`);
147:     }
148:   }
149: 
150:   async finish(): Promise<void> {
151:     const totalDuration = (Date.now() - this.startTime) / 1000;
152:     console.log("\n=== Operation Complete ===");
153:     console.log(`Total Duration: ${totalDuration.toFixed(1)} seconds`);
154: 
155:     if (this.options.dryRun) {
156:       console.log("\nThis was a dry run - no changes were made");
157:       console.log("Remove --dry-run flag to perform actual updates");
158:     }
159:   }
160: }
</file>

<file path="src/utils/syncUtils.ts">
  1: import axios, {isAxiosError} from "axios";
  2: import {logWarning} from "./logger";
  3: 
  4: // Centralized constants
  5: export const BASE_URL = "https://tcgcsv.com/tcgplayer"; // Base URL without category
  6: export const MAX_RETRIES = 3;
  7: export const BASE_DELAY = 1000;
  8: 
  9: /**
 10:  * Validates and constructs full paths for TCGCSV requests.
 11:  */
 12: export function constructTCGCSVPath(endpoint: string): string {
 13:   // Remove any leading slashes
 14:   endpoint = endpoint.replace(/^\/+/, "");
 15: 
 16:   // Construct the full URL
 17:   return `${BASE_URL}/${endpoint}`;
 18: }
 19: 
 20: /**
 21:  * Validates and fixes document IDs, including promo cards.
 22:  */
 23: export function validateAndFixDocumentId(
 24:   productId: number,
 25:   cardNumber: string
 26: ): string {
 27:   if (!productId || !cardNumber) {
 28:     throw new Error(
 29:       "Missing productId or cardNumber for document ID generation."
 30:     );
 31:   }
 32: 
 33:   const sanitizedCardNumber = cardNumber.replace(/\//g, "_");
 34:   return `${productId}_${sanitizedCardNumber}`;
 35: }
 36: 
 37: /**
 38:  * Handles network requests with retries.
 39:  */
 40: export async function makeRequest<T>(
 41:   endpoint: string,
 42:   options: { retryCount?: number; customDelay?: number } = {}
 43: ): Promise<T> {
 44:   const {retryCount = 0, customDelay = BASE_DELAY} = options;
 45: 
 46:   try {
 47:     const url = constructTCGCSVPath(endpoint);
 48:     await new Promise((resolve) => setTimeout(resolve, customDelay));
 49: 
 50:     const response = await axios.get<T>(url, {
 51:       timeout: 30000,
 52:       headers: {
 53:         "Accept": "application/json",
 54:         "User-Agent": "FFTCG-Sync-Service/1.0",
 55:         "Origin": "https://fftcgcompanion.com",
 56:       },
 57:       validateStatus: (status) => {
 58:         return status < 500; // Don't retry on client errors (4xx)
 59:       },
 60:     });
 61: 
 62:     // Check for 403 specifically
 63:     if (response.status === 403) {
 64:       throw new Error(`Access denied to TCGCSV API at path: ${url}`);
 65:     }
 66: 
 67:     return response.data;
 68:   } catch (error) {
 69:     if (
 70:       retryCount < MAX_RETRIES - 1 &&
 71:       (!isAxiosError(error) || error.response?.status !== 403)
 72:     ) {
 73:       const delay = Math.pow(2, retryCount) * BASE_DELAY;
 74:       await logWarning(`Request failed, retrying in ${delay}ms...`, {
 75:         endpoint,
 76:         attempt: retryCount + 1,
 77:         maxRetries: MAX_RETRIES,
 78:         error: error instanceof Error ? error.message : "Unknown error",
 79:       });
 80:       return makeRequest<T>(endpoint, {
 81:         retryCount: retryCount + 1,
 82:         customDelay: delay,
 83:       });
 84:     }
 85:     throw error;
 86:   }
 87: }
 88: 
 89: export async function processBatch<T>(
 90:   items: T[],
 91:   processFn: (batch: T[]) => Promise<void>,
 92:   options: {
 93:     batchSize?: number;
 94:     onBatchComplete?: (stats: {
 95:       processed: number;
 96:       total: number;
 97:     }) => Promise<void>;
 98:   } = {}
 99: ): Promise<void> {
100:   const batchSize = options.batchSize || 500; // Default batch size
101:   const totalItems = items.length;
102: 
103:   for (let i = 0; i < totalItems; i += batchSize) {
104:     const batch = items.slice(i, i + batchSize);
105:     await processFn(batch);
106: 
107:     if (options.onBatchComplete) {
108:       await options.onBatchComplete({
109:         processed: i + batch.length,
110:         total: totalItems,
111:       });
112:     }
113:   }
114: }
</file>

<file path="tsconfig.dev.json">
1: {
2:   "extends": "./tsconfig.json",
3:   "include": [
4:     ".eslintrc.js",
5:     ".eslintrc.fix.js",
6:     ".eslintrc.base.cjs"
7:   ]
8: }
</file>

<file path="tsconfig.json">
 1: {
 2:   "compilerOptions": {
 3:     "module": "commonjs",
 4:     "noImplicitReturns": true,
 5:     "noUnusedLocals": true,
 6:     "outDir": "lib",
 7:     "sourceMap": true,
 8:     "strict": true,
 9:     "target": "es2017",
10:     "esModuleInterop": true,
11:     "skipLibCheck": true,
12:     "types": ["node", "express"],
13:     "baseUrl": "./src",
14:     "lib": ["es2017", "dom"],
15:     "typeRoots": [
16:       "./node_modules/@types",
17:       "./src/types"
18:     ]
19:   },
20:   "compileOnSave": true,
21:   "include": [
22:     "src/**/*",
23:     ".eslintrc.js",
24:     ".eslintrc.fix.js",
25:     ".eslintrc.base.cjs"
26:   ],
27:   "exclude": [
28:     "node_modules",
29:     "lib"
30:   ]
31: }
</file>

</repository_files>
